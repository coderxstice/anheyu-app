# 评论排序规则文档

## 📋 目录

- [概述](#概述)
- [核心概念](#核心概念)
- [数据结构](#数据结构)
- [排序规则](#排序规则)
- [前端实现](#前端实现)
- [后端实现](#后端实现)
- [边缘案例](#边缘案例)
- [部署指南](#部署指南)

---

## 概述

本文档描述了博客评论系统的排序规则，旨在实现**对话连贯性优先**的评论展示方式，让用户从上到下阅读时能够流畅地跟随对话脉络。

### 🎯 设计目标

1. **对话连贯性**：回复评论应紧跟在被回复的评论下方
2. **时间敏感性**：新评论应优先展示（在同等条件下）
3. **热度优先**：回复多的对话链应优先展示
4. **稳定性**：点击"加载更多"时，已显示的评论不应改变顺序

### 📊 评论层级

```
顶级评论（文章/页面）
└─ 二级评论（链头）← 直接回复顶级评论
   ├─ 三级评论 ← 回复链头
   │  └─ 四级评论 ← 回复三级
   └─ 另一个三级评论

注意：前端显示最多2层（链头 + 展开的回复）
```

---

## 核心概念

### 1. 链头（Chain Head）

**定义**：直接回复顶级评论的评论，即 `reply_to_id === 顶级评论ID`

**作用**：作为对话链的入口点，决定评论的主要排序

**示例**：

```
顶级评论 A (id: A)
├─ 评论 B (reply_to_id: A) ← 链头 1
├─ 评论 C (reply_to_id: A) ← 链头 2
└─ 评论 D (reply_to_id: A) ← 链头 3
```

### 2. 对话链（Conversation Chain）

**定义**：从链头开始的完整回复序列

**示例**：

```
链头 B (reply_to_id: A)
└─ 评论 E (reply_to_id: B)
   └─ 评论 F (reply_to_id: E)

这是一条完整的对话链：B → E → F
```

### 3. 权重（Weight）

**定义**：链头下的所有回复数量（递归计算）

**计算方法**：遍历链头的所有直接回复，然后递归计算每个回复的子回复数量，最终累加得出总权重。

### 4. 预览模式（Preview Mode）

**定义**：只显示前 N 个链头及其完整对话链的展示模式

**触发条件**：`page === 1 && pageSize <= 3`

**目的**：提供快速预览，避免一次性加载过多数据

---

## 数据结构

### Comment 表结构

评论表包含以下关键字段：

- `id`：主键
- `content`：评论内容（纯文本）
- `content_html`：评论内容（HTML 格式）
- `target_path`：目标路径（文章/页面标识）
- `target_title`：目标标题
- `parent_id`：父评论 ID（定义层级关系）
- `reply_to_id`：回复目标 ID（定义对话关系）
- `nickname`：评论者昵称
- `email`：评论者邮箱
- `website`：个人网站
- `ip_address`：IP 地址
- `user_agent`：用户代理
- `status`：状态（published/pending 等）
- `is_admin_author`：是否为管理员评论
- `is_anonymous`：是否匿名
- `like_count`：点赞数
- `created_at`：创建时间
- `updated_at`：更新时间
- `pinned_at`：置顶时间

**重要索引**：

- `target_path`：用于快速查询某文章/页面的评论
- `parent_id`：用于查找子评论
- `reply_to_id`：用于构建对话链
- `created_at`：用于排序

### 关键字段说明

#### `parent_id` vs `reply_to_id`

| 字段          | 用途                     | 示例                     |
| ------------- | ------------------------ | ------------------------ |
| `parent_id`   | 定义层级关系（树形结构） | 用于查找某评论的所有子孙 |
| `reply_to_id` | 定义对话关系（对话流）   | 用于显示"回复 @xxx"      |

**示例场景**：

```
A (顶级评论)
├─ B (parent_id: A, reply_to_id: A) ← 回复A
   └─ C (parent_id: A, reply_to_id: B) ← 在A下面，但回复的是B

显示效果：
A
├─ B "回复 @A"
└─ C "回复 @B"  ← reply_to_id 决定显示的昵称
```

### 数据接口

评论对象包含以下字段：

**基础字段**：

- `id`：公开 ID
- `created_at`：创建时间
- `nickname`：昵称
- `email_md5`：邮箱 MD5（用于头像）
- `website`：个人网站（可选）
- `content_html`：HTML 内容
- `is_admin_comment`：是否管理员评论
- `is_anonymous`：是否匿名

**关系字段**：

- `target_path`：目标路径
- `target_title`：目标标题（可选）
- `parent_id`：父评论 ID
- `reply_to_id`：回复目标 ID
- `reply_to_nick`：回复目标昵称（可选）

**统计字段**：

- `like_count`：点赞数
- `total_children`：子评论总数
- `children`：子评论列表（可选）

**前端扩展字段**（用于 UI 展示）：

- `_hasReplies`：是否有回复
- `_repliesCount`：回复数量
- `_replies`：回复列表

---

## 排序规则

### 顶级评论排序

**规则**：按创建时间倒序（最新的在最上面）

**原因**：用户最关心最新的评论

---

### 二级评论排序（核心）

#### 第一步：识别链头

从所有子评论中筛选出链头评论，即 `reply_to_id` 等于顶级评论 ID 或为空的评论。

#### 第二步：计算权重

为每个链头计算权重，权重等于该链头下所有回复的总数（递归计算）。同时标记链头是否有回复。

#### 第三步：链头排序

**规则**：优先按时间倒序，权重差距显著时按权重排序

**排序逻辑**：

1. 计算两个链头的时间戳
2. 如果权重差距较大（>= 5 条回复），则按权重降序排序（热门对话优先）
3. 否则按时间倒序排序（保持稳定性）

**设计理由**：

- **默认时间优先**：保证顺序稳定，避免评论跳动
- **热度突出**：当某个对话明显更热门时（差距 ≥5 条），优先展示

#### 第四步：展开对话链（深度优先）

**展开规则**：

1. 创建链数组，将链头作为第一个元素
2. 获取该评论的所有直接回复
3. 将回复按时间正序排序（老的在前，符合对话顺序）
4. 深度优先遍历，递归展开每个回复
5. 返回完整的对话链

**示例**：

```
输入：
B (10:00) ← 链头
├─ C (10:01) ← 回复B
│  └─ D (10:03) ← 回复C
└─ E (10:02) ← 回复B

输出：
[B, C, D, E]

解释：深度优先 + 时间正序
1. B (链头)
2. C (B的第一个回复，10:01)
3. D (C的回复，10:03)
4. E (B的第二个回复，10:02)
```

---

### 完整排序流程图

```
顶级评论 A
  ↓
获取所有子评论 (children)
  ↓
识别链头（reply_to_id === A）
  ↓
计算每个链头的权重
  ↓
链头排序（时间优先，热度辅助）
  ↓
深度优先展开每个链头的对话链
  ↓
最终排序结果
```

---

## 前端实现

### 核心组件

#### 1. CommentItem.vue

**职责**：

- 显示单条顶级评论
- 对子评论进行排序
- 处理"加载更多子评论"

**核心逻辑**：

1. **响应式数据**：使用 `watchEffect` 自动响应评论数据变化
2. **构建关系映射**：
   - 识别链头（`reply_to_id` 等于顶级评论 ID）
   - 构建回复关系映射表（`reply_to_id` -> 回复列表）
3. **权重计算**：递归计算每个链头的所有回复数量
4. **链头排序**：按权重和时间进行排序
5. **展开对话链**：深度优先展开每个链头的完整对话链
6. **稳定性处理**：
   - 判断是否为"加载更多"操作
   - 如果是首次渲染：直接使用新排序结果
   - 如果是加载更多：保持已显示评论顺序，新评论追加到末尾

**关键特性**：

- 忽略 `reply_to` 目标不在当前数组中的孤儿评论
- 为每个链头添加扩展字段（`_hasReplies`、`_repliesCount`、`_replies`）
- 通过比对 ID 集合判断是否为"加载更多"操作

#### 2. ReplyItem.vue

**职责**：

- 显示单条回复评论
- 展开/收起子回复
- 处理回复表单

**核心特性**：

- 平级显示展开的回复（最多 2 层）
- 自动展开回复表单时的上下文

---

## 后端实现

### 预览逻辑

**位置**：`pkg/service/comment/service.go` - `ListChildren` 方法

**核心流程**：

1. **获取所有后代评论**：递归查找父评论的所有子孙评论
2. **判断预览模式**：当 `page === 1` 且 `pageSize <= 3` 时启用预览模式
3. **预览模式处理**：
   - 识别所有链头（`reply_to_id` 等于父评论 ID 或为空）
   - 对链头按创建时间倒序排序
   - 取前 N 个链头（N 为 `pageSize`，最多 3 个）
   - 递归收集每个链头的完整对话链
4. **正常分页模式**：
   - 按时间倒序对所有后代评论排序
   - 根据分页参数返回对应范围的评论
5. **组装响应**：将评论转换为 DTO 并返回

**递归收集对话链的逻辑**：

- 标记已选中的评论 ID，避免重复
- 将链头加入结果集
- 递归查找所有回复该评论的评论
- 将它们也加入结果集

### 预览模式示例

**输入**：

```
顶级评论有6条子评论：
- B (10:00, reply_to: A) ← 链头1
- C (10:05, reply_to: A) ← 链头2
  - D (10:06, reply_to: C)
  - E (10:07, reply_to: D)
- F (10:10, reply_to: A) ← 链头3
  - G (10:11, reply_to: F)
```

**输出**（previewLimit=3）：

```
返回6条评论：
- F (链头3，最新)
  - G (F的回复)
- C (链头2)
  - D (C的回复)
  - E (D的回复)
- B (链头1，最老)
```

**关键点**：

- ✅ 只返回前 3 个链头
- ✅ 每个链头的完整对话链都返回
- ✅ 前端收到的是可以直接展示的完整数据

---

## 边缘案例

### 案例 1：孤儿评论

**场景**：某条评论的 `reply_to_id` 指向的评论不在当前数据中

**示例**：

```
预览模式返回：
- 评论A (reply_to: 顶级)
- 评论B (reply_to: C)  ← 孤儿（C不在数据中）
```

**处理方式**：

- **前端**：忽略孤儿评论（不显示）
- **后端**：预览模式不应返回孤儿评论（只返回完整对话链）

**原因**：孤儿评论会破坏对话连贯性

---

### 案例 2：新发表评论

**场景**：用户发表新评论后，前端直接添加到列表

**处理方式**：

1. 找到新评论的父评论
2. 将新评论添加到父评论的 `children` 数组末尾
3. 响应式系统自动触发排序算法
4. 新评论会被正确排序到合适位置

**关键点**：

- ✅ 新评论添加到 `children` 数组末尾
- ✅ `sortedChildren` 的 `watchEffect` 自动触发重新排序
- ✅ 因为是新评论（ID 不在 `previousSortedIds` 中），会被正确排序

---

### 案例 3：点击"加载更多"

**场景**：用户点击"加载更多子评论"按钮

**判断逻辑**：

判断是否为"加载更多"操作需要同时满足：

1. 不是首次加载（`previousSortedIds` 不为空）
2. 所有旧 ID 仍然存在（`previousSortedIds` 中的 ID 都在新数据中）
3. 有新 ID 出现（新数据中有 `previousSortedIds` 中不存在的 ID）

**处理方式**：

1. 按原顺序保留已显示的评论
2. 将新加载的评论按排序结果追加到末尾

**效果**：

```
加载前（3条）：    加载后（6条）：
A                  A  ← 保持原位
B                  B  ← 保持原位
C                  C  ← 保持原位
                   D  ← 新加载，追加到末尾
                   E  ← 新加载，追加到末尾
                   F  ← 新加载，追加到末尾
```

---

### 案例 4：展开回复

**场景**：用户点击某条评论的"展开回复"按钮

**数据变化**：

```
展开前：
- 链头 A (_hasReplies: true, _replies: [B, C, D])

展开后：
ReplyItem 组件渲染 _replies：
- 链头 A
  - B (从 _replies 渲染)
  - C (从 _replies 渲染)
  - D (从 _replies 渲染)
```

**关键点**：

- ✅ 数据本身没有变化（`children` 不变）
- ✅ 只是 UI 状态变化（`isRepliesExpanded`）
- ✅ 不会触发重新排序

---

## 部署指南

### 数据库迁移

#### 1. 添加 `reply_to_id` 字段

需要在评论表中添加 `reply_to_id` 字段：

- 字段类型：BIGINT
- 位置：在 `parent_id` 字段之后
- 可为空：是

同时需要创建索引以优化查询性能：

- 为 `reply_to_id` 字段创建索引

可选：添加外键约束，确保数据完整性（删除评论时自动将回复的 `reply_to_id` 设为 NULL）

#### 2. 数据迁移（可选）

为保证向后兼容，可以将现有评论的 `reply_to_id` 设置为 `parent_id` 的值。这样旧评论也能正常显示在新的排序系统中。

### 前端部署

**步骤**：

1. **更新依赖**：无需额外依赖
2. **重新编译**：进入 `assets` 目录，运行构建命令
3. **部署静态文件**：将 `dist` 目录部署到服务器

### 后端部署

**步骤**：

1. **编译**：编译 Go 程序为可执行文件
2. **重启服务**：重启应用服务
3. **验证**：测试评论 API 接口，确认预览模式工作正常

**验证方法**：访问评论子评论接口，传入 `page=1&page_size=3` 参数，验证返回的是前 3 个链头及其完整对话链

### 验证清单

- [ ] 数据库字段已添加
- [ ] 后端编译成功
- [ ] 前端编译成功
- [ ] 预览模式返回正确数据（前 3 个链头+完整对话链）
- [ ] 点击"加载更多"后顺序保持稳定
- [ ] 新发表评论显示在正确位置
- [ ] 展开/收起回复功能正常

---

## 测试场景

### 测试 1：基本排序

**准备数据**：

```
A (顶级，10:00)
├─ B (10:01, reply_to: A) ← 链头1
├─ C (10:05, reply_to: A) ← 链头2
│  └─ D (10:06, reply_to: C)
└─ E (10:10, reply_to: A) ← 链头3
```

**预期显示**：

```
A
├─ E (最新链头)
├─ C (第二新)
│  └─ D (C的回复)
└─ B (最老链头)
```

**验证**：

- [ ] 链头按时间倒序
- [ ] D 紧跟在 C 下面

---

### 测试 2：权重排序

**准备数据**：

```
A (顶级)
├─ B (10:01, 0条回复) ← 链头1
├─ C (10:02, 10条回复) ← 链头2
└─ D (10:03, 1条回复) ← 链头3
```

**预期显示**：

```
A
├─ C (权重最高，10条回复)
├─ D (时间最新)
└─ B (时间最老)
```

**验证**：

- [ ] 权重差距 ≥5 时，C 排在最前
- [ ] B 和 D 按时间排序

---

### 测试 3：加载更多

**步骤**：

1. 刷新页面，预览显示前 3 个链头
2. 点击"加载更多子评论"
3. 验证已显示的 3 个链头保持原位
4. 新加载的链头追加到末尾

**验证**：

- [ ] 已显示评论不移动
- [ ] 新评论追加到末尾
- [ ] 不会出现重复评论

---

### 测试 4：展开回复

**步骤**：

1. 找到一条有回复的链头（显示"展开 N 条回复"按钮）
2. 点击展开
3. 验证回复平级显示

**验证**：

- [ ] 回复显示在链头下方
- [ ] 回复按时间正序（老的在前）
- [ ] 最多显示 2 层（不再缩进）

---

## 常见问题

### Q1：为什么链头按时间倒序，而回复按时间正序？

**A**：

- **链头时间倒序**：让用户先看到最新的对话
- **回复时间正序**：保持对话的自然流向（从老到新阅读）

---

### Q2：为什么权重阈值是 5？

**A**：5 条回复是一个经验值，表示"显著的热度差异"：

- 小于 5：可能只是偶然的差异，保持时间顺序更稳定
- 大于等于 5：说明这个对话明显更受关注，应该优先展示

可以根据实际数据调整这个阈值。

---

### Q3：为什么前端要判断"加载更多"？

**A**：为了保证**顺序稳定性**：

- 首次加载：完全按排序规则排序
- 加载更多：保持已显示评论的位置，避免用户困惑

---

### Q4：为什么预览模式不直接返回最新的 3 条评论？

**A**：因为"最新的 3 条评论"可能是：

- 某条深层回复（孤儿）
- 不同对话链的片段

这样前端无法构建完整的对话流。预览模式返回"前 3 个链头+完整对话链"，确保数据的完整性。

---

## 性能优化

### 前端优化

1. **虚拟滚动**（可选）：

   - 当评论数量超过 100 条时启用
   - 只渲染可见区域的评论
   - 减少 DOM 节点数量，提升渲染性能

2. **懒加载图片**：

   - 评论中的图片使用懒加载
   - 减少首屏加载时间
   - 提升页面初始渲染速度

3. **防抖/节流**：
   - "加载更多"按钮添加防抖
   - 避免重复请求
   - 减少服务器压力

### 后端优化

1. **查询优化**：

   - 为 `parent_id` 和 `created_at` 字段创建联合索引
   - 使用索引加速查询和排序
   - 避免全表扫描

2. **缓存策略**：

   - 对热门文章的评论进行缓存
   - 建议缓存时间：5 分钟
   - 减少数据库查询压力

3. **分页限制**：
   - 设置 `pageSize` 最大值为 50
   - 避免一次性查询过多数据
   - 保护数据库和服务器资源

---

## 版本历史

### v1.0.0 (2025-10-26)

- ✅ 实现基本排序规则
- ✅ 添加 `reply_to_id` 字段
- ✅ 实现预览模式
- ✅ 实现"加载更多"稳定性
- ✅ 实现展开/收起回复功能

---

## 参考资料

- [Vue 3 官方文档](https://vuejs.org/)
- [Go Ent 框架](https://entgo.io/)
- [评论系统最佳实践](https://ux.stackexchange.com/questions/124520/best-practices-for-comment-threading)

---

## 维护者

- **作者**：安知鱼
- **项目**：AnheyuBlog
- **更新日期**：2025-10-26

---

**📝 注意**：本文档描述的是当前版本的实现。如有任何疑问或改进建议，请提交 Issue 或 Pull Request。
