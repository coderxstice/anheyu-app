// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/anzhiyu-c/anheyu-app/ent/album"
	"github.com/anzhiyu-c/anheyu-app/ent/article"
	"github.com/anzhiyu-c/anheyu-app/ent/comment"
	"github.com/anzhiyu-c/anheyu-app/ent/directlink"
	"github.com/anzhiyu-c/anheyu-app/ent/entity"
	"github.com/anzhiyu-c/anheyu-app/ent/file"
	"github.com/anzhiyu-c/anheyu-app/ent/fileentity"
	"github.com/anzhiyu-c/anheyu-app/ent/link"
	"github.com/anzhiyu-c/anheyu-app/ent/linkcategory"
	"github.com/anzhiyu-c/anheyu-app/ent/linktag"
	"github.com/anzhiyu-c/anheyu-app/ent/metadata"
	"github.com/anzhiyu-c/anheyu-app/ent/page"
	"github.com/anzhiyu-c/anheyu-app/ent/postcategory"
	"github.com/anzhiyu-c/anheyu-app/ent/posttag"
	"github.com/anzhiyu-c/anheyu-app/ent/predicate"
	"github.com/anzhiyu-c/anheyu-app/ent/setting"
	"github.com/anzhiyu-c/anheyu-app/ent/storagepolicy"
	"github.com/anzhiyu-c/anheyu-app/ent/tag"
	"github.com/anzhiyu-c/anheyu-app/ent/urlstat"
	"github.com/anzhiyu-c/anheyu-app/ent/user"
	"github.com/anzhiyu-c/anheyu-app/ent/usergroup"
	"github.com/anzhiyu-c/anheyu-app/ent/userinstalledtheme"
	"github.com/anzhiyu-c/anheyu-app/ent/visitorlog"
	"github.com/anzhiyu-c/anheyu-app/ent/visitorstat"
	"github.com/anzhiyu-c/anheyu-app/pkg/domain/model"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlbum              = "Album"
	TypeArticle            = "Article"
	TypeComment            = "Comment"
	TypeDirectLink         = "DirectLink"
	TypeEntity             = "Entity"
	TypeFile               = "File"
	TypeFileEntity         = "FileEntity"
	TypeLink               = "Link"
	TypeLinkCategory       = "LinkCategory"
	TypeLinkTag            = "LinkTag"
	TypeMetadata           = "Metadata"
	TypePage               = "Page"
	TypePostCategory       = "PostCategory"
	TypePostTag            = "PostTag"
	TypeSetting            = "Setting"
	TypeStoragePolicy      = "StoragePolicy"
	TypeTag                = "Tag"
	TypeURLStat            = "URLStat"
	TypeUser               = "User"
	TypeUserGroup          = "UserGroup"
	TypeUserInstalledTheme = "UserInstalledTheme"
	TypeVisitorLog         = "VisitorLog"
	TypeVisitorStat        = "VisitorStat"
)

// AlbumMutation represents an operation that mutates the Album nodes in the graph.
type AlbumMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	deleted_at        *time.Time
	created_at        *time.Time
	updated_at        *time.Time
	image_url         *string
	big_image_url     *string
	download_url      *string
	thumb_param       *string
	big_param         *string
	tags              *string
	view_count        *int
	addview_count     *int
	download_count    *int
	adddownload_count *int
	width             *int
	addwidth          *int
	height            *int
	addheight         *int
	file_size         *int64
	addfile_size      *int64
	format            *string
	aspect_ratio      *string
	file_hash         *string
	display_order     *int
	adddisplay_order  *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Album, error)
	predicates        []predicate.Album
}

var _ ent.Mutation = (*AlbumMutation)(nil)

// albumOption allows management of the mutation configuration using functional options.
type albumOption func(*AlbumMutation)

// newAlbumMutation creates new mutation for the Album entity.
func newAlbumMutation(c config, op Op, opts ...albumOption) *AlbumMutation {
	m := &AlbumMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumID sets the ID field of the mutation.
func withAlbumID(id uint) albumOption {
	return func(m *AlbumMutation) {
		var (
			err   error
			once  sync.Once
			value *Album
		)
		m.oldValue = func(ctx context.Context) (*Album, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Album.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbum sets the old Album of the mutation.
func withAlbum(node *Album) albumOption {
	return func(m *AlbumMutation) {
		m.oldValue = func(context.Context) (*Album, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Album entities.
func (m *AlbumMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Album.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AlbumMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AlbumMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AlbumMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[album.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AlbumMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[album.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AlbumMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, album.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AlbumMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlbumMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlbumMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlbumMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlbumMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlbumMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetImageURL sets the "image_url" field.
func (m *AlbumMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *AlbumMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *AlbumMutation) ResetImageURL() {
	m.image_url = nil
}

// SetBigImageURL sets the "big_image_url" field.
func (m *AlbumMutation) SetBigImageURL(s string) {
	m.big_image_url = &s
}

// BigImageURL returns the value of the "big_image_url" field in the mutation.
func (m *AlbumMutation) BigImageURL() (r string, exists bool) {
	v := m.big_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBigImageURL returns the old "big_image_url" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldBigImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBigImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBigImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBigImageURL: %w", err)
	}
	return oldValue.BigImageURL, nil
}

// ClearBigImageURL clears the value of the "big_image_url" field.
func (m *AlbumMutation) ClearBigImageURL() {
	m.big_image_url = nil
	m.clearedFields[album.FieldBigImageURL] = struct{}{}
}

// BigImageURLCleared returns if the "big_image_url" field was cleared in this mutation.
func (m *AlbumMutation) BigImageURLCleared() bool {
	_, ok := m.clearedFields[album.FieldBigImageURL]
	return ok
}

// ResetBigImageURL resets all changes to the "big_image_url" field.
func (m *AlbumMutation) ResetBigImageURL() {
	m.big_image_url = nil
	delete(m.clearedFields, album.FieldBigImageURL)
}

// SetDownloadURL sets the "download_url" field.
func (m *AlbumMutation) SetDownloadURL(s string) {
	m.download_url = &s
}

// DownloadURL returns the value of the "download_url" field in the mutation.
func (m *AlbumMutation) DownloadURL() (r string, exists bool) {
	v := m.download_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadURL returns the old "download_url" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDownloadURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadURL: %w", err)
	}
	return oldValue.DownloadURL, nil
}

// ClearDownloadURL clears the value of the "download_url" field.
func (m *AlbumMutation) ClearDownloadURL() {
	m.download_url = nil
	m.clearedFields[album.FieldDownloadURL] = struct{}{}
}

// DownloadURLCleared returns if the "download_url" field was cleared in this mutation.
func (m *AlbumMutation) DownloadURLCleared() bool {
	_, ok := m.clearedFields[album.FieldDownloadURL]
	return ok
}

// ResetDownloadURL resets all changes to the "download_url" field.
func (m *AlbumMutation) ResetDownloadURL() {
	m.download_url = nil
	delete(m.clearedFields, album.FieldDownloadURL)
}

// SetThumbParam sets the "thumb_param" field.
func (m *AlbumMutation) SetThumbParam(s string) {
	m.thumb_param = &s
}

// ThumbParam returns the value of the "thumb_param" field in the mutation.
func (m *AlbumMutation) ThumbParam() (r string, exists bool) {
	v := m.thumb_param
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbParam returns the old "thumb_param" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldThumbParam(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbParam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbParam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbParam: %w", err)
	}
	return oldValue.ThumbParam, nil
}

// ClearThumbParam clears the value of the "thumb_param" field.
func (m *AlbumMutation) ClearThumbParam() {
	m.thumb_param = nil
	m.clearedFields[album.FieldThumbParam] = struct{}{}
}

// ThumbParamCleared returns if the "thumb_param" field was cleared in this mutation.
func (m *AlbumMutation) ThumbParamCleared() bool {
	_, ok := m.clearedFields[album.FieldThumbParam]
	return ok
}

// ResetThumbParam resets all changes to the "thumb_param" field.
func (m *AlbumMutation) ResetThumbParam() {
	m.thumb_param = nil
	delete(m.clearedFields, album.FieldThumbParam)
}

// SetBigParam sets the "big_param" field.
func (m *AlbumMutation) SetBigParam(s string) {
	m.big_param = &s
}

// BigParam returns the value of the "big_param" field in the mutation.
func (m *AlbumMutation) BigParam() (r string, exists bool) {
	v := m.big_param
	if v == nil {
		return
	}
	return *v, true
}

// OldBigParam returns the old "big_param" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldBigParam(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBigParam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBigParam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBigParam: %w", err)
	}
	return oldValue.BigParam, nil
}

// ClearBigParam clears the value of the "big_param" field.
func (m *AlbumMutation) ClearBigParam() {
	m.big_param = nil
	m.clearedFields[album.FieldBigParam] = struct{}{}
}

// BigParamCleared returns if the "big_param" field was cleared in this mutation.
func (m *AlbumMutation) BigParamCleared() bool {
	_, ok := m.clearedFields[album.FieldBigParam]
	return ok
}

// ResetBigParam resets all changes to the "big_param" field.
func (m *AlbumMutation) ResetBigParam() {
	m.big_param = nil
	delete(m.clearedFields, album.FieldBigParam)
}

// SetTags sets the "tags" field.
func (m *AlbumMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AlbumMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *AlbumMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[album.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *AlbumMutation) TagsCleared() bool {
	_, ok := m.clearedFields[album.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *AlbumMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, album.FieldTags)
}

// SetViewCount sets the "view_count" field.
func (m *AlbumMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *AlbumMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *AlbumMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *AlbumMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *AlbumMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetDownloadCount sets the "download_count" field.
func (m *AlbumMutation) SetDownloadCount(i int) {
	m.download_count = &i
	m.adddownload_count = nil
}

// DownloadCount returns the value of the "download_count" field in the mutation.
func (m *AlbumMutation) DownloadCount() (r int, exists bool) {
	v := m.download_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadCount returns the old "download_count" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDownloadCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadCount: %w", err)
	}
	return oldValue.DownloadCount, nil
}

// AddDownloadCount adds i to the "download_count" field.
func (m *AlbumMutation) AddDownloadCount(i int) {
	if m.adddownload_count != nil {
		*m.adddownload_count += i
	} else {
		m.adddownload_count = &i
	}
}

// AddedDownloadCount returns the value that was added to the "download_count" field in this mutation.
func (m *AlbumMutation) AddedDownloadCount() (r int, exists bool) {
	v := m.adddownload_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloadCount resets all changes to the "download_count" field.
func (m *AlbumMutation) ResetDownloadCount() {
	m.download_count = nil
	m.adddownload_count = nil
}

// SetWidth sets the "width" field.
func (m *AlbumMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *AlbumMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *AlbumMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *AlbumMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *AlbumMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[album.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *AlbumMutation) WidthCleared() bool {
	_, ok := m.clearedFields[album.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *AlbumMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, album.FieldWidth)
}

// SetHeight sets the "height" field.
func (m *AlbumMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *AlbumMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *AlbumMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *AlbumMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *AlbumMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[album.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *AlbumMutation) HeightCleared() bool {
	_, ok := m.clearedFields[album.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *AlbumMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, album.FieldHeight)
}

// SetFileSize sets the "file_size" field.
func (m *AlbumMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *AlbumMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *AlbumMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *AlbumMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileSize clears the value of the "file_size" field.
func (m *AlbumMutation) ClearFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	m.clearedFields[album.FieldFileSize] = struct{}{}
}

// FileSizeCleared returns if the "file_size" field was cleared in this mutation.
func (m *AlbumMutation) FileSizeCleared() bool {
	_, ok := m.clearedFields[album.FieldFileSize]
	return ok
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *AlbumMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	delete(m.clearedFields, album.FieldFileSize)
}

// SetFormat sets the "format" field.
func (m *AlbumMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *AlbumMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ClearFormat clears the value of the "format" field.
func (m *AlbumMutation) ClearFormat() {
	m.format = nil
	m.clearedFields[album.FieldFormat] = struct{}{}
}

// FormatCleared returns if the "format" field was cleared in this mutation.
func (m *AlbumMutation) FormatCleared() bool {
	_, ok := m.clearedFields[album.FieldFormat]
	return ok
}

// ResetFormat resets all changes to the "format" field.
func (m *AlbumMutation) ResetFormat() {
	m.format = nil
	delete(m.clearedFields, album.FieldFormat)
}

// SetAspectRatio sets the "aspect_ratio" field.
func (m *AlbumMutation) SetAspectRatio(s string) {
	m.aspect_ratio = &s
}

// AspectRatio returns the value of the "aspect_ratio" field in the mutation.
func (m *AlbumMutation) AspectRatio() (r string, exists bool) {
	v := m.aspect_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldAspectRatio returns the old "aspect_ratio" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldAspectRatio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAspectRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAspectRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAspectRatio: %w", err)
	}
	return oldValue.AspectRatio, nil
}

// ClearAspectRatio clears the value of the "aspect_ratio" field.
func (m *AlbumMutation) ClearAspectRatio() {
	m.aspect_ratio = nil
	m.clearedFields[album.FieldAspectRatio] = struct{}{}
}

// AspectRatioCleared returns if the "aspect_ratio" field was cleared in this mutation.
func (m *AlbumMutation) AspectRatioCleared() bool {
	_, ok := m.clearedFields[album.FieldAspectRatio]
	return ok
}

// ResetAspectRatio resets all changes to the "aspect_ratio" field.
func (m *AlbumMutation) ResetAspectRatio() {
	m.aspect_ratio = nil
	delete(m.clearedFields, album.FieldAspectRatio)
}

// SetFileHash sets the "file_hash" field.
func (m *AlbumMutation) SetFileHash(s string) {
	m.file_hash = &s
}

// FileHash returns the value of the "file_hash" field in the mutation.
func (m *AlbumMutation) FileHash() (r string, exists bool) {
	v := m.file_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldFileHash returns the old "file_hash" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldFileHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileHash: %w", err)
	}
	return oldValue.FileHash, nil
}

// ResetFileHash resets all changes to the "file_hash" field.
func (m *AlbumMutation) ResetFileHash() {
	m.file_hash = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *AlbumMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *AlbumMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *AlbumMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *AlbumMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *AlbumMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// Where appends a list predicates to the AlbumMutation builder.
func (m *AlbumMutation) Where(ps ...predicate.Album) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Album, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Album).
func (m *AlbumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.deleted_at != nil {
		fields = append(fields, album.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, album.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, album.FieldUpdatedAt)
	}
	if m.image_url != nil {
		fields = append(fields, album.FieldImageURL)
	}
	if m.big_image_url != nil {
		fields = append(fields, album.FieldBigImageURL)
	}
	if m.download_url != nil {
		fields = append(fields, album.FieldDownloadURL)
	}
	if m.thumb_param != nil {
		fields = append(fields, album.FieldThumbParam)
	}
	if m.big_param != nil {
		fields = append(fields, album.FieldBigParam)
	}
	if m.tags != nil {
		fields = append(fields, album.FieldTags)
	}
	if m.view_count != nil {
		fields = append(fields, album.FieldViewCount)
	}
	if m.download_count != nil {
		fields = append(fields, album.FieldDownloadCount)
	}
	if m.width != nil {
		fields = append(fields, album.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, album.FieldHeight)
	}
	if m.file_size != nil {
		fields = append(fields, album.FieldFileSize)
	}
	if m.format != nil {
		fields = append(fields, album.FieldFormat)
	}
	if m.aspect_ratio != nil {
		fields = append(fields, album.FieldAspectRatio)
	}
	if m.file_hash != nil {
		fields = append(fields, album.FieldFileHash)
	}
	if m.display_order != nil {
		fields = append(fields, album.FieldDisplayOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case album.FieldDeletedAt:
		return m.DeletedAt()
	case album.FieldCreatedAt:
		return m.CreatedAt()
	case album.FieldUpdatedAt:
		return m.UpdatedAt()
	case album.FieldImageURL:
		return m.ImageURL()
	case album.FieldBigImageURL:
		return m.BigImageURL()
	case album.FieldDownloadURL:
		return m.DownloadURL()
	case album.FieldThumbParam:
		return m.ThumbParam()
	case album.FieldBigParam:
		return m.BigParam()
	case album.FieldTags:
		return m.Tags()
	case album.FieldViewCount:
		return m.ViewCount()
	case album.FieldDownloadCount:
		return m.DownloadCount()
	case album.FieldWidth:
		return m.Width()
	case album.FieldHeight:
		return m.Height()
	case album.FieldFileSize:
		return m.FileSize()
	case album.FieldFormat:
		return m.Format()
	case album.FieldAspectRatio:
		return m.AspectRatio()
	case album.FieldFileHash:
		return m.FileHash()
	case album.FieldDisplayOrder:
		return m.DisplayOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case album.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case album.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case album.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case album.FieldImageURL:
		return m.OldImageURL(ctx)
	case album.FieldBigImageURL:
		return m.OldBigImageURL(ctx)
	case album.FieldDownloadURL:
		return m.OldDownloadURL(ctx)
	case album.FieldThumbParam:
		return m.OldThumbParam(ctx)
	case album.FieldBigParam:
		return m.OldBigParam(ctx)
	case album.FieldTags:
		return m.OldTags(ctx)
	case album.FieldViewCount:
		return m.OldViewCount(ctx)
	case album.FieldDownloadCount:
		return m.OldDownloadCount(ctx)
	case album.FieldWidth:
		return m.OldWidth(ctx)
	case album.FieldHeight:
		return m.OldHeight(ctx)
	case album.FieldFileSize:
		return m.OldFileSize(ctx)
	case album.FieldFormat:
		return m.OldFormat(ctx)
	case album.FieldAspectRatio:
		return m.OldAspectRatio(ctx)
	case album.FieldFileHash:
		return m.OldFileHash(ctx)
	case album.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Album field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case album.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case album.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case album.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case album.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case album.FieldBigImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBigImageURL(v)
		return nil
	case album.FieldDownloadURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadURL(v)
		return nil
	case album.FieldThumbParam:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbParam(v)
		return nil
	case album.FieldBigParam:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBigParam(v)
		return nil
	case album.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case album.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case album.FieldDownloadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadCount(v)
		return nil
	case album.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case album.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case album.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case album.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case album.FieldAspectRatio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAspectRatio(v)
		return nil
	case album.FieldFileHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileHash(v)
		return nil
	case album.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumMutation) AddedFields() []string {
	var fields []string
	if m.addview_count != nil {
		fields = append(fields, album.FieldViewCount)
	}
	if m.adddownload_count != nil {
		fields = append(fields, album.FieldDownloadCount)
	}
	if m.addwidth != nil {
		fields = append(fields, album.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, album.FieldHeight)
	}
	if m.addfile_size != nil {
		fields = append(fields, album.FieldFileSize)
	}
	if m.adddisplay_order != nil {
		fields = append(fields, album.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case album.FieldViewCount:
		return m.AddedViewCount()
	case album.FieldDownloadCount:
		return m.AddedDownloadCount()
	case album.FieldWidth:
		return m.AddedWidth()
	case album.FieldHeight:
		return m.AddedHeight()
	case album.FieldFileSize:
		return m.AddedFileSize()
	case album.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) AddField(name string, value ent.Value) error {
	switch name {
	case album.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case album.FieldDownloadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloadCount(v)
		return nil
	case album.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case album.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case album.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	case album.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Album numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(album.FieldDeletedAt) {
		fields = append(fields, album.FieldDeletedAt)
	}
	if m.FieldCleared(album.FieldBigImageURL) {
		fields = append(fields, album.FieldBigImageURL)
	}
	if m.FieldCleared(album.FieldDownloadURL) {
		fields = append(fields, album.FieldDownloadURL)
	}
	if m.FieldCleared(album.FieldThumbParam) {
		fields = append(fields, album.FieldThumbParam)
	}
	if m.FieldCleared(album.FieldBigParam) {
		fields = append(fields, album.FieldBigParam)
	}
	if m.FieldCleared(album.FieldTags) {
		fields = append(fields, album.FieldTags)
	}
	if m.FieldCleared(album.FieldWidth) {
		fields = append(fields, album.FieldWidth)
	}
	if m.FieldCleared(album.FieldHeight) {
		fields = append(fields, album.FieldHeight)
	}
	if m.FieldCleared(album.FieldFileSize) {
		fields = append(fields, album.FieldFileSize)
	}
	if m.FieldCleared(album.FieldFormat) {
		fields = append(fields, album.FieldFormat)
	}
	if m.FieldCleared(album.FieldAspectRatio) {
		fields = append(fields, album.FieldAspectRatio)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumMutation) ClearField(name string) error {
	switch name {
	case album.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case album.FieldBigImageURL:
		m.ClearBigImageURL()
		return nil
	case album.FieldDownloadURL:
		m.ClearDownloadURL()
		return nil
	case album.FieldThumbParam:
		m.ClearThumbParam()
		return nil
	case album.FieldBigParam:
		m.ClearBigParam()
		return nil
	case album.FieldTags:
		m.ClearTags()
		return nil
	case album.FieldWidth:
		m.ClearWidth()
		return nil
	case album.FieldHeight:
		m.ClearHeight()
		return nil
	case album.FieldFileSize:
		m.ClearFileSize()
		return nil
	case album.FieldFormat:
		m.ClearFormat()
		return nil
	case album.FieldAspectRatio:
		m.ClearAspectRatio()
		return nil
	}
	return fmt.Errorf("unknown Album nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumMutation) ResetField(name string) error {
	switch name {
	case album.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case album.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case album.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case album.FieldImageURL:
		m.ResetImageURL()
		return nil
	case album.FieldBigImageURL:
		m.ResetBigImageURL()
		return nil
	case album.FieldDownloadURL:
		m.ResetDownloadURL()
		return nil
	case album.FieldThumbParam:
		m.ResetThumbParam()
		return nil
	case album.FieldBigParam:
		m.ResetBigParam()
		return nil
	case album.FieldTags:
		m.ResetTags()
		return nil
	case album.FieldViewCount:
		m.ResetViewCount()
		return nil
	case album.FieldDownloadCount:
		m.ResetDownloadCount()
		return nil
	case album.FieldWidth:
		m.ResetWidth()
		return nil
	case album.FieldHeight:
		m.ResetHeight()
		return nil
	case album.FieldFileSize:
		m.ResetFileSize()
		return nil
	case album.FieldFormat:
		m.ResetFormat()
		return nil
	case album.FieldAspectRatio:
		m.ResetAspectRatio()
		return nil
	case album.FieldFileHash:
		m.ResetFileHash()
		return nil
	case album.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Album unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Album edge %s", name)
}

// ArticleMutation represents an operation that mutates the Article nodes in the graph.
type ArticleMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uint
	deleted_at              *time.Time
	created_at              *time.Time
	updated_at              *time.Time
	title                   *string
	content_md              *string
	content_html            *string
	cover_url               *string
	status                  *article.Status
	view_count              *int
	addview_count           *int
	word_count              *int
	addword_count           *int
	reading_time            *int
	addreading_time         *int
	ip_location             *string
	primary_color           *string
	is_primary_color_manual *bool
	home_sort               *int
	addhome_sort            *int
	pin_sort                *int
	addpin_sort             *int
	top_img_url             *string
	summaries               *[]string
	appendsummaries         []string
	abbrlink                *string
	copyright               *bool
	copyright_author        *string
	copyright_author_href   *string
	copyright_url           *string
	clearedFields           map[string]struct{}
	post_tags               map[uint]struct{}
	removedpost_tags        map[uint]struct{}
	clearedpost_tags        bool
	post_categories         map[uint]struct{}
	removedpost_categories  map[uint]struct{}
	clearedpost_categories  bool
	comments                map[uint]struct{}
	removedcomments         map[uint]struct{}
	clearedcomments         bool
	done                    bool
	oldValue                func(context.Context) (*Article, error)
	predicates              []predicate.Article
}

var _ ent.Mutation = (*ArticleMutation)(nil)

// articleOption allows management of the mutation configuration using functional options.
type articleOption func(*ArticleMutation)

// newArticleMutation creates new mutation for the Article entity.
func newArticleMutation(c config, op Op, opts ...articleOption) *ArticleMutation {
	m := &ArticleMutation{
		config:        c,
		op:            op,
		typ:           TypeArticle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArticleID sets the ID field of the mutation.
func withArticleID(id uint) articleOption {
	return func(m *ArticleMutation) {
		var (
			err   error
			once  sync.Once
			value *Article
		)
		m.oldValue = func(ctx context.Context) (*Article, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Article.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArticle sets the old Article of the mutation.
func withArticle(node *Article) articleOption {
	return func(m *ArticleMutation) {
		m.oldValue = func(context.Context) (*Article, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArticleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArticleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Article entities.
func (m *ArticleMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArticleMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArticleMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Article.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArticleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArticleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ArticleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[article.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ArticleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[article.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArticleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, article.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ArticleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArticleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArticleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArticleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArticleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArticleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *ArticleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ArticleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ArticleMutation) ResetTitle() {
	m.title = nil
}

// SetContentMd sets the "content_md" field.
func (m *ArticleMutation) SetContentMd(s string) {
	m.content_md = &s
}

// ContentMd returns the value of the "content_md" field in the mutation.
func (m *ArticleMutation) ContentMd() (r string, exists bool) {
	v := m.content_md
	if v == nil {
		return
	}
	return *v, true
}

// OldContentMd returns the old "content_md" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldContentMd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentMd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentMd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentMd: %w", err)
	}
	return oldValue.ContentMd, nil
}

// ClearContentMd clears the value of the "content_md" field.
func (m *ArticleMutation) ClearContentMd() {
	m.content_md = nil
	m.clearedFields[article.FieldContentMd] = struct{}{}
}

// ContentMdCleared returns if the "content_md" field was cleared in this mutation.
func (m *ArticleMutation) ContentMdCleared() bool {
	_, ok := m.clearedFields[article.FieldContentMd]
	return ok
}

// ResetContentMd resets all changes to the "content_md" field.
func (m *ArticleMutation) ResetContentMd() {
	m.content_md = nil
	delete(m.clearedFields, article.FieldContentMd)
}

// SetContentHTML sets the "content_html" field.
func (m *ArticleMutation) SetContentHTML(s string) {
	m.content_html = &s
}

// ContentHTML returns the value of the "content_html" field in the mutation.
func (m *ArticleMutation) ContentHTML() (r string, exists bool) {
	v := m.content_html
	if v == nil {
		return
	}
	return *v, true
}

// OldContentHTML returns the old "content_html" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldContentHTML(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentHTML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentHTML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentHTML: %w", err)
	}
	return oldValue.ContentHTML, nil
}

// ClearContentHTML clears the value of the "content_html" field.
func (m *ArticleMutation) ClearContentHTML() {
	m.content_html = nil
	m.clearedFields[article.FieldContentHTML] = struct{}{}
}

// ContentHTMLCleared returns if the "content_html" field was cleared in this mutation.
func (m *ArticleMutation) ContentHTMLCleared() bool {
	_, ok := m.clearedFields[article.FieldContentHTML]
	return ok
}

// ResetContentHTML resets all changes to the "content_html" field.
func (m *ArticleMutation) ResetContentHTML() {
	m.content_html = nil
	delete(m.clearedFields, article.FieldContentHTML)
}

// SetCoverURL sets the "cover_url" field.
func (m *ArticleMutation) SetCoverURL(s string) {
	m.cover_url = &s
}

// CoverURL returns the value of the "cover_url" field in the mutation.
func (m *ArticleMutation) CoverURL() (r string, exists bool) {
	v := m.cover_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverURL returns the old "cover_url" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCoverURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverURL: %w", err)
	}
	return oldValue.CoverURL, nil
}

// ClearCoverURL clears the value of the "cover_url" field.
func (m *ArticleMutation) ClearCoverURL() {
	m.cover_url = nil
	m.clearedFields[article.FieldCoverURL] = struct{}{}
}

// CoverURLCleared returns if the "cover_url" field was cleared in this mutation.
func (m *ArticleMutation) CoverURLCleared() bool {
	_, ok := m.clearedFields[article.FieldCoverURL]
	return ok
}

// ResetCoverURL resets all changes to the "cover_url" field.
func (m *ArticleMutation) ResetCoverURL() {
	m.cover_url = nil
	delete(m.clearedFields, article.FieldCoverURL)
}

// SetStatus sets the "status" field.
func (m *ArticleMutation) SetStatus(a article.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *ArticleMutation) Status() (r article.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldStatus(ctx context.Context) (v article.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ArticleMutation) ResetStatus() {
	m.status = nil
}

// SetViewCount sets the "view_count" field.
func (m *ArticleMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *ArticleMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *ArticleMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *ArticleMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *ArticleMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetWordCount sets the "word_count" field.
func (m *ArticleMutation) SetWordCount(i int) {
	m.word_count = &i
	m.addword_count = nil
}

// WordCount returns the value of the "word_count" field in the mutation.
func (m *ArticleMutation) WordCount() (r int, exists bool) {
	v := m.word_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWordCount returns the old "word_count" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldWordCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordCount: %w", err)
	}
	return oldValue.WordCount, nil
}

// AddWordCount adds i to the "word_count" field.
func (m *ArticleMutation) AddWordCount(i int) {
	if m.addword_count != nil {
		*m.addword_count += i
	} else {
		m.addword_count = &i
	}
}

// AddedWordCount returns the value that was added to the "word_count" field in this mutation.
func (m *ArticleMutation) AddedWordCount() (r int, exists bool) {
	v := m.addword_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetWordCount resets all changes to the "word_count" field.
func (m *ArticleMutation) ResetWordCount() {
	m.word_count = nil
	m.addword_count = nil
}

// SetReadingTime sets the "reading_time" field.
func (m *ArticleMutation) SetReadingTime(i int) {
	m.reading_time = &i
	m.addreading_time = nil
}

// ReadingTime returns the value of the "reading_time" field in the mutation.
func (m *ArticleMutation) ReadingTime() (r int, exists bool) {
	v := m.reading_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReadingTime returns the old "reading_time" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldReadingTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadingTime: %w", err)
	}
	return oldValue.ReadingTime, nil
}

// AddReadingTime adds i to the "reading_time" field.
func (m *ArticleMutation) AddReadingTime(i int) {
	if m.addreading_time != nil {
		*m.addreading_time += i
	} else {
		m.addreading_time = &i
	}
}

// AddedReadingTime returns the value that was added to the "reading_time" field in this mutation.
func (m *ArticleMutation) AddedReadingTime() (r int, exists bool) {
	v := m.addreading_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetReadingTime resets all changes to the "reading_time" field.
func (m *ArticleMutation) ResetReadingTime() {
	m.reading_time = nil
	m.addreading_time = nil
}

// SetIPLocation sets the "ip_location" field.
func (m *ArticleMutation) SetIPLocation(s string) {
	m.ip_location = &s
}

// IPLocation returns the value of the "ip_location" field in the mutation.
func (m *ArticleMutation) IPLocation() (r string, exists bool) {
	v := m.ip_location
	if v == nil {
		return
	}
	return *v, true
}

// OldIPLocation returns the old "ip_location" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldIPLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPLocation: %w", err)
	}
	return oldValue.IPLocation, nil
}

// ClearIPLocation clears the value of the "ip_location" field.
func (m *ArticleMutation) ClearIPLocation() {
	m.ip_location = nil
	m.clearedFields[article.FieldIPLocation] = struct{}{}
}

// IPLocationCleared returns if the "ip_location" field was cleared in this mutation.
func (m *ArticleMutation) IPLocationCleared() bool {
	_, ok := m.clearedFields[article.FieldIPLocation]
	return ok
}

// ResetIPLocation resets all changes to the "ip_location" field.
func (m *ArticleMutation) ResetIPLocation() {
	m.ip_location = nil
	delete(m.clearedFields, article.FieldIPLocation)
}

// SetPrimaryColor sets the "primary_color" field.
func (m *ArticleMutation) SetPrimaryColor(s string) {
	m.primary_color = &s
}

// PrimaryColor returns the value of the "primary_color" field in the mutation.
func (m *ArticleMutation) PrimaryColor() (r string, exists bool) {
	v := m.primary_color
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryColor returns the old "primary_color" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldPrimaryColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryColor: %w", err)
	}
	return oldValue.PrimaryColor, nil
}

// ClearPrimaryColor clears the value of the "primary_color" field.
func (m *ArticleMutation) ClearPrimaryColor() {
	m.primary_color = nil
	m.clearedFields[article.FieldPrimaryColor] = struct{}{}
}

// PrimaryColorCleared returns if the "primary_color" field was cleared in this mutation.
func (m *ArticleMutation) PrimaryColorCleared() bool {
	_, ok := m.clearedFields[article.FieldPrimaryColor]
	return ok
}

// ResetPrimaryColor resets all changes to the "primary_color" field.
func (m *ArticleMutation) ResetPrimaryColor() {
	m.primary_color = nil
	delete(m.clearedFields, article.FieldPrimaryColor)
}

// SetIsPrimaryColorManual sets the "is_primary_color_manual" field.
func (m *ArticleMutation) SetIsPrimaryColorManual(b bool) {
	m.is_primary_color_manual = &b
}

// IsPrimaryColorManual returns the value of the "is_primary_color_manual" field in the mutation.
func (m *ArticleMutation) IsPrimaryColorManual() (r bool, exists bool) {
	v := m.is_primary_color_manual
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimaryColorManual returns the old "is_primary_color_manual" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldIsPrimaryColorManual(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimaryColorManual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimaryColorManual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimaryColorManual: %w", err)
	}
	return oldValue.IsPrimaryColorManual, nil
}

// ResetIsPrimaryColorManual resets all changes to the "is_primary_color_manual" field.
func (m *ArticleMutation) ResetIsPrimaryColorManual() {
	m.is_primary_color_manual = nil
}

// SetHomeSort sets the "home_sort" field.
func (m *ArticleMutation) SetHomeSort(i int) {
	m.home_sort = &i
	m.addhome_sort = nil
}

// HomeSort returns the value of the "home_sort" field in the mutation.
func (m *ArticleMutation) HomeSort() (r int, exists bool) {
	v := m.home_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeSort returns the old "home_sort" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldHomeSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeSort: %w", err)
	}
	return oldValue.HomeSort, nil
}

// AddHomeSort adds i to the "home_sort" field.
func (m *ArticleMutation) AddHomeSort(i int) {
	if m.addhome_sort != nil {
		*m.addhome_sort += i
	} else {
		m.addhome_sort = &i
	}
}

// AddedHomeSort returns the value that was added to the "home_sort" field in this mutation.
func (m *ArticleMutation) AddedHomeSort() (r int, exists bool) {
	v := m.addhome_sort
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeSort resets all changes to the "home_sort" field.
func (m *ArticleMutation) ResetHomeSort() {
	m.home_sort = nil
	m.addhome_sort = nil
}

// SetPinSort sets the "pin_sort" field.
func (m *ArticleMutation) SetPinSort(i int) {
	m.pin_sort = &i
	m.addpin_sort = nil
}

// PinSort returns the value of the "pin_sort" field in the mutation.
func (m *ArticleMutation) PinSort() (r int, exists bool) {
	v := m.pin_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldPinSort returns the old "pin_sort" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldPinSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinSort: %w", err)
	}
	return oldValue.PinSort, nil
}

// AddPinSort adds i to the "pin_sort" field.
func (m *ArticleMutation) AddPinSort(i int) {
	if m.addpin_sort != nil {
		*m.addpin_sort += i
	} else {
		m.addpin_sort = &i
	}
}

// AddedPinSort returns the value that was added to the "pin_sort" field in this mutation.
func (m *ArticleMutation) AddedPinSort() (r int, exists bool) {
	v := m.addpin_sort
	if v == nil {
		return
	}
	return *v, true
}

// ResetPinSort resets all changes to the "pin_sort" field.
func (m *ArticleMutation) ResetPinSort() {
	m.pin_sort = nil
	m.addpin_sort = nil
}

// SetTopImgURL sets the "top_img_url" field.
func (m *ArticleMutation) SetTopImgURL(s string) {
	m.top_img_url = &s
}

// TopImgURL returns the value of the "top_img_url" field in the mutation.
func (m *ArticleMutation) TopImgURL() (r string, exists bool) {
	v := m.top_img_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTopImgURL returns the old "top_img_url" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldTopImgURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopImgURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopImgURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopImgURL: %w", err)
	}
	return oldValue.TopImgURL, nil
}

// ClearTopImgURL clears the value of the "top_img_url" field.
func (m *ArticleMutation) ClearTopImgURL() {
	m.top_img_url = nil
	m.clearedFields[article.FieldTopImgURL] = struct{}{}
}

// TopImgURLCleared returns if the "top_img_url" field was cleared in this mutation.
func (m *ArticleMutation) TopImgURLCleared() bool {
	_, ok := m.clearedFields[article.FieldTopImgURL]
	return ok
}

// ResetTopImgURL resets all changes to the "top_img_url" field.
func (m *ArticleMutation) ResetTopImgURL() {
	m.top_img_url = nil
	delete(m.clearedFields, article.FieldTopImgURL)
}

// SetSummaries sets the "summaries" field.
func (m *ArticleMutation) SetSummaries(s []string) {
	m.summaries = &s
	m.appendsummaries = nil
}

// Summaries returns the value of the "summaries" field in the mutation.
func (m *ArticleMutation) Summaries() (r []string, exists bool) {
	v := m.summaries
	if v == nil {
		return
	}
	return *v, true
}

// OldSummaries returns the old "summaries" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldSummaries(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummaries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummaries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummaries: %w", err)
	}
	return oldValue.Summaries, nil
}

// AppendSummaries adds s to the "summaries" field.
func (m *ArticleMutation) AppendSummaries(s []string) {
	m.appendsummaries = append(m.appendsummaries, s...)
}

// AppendedSummaries returns the list of values that were appended to the "summaries" field in this mutation.
func (m *ArticleMutation) AppendedSummaries() ([]string, bool) {
	if len(m.appendsummaries) == 0 {
		return nil, false
	}
	return m.appendsummaries, true
}

// ClearSummaries clears the value of the "summaries" field.
func (m *ArticleMutation) ClearSummaries() {
	m.summaries = nil
	m.appendsummaries = nil
	m.clearedFields[article.FieldSummaries] = struct{}{}
}

// SummariesCleared returns if the "summaries" field was cleared in this mutation.
func (m *ArticleMutation) SummariesCleared() bool {
	_, ok := m.clearedFields[article.FieldSummaries]
	return ok
}

// ResetSummaries resets all changes to the "summaries" field.
func (m *ArticleMutation) ResetSummaries() {
	m.summaries = nil
	m.appendsummaries = nil
	delete(m.clearedFields, article.FieldSummaries)
}

// SetAbbrlink sets the "abbrlink" field.
func (m *ArticleMutation) SetAbbrlink(s string) {
	m.abbrlink = &s
}

// Abbrlink returns the value of the "abbrlink" field in the mutation.
func (m *ArticleMutation) Abbrlink() (r string, exists bool) {
	v := m.abbrlink
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbrlink returns the old "abbrlink" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldAbbrlink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbrlink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbrlink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbrlink: %w", err)
	}
	return oldValue.Abbrlink, nil
}

// ClearAbbrlink clears the value of the "abbrlink" field.
func (m *ArticleMutation) ClearAbbrlink() {
	m.abbrlink = nil
	m.clearedFields[article.FieldAbbrlink] = struct{}{}
}

// AbbrlinkCleared returns if the "abbrlink" field was cleared in this mutation.
func (m *ArticleMutation) AbbrlinkCleared() bool {
	_, ok := m.clearedFields[article.FieldAbbrlink]
	return ok
}

// ResetAbbrlink resets all changes to the "abbrlink" field.
func (m *ArticleMutation) ResetAbbrlink() {
	m.abbrlink = nil
	delete(m.clearedFields, article.FieldAbbrlink)
}

// SetCopyright sets the "copyright" field.
func (m *ArticleMutation) SetCopyright(b bool) {
	m.copyright = &b
}

// Copyright returns the value of the "copyright" field in the mutation.
func (m *ArticleMutation) Copyright() (r bool, exists bool) {
	v := m.copyright
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyright returns the old "copyright" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCopyright(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyright is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyright requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyright: %w", err)
	}
	return oldValue.Copyright, nil
}

// ResetCopyright resets all changes to the "copyright" field.
func (m *ArticleMutation) ResetCopyright() {
	m.copyright = nil
}

// SetCopyrightAuthor sets the "copyright_author" field.
func (m *ArticleMutation) SetCopyrightAuthor(s string) {
	m.copyright_author = &s
}

// CopyrightAuthor returns the value of the "copyright_author" field in the mutation.
func (m *ArticleMutation) CopyrightAuthor() (r string, exists bool) {
	v := m.copyright_author
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyrightAuthor returns the old "copyright_author" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCopyrightAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyrightAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyrightAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyrightAuthor: %w", err)
	}
	return oldValue.CopyrightAuthor, nil
}

// ClearCopyrightAuthor clears the value of the "copyright_author" field.
func (m *ArticleMutation) ClearCopyrightAuthor() {
	m.copyright_author = nil
	m.clearedFields[article.FieldCopyrightAuthor] = struct{}{}
}

// CopyrightAuthorCleared returns if the "copyright_author" field was cleared in this mutation.
func (m *ArticleMutation) CopyrightAuthorCleared() bool {
	_, ok := m.clearedFields[article.FieldCopyrightAuthor]
	return ok
}

// ResetCopyrightAuthor resets all changes to the "copyright_author" field.
func (m *ArticleMutation) ResetCopyrightAuthor() {
	m.copyright_author = nil
	delete(m.clearedFields, article.FieldCopyrightAuthor)
}

// SetCopyrightAuthorHref sets the "copyright_author_href" field.
func (m *ArticleMutation) SetCopyrightAuthorHref(s string) {
	m.copyright_author_href = &s
}

// CopyrightAuthorHref returns the value of the "copyright_author_href" field in the mutation.
func (m *ArticleMutation) CopyrightAuthorHref() (r string, exists bool) {
	v := m.copyright_author_href
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyrightAuthorHref returns the old "copyright_author_href" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCopyrightAuthorHref(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyrightAuthorHref is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyrightAuthorHref requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyrightAuthorHref: %w", err)
	}
	return oldValue.CopyrightAuthorHref, nil
}

// ClearCopyrightAuthorHref clears the value of the "copyright_author_href" field.
func (m *ArticleMutation) ClearCopyrightAuthorHref() {
	m.copyright_author_href = nil
	m.clearedFields[article.FieldCopyrightAuthorHref] = struct{}{}
}

// CopyrightAuthorHrefCleared returns if the "copyright_author_href" field was cleared in this mutation.
func (m *ArticleMutation) CopyrightAuthorHrefCleared() bool {
	_, ok := m.clearedFields[article.FieldCopyrightAuthorHref]
	return ok
}

// ResetCopyrightAuthorHref resets all changes to the "copyright_author_href" field.
func (m *ArticleMutation) ResetCopyrightAuthorHref() {
	m.copyright_author_href = nil
	delete(m.clearedFields, article.FieldCopyrightAuthorHref)
}

// SetCopyrightURL sets the "copyright_url" field.
func (m *ArticleMutation) SetCopyrightURL(s string) {
	m.copyright_url = &s
}

// CopyrightURL returns the value of the "copyright_url" field in the mutation.
func (m *ArticleMutation) CopyrightURL() (r string, exists bool) {
	v := m.copyright_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyrightURL returns the old "copyright_url" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCopyrightURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyrightURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyrightURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyrightURL: %w", err)
	}
	return oldValue.CopyrightURL, nil
}

// ClearCopyrightURL clears the value of the "copyright_url" field.
func (m *ArticleMutation) ClearCopyrightURL() {
	m.copyright_url = nil
	m.clearedFields[article.FieldCopyrightURL] = struct{}{}
}

// CopyrightURLCleared returns if the "copyright_url" field was cleared in this mutation.
func (m *ArticleMutation) CopyrightURLCleared() bool {
	_, ok := m.clearedFields[article.FieldCopyrightURL]
	return ok
}

// ResetCopyrightURL resets all changes to the "copyright_url" field.
func (m *ArticleMutation) ResetCopyrightURL() {
	m.copyright_url = nil
	delete(m.clearedFields, article.FieldCopyrightURL)
}

// AddPostTagIDs adds the "post_tags" edge to the PostTag entity by ids.
func (m *ArticleMutation) AddPostTagIDs(ids ...uint) {
	if m.post_tags == nil {
		m.post_tags = make(map[uint]struct{})
	}
	for i := range ids {
		m.post_tags[ids[i]] = struct{}{}
	}
}

// ClearPostTags clears the "post_tags" edge to the PostTag entity.
func (m *ArticleMutation) ClearPostTags() {
	m.clearedpost_tags = true
}

// PostTagsCleared reports if the "post_tags" edge to the PostTag entity was cleared.
func (m *ArticleMutation) PostTagsCleared() bool {
	return m.clearedpost_tags
}

// RemovePostTagIDs removes the "post_tags" edge to the PostTag entity by IDs.
func (m *ArticleMutation) RemovePostTagIDs(ids ...uint) {
	if m.removedpost_tags == nil {
		m.removedpost_tags = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.post_tags, ids[i])
		m.removedpost_tags[ids[i]] = struct{}{}
	}
}

// RemovedPostTags returns the removed IDs of the "post_tags" edge to the PostTag entity.
func (m *ArticleMutation) RemovedPostTagsIDs() (ids []uint) {
	for id := range m.removedpost_tags {
		ids = append(ids, id)
	}
	return
}

// PostTagsIDs returns the "post_tags" edge IDs in the mutation.
func (m *ArticleMutation) PostTagsIDs() (ids []uint) {
	for id := range m.post_tags {
		ids = append(ids, id)
	}
	return
}

// ResetPostTags resets all changes to the "post_tags" edge.
func (m *ArticleMutation) ResetPostTags() {
	m.post_tags = nil
	m.clearedpost_tags = false
	m.removedpost_tags = nil
}

// AddPostCategoryIDs adds the "post_categories" edge to the PostCategory entity by ids.
func (m *ArticleMutation) AddPostCategoryIDs(ids ...uint) {
	if m.post_categories == nil {
		m.post_categories = make(map[uint]struct{})
	}
	for i := range ids {
		m.post_categories[ids[i]] = struct{}{}
	}
}

// ClearPostCategories clears the "post_categories" edge to the PostCategory entity.
func (m *ArticleMutation) ClearPostCategories() {
	m.clearedpost_categories = true
}

// PostCategoriesCleared reports if the "post_categories" edge to the PostCategory entity was cleared.
func (m *ArticleMutation) PostCategoriesCleared() bool {
	return m.clearedpost_categories
}

// RemovePostCategoryIDs removes the "post_categories" edge to the PostCategory entity by IDs.
func (m *ArticleMutation) RemovePostCategoryIDs(ids ...uint) {
	if m.removedpost_categories == nil {
		m.removedpost_categories = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.post_categories, ids[i])
		m.removedpost_categories[ids[i]] = struct{}{}
	}
}

// RemovedPostCategories returns the removed IDs of the "post_categories" edge to the PostCategory entity.
func (m *ArticleMutation) RemovedPostCategoriesIDs() (ids []uint) {
	for id := range m.removedpost_categories {
		ids = append(ids, id)
	}
	return
}

// PostCategoriesIDs returns the "post_categories" edge IDs in the mutation.
func (m *ArticleMutation) PostCategoriesIDs() (ids []uint) {
	for id := range m.post_categories {
		ids = append(ids, id)
	}
	return
}

// ResetPostCategories resets all changes to the "post_categories" edge.
func (m *ArticleMutation) ResetPostCategories() {
	m.post_categories = nil
	m.clearedpost_categories = false
	m.removedpost_categories = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *ArticleMutation) AddCommentIDs(ids ...uint) {
	if m.comments == nil {
		m.comments = make(map[uint]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *ArticleMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *ArticleMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *ArticleMutation) RemoveCommentIDs(ids ...uint) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *ArticleMutation) RemovedCommentsIDs() (ids []uint) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *ArticleMutation) CommentsIDs() (ids []uint) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *ArticleMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// Where appends a list predicates to the ArticleMutation builder.
func (m *ArticleMutation) Where(ps ...predicate.Article) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArticleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArticleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Article, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArticleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArticleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Article).
func (m *ArticleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArticleMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.deleted_at != nil {
		fields = append(fields, article.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, article.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, article.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, article.FieldTitle)
	}
	if m.content_md != nil {
		fields = append(fields, article.FieldContentMd)
	}
	if m.content_html != nil {
		fields = append(fields, article.FieldContentHTML)
	}
	if m.cover_url != nil {
		fields = append(fields, article.FieldCoverURL)
	}
	if m.status != nil {
		fields = append(fields, article.FieldStatus)
	}
	if m.view_count != nil {
		fields = append(fields, article.FieldViewCount)
	}
	if m.word_count != nil {
		fields = append(fields, article.FieldWordCount)
	}
	if m.reading_time != nil {
		fields = append(fields, article.FieldReadingTime)
	}
	if m.ip_location != nil {
		fields = append(fields, article.FieldIPLocation)
	}
	if m.primary_color != nil {
		fields = append(fields, article.FieldPrimaryColor)
	}
	if m.is_primary_color_manual != nil {
		fields = append(fields, article.FieldIsPrimaryColorManual)
	}
	if m.home_sort != nil {
		fields = append(fields, article.FieldHomeSort)
	}
	if m.pin_sort != nil {
		fields = append(fields, article.FieldPinSort)
	}
	if m.top_img_url != nil {
		fields = append(fields, article.FieldTopImgURL)
	}
	if m.summaries != nil {
		fields = append(fields, article.FieldSummaries)
	}
	if m.abbrlink != nil {
		fields = append(fields, article.FieldAbbrlink)
	}
	if m.copyright != nil {
		fields = append(fields, article.FieldCopyright)
	}
	if m.copyright_author != nil {
		fields = append(fields, article.FieldCopyrightAuthor)
	}
	if m.copyright_author_href != nil {
		fields = append(fields, article.FieldCopyrightAuthorHref)
	}
	if m.copyright_url != nil {
		fields = append(fields, article.FieldCopyrightURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArticleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case article.FieldDeletedAt:
		return m.DeletedAt()
	case article.FieldCreatedAt:
		return m.CreatedAt()
	case article.FieldUpdatedAt:
		return m.UpdatedAt()
	case article.FieldTitle:
		return m.Title()
	case article.FieldContentMd:
		return m.ContentMd()
	case article.FieldContentHTML:
		return m.ContentHTML()
	case article.FieldCoverURL:
		return m.CoverURL()
	case article.FieldStatus:
		return m.Status()
	case article.FieldViewCount:
		return m.ViewCount()
	case article.FieldWordCount:
		return m.WordCount()
	case article.FieldReadingTime:
		return m.ReadingTime()
	case article.FieldIPLocation:
		return m.IPLocation()
	case article.FieldPrimaryColor:
		return m.PrimaryColor()
	case article.FieldIsPrimaryColorManual:
		return m.IsPrimaryColorManual()
	case article.FieldHomeSort:
		return m.HomeSort()
	case article.FieldPinSort:
		return m.PinSort()
	case article.FieldTopImgURL:
		return m.TopImgURL()
	case article.FieldSummaries:
		return m.Summaries()
	case article.FieldAbbrlink:
		return m.Abbrlink()
	case article.FieldCopyright:
		return m.Copyright()
	case article.FieldCopyrightAuthor:
		return m.CopyrightAuthor()
	case article.FieldCopyrightAuthorHref:
		return m.CopyrightAuthorHref()
	case article.FieldCopyrightURL:
		return m.CopyrightURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArticleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case article.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case article.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case article.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case article.FieldTitle:
		return m.OldTitle(ctx)
	case article.FieldContentMd:
		return m.OldContentMd(ctx)
	case article.FieldContentHTML:
		return m.OldContentHTML(ctx)
	case article.FieldCoverURL:
		return m.OldCoverURL(ctx)
	case article.FieldStatus:
		return m.OldStatus(ctx)
	case article.FieldViewCount:
		return m.OldViewCount(ctx)
	case article.FieldWordCount:
		return m.OldWordCount(ctx)
	case article.FieldReadingTime:
		return m.OldReadingTime(ctx)
	case article.FieldIPLocation:
		return m.OldIPLocation(ctx)
	case article.FieldPrimaryColor:
		return m.OldPrimaryColor(ctx)
	case article.FieldIsPrimaryColorManual:
		return m.OldIsPrimaryColorManual(ctx)
	case article.FieldHomeSort:
		return m.OldHomeSort(ctx)
	case article.FieldPinSort:
		return m.OldPinSort(ctx)
	case article.FieldTopImgURL:
		return m.OldTopImgURL(ctx)
	case article.FieldSummaries:
		return m.OldSummaries(ctx)
	case article.FieldAbbrlink:
		return m.OldAbbrlink(ctx)
	case article.FieldCopyright:
		return m.OldCopyright(ctx)
	case article.FieldCopyrightAuthor:
		return m.OldCopyrightAuthor(ctx)
	case article.FieldCopyrightAuthorHref:
		return m.OldCopyrightAuthorHref(ctx)
	case article.FieldCopyrightURL:
		return m.OldCopyrightURL(ctx)
	}
	return nil, fmt.Errorf("unknown Article field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case article.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case article.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case article.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case article.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case article.FieldContentMd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentMd(v)
		return nil
	case article.FieldContentHTML:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentHTML(v)
		return nil
	case article.FieldCoverURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverURL(v)
		return nil
	case article.FieldStatus:
		v, ok := value.(article.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case article.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case article.FieldWordCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordCount(v)
		return nil
	case article.FieldReadingTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadingTime(v)
		return nil
	case article.FieldIPLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPLocation(v)
		return nil
	case article.FieldPrimaryColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryColor(v)
		return nil
	case article.FieldIsPrimaryColorManual:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimaryColorManual(v)
		return nil
	case article.FieldHomeSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeSort(v)
		return nil
	case article.FieldPinSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinSort(v)
		return nil
	case article.FieldTopImgURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopImgURL(v)
		return nil
	case article.FieldSummaries:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummaries(v)
		return nil
	case article.FieldAbbrlink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbrlink(v)
		return nil
	case article.FieldCopyright:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyright(v)
		return nil
	case article.FieldCopyrightAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyrightAuthor(v)
		return nil
	case article.FieldCopyrightAuthorHref:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyrightAuthorHref(v)
		return nil
	case article.FieldCopyrightURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyrightURL(v)
		return nil
	}
	return fmt.Errorf("unknown Article field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArticleMutation) AddedFields() []string {
	var fields []string
	if m.addview_count != nil {
		fields = append(fields, article.FieldViewCount)
	}
	if m.addword_count != nil {
		fields = append(fields, article.FieldWordCount)
	}
	if m.addreading_time != nil {
		fields = append(fields, article.FieldReadingTime)
	}
	if m.addhome_sort != nil {
		fields = append(fields, article.FieldHomeSort)
	}
	if m.addpin_sort != nil {
		fields = append(fields, article.FieldPinSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArticleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case article.FieldViewCount:
		return m.AddedViewCount()
	case article.FieldWordCount:
		return m.AddedWordCount()
	case article.FieldReadingTime:
		return m.AddedReadingTime()
	case article.FieldHomeSort:
		return m.AddedHomeSort()
	case article.FieldPinSort:
		return m.AddedPinSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case article.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case article.FieldWordCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWordCount(v)
		return nil
	case article.FieldReadingTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReadingTime(v)
		return nil
	case article.FieldHomeSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeSort(v)
		return nil
	case article.FieldPinSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPinSort(v)
		return nil
	}
	return fmt.Errorf("unknown Article numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArticleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(article.FieldDeletedAt) {
		fields = append(fields, article.FieldDeletedAt)
	}
	if m.FieldCleared(article.FieldContentMd) {
		fields = append(fields, article.FieldContentMd)
	}
	if m.FieldCleared(article.FieldContentHTML) {
		fields = append(fields, article.FieldContentHTML)
	}
	if m.FieldCleared(article.FieldCoverURL) {
		fields = append(fields, article.FieldCoverURL)
	}
	if m.FieldCleared(article.FieldIPLocation) {
		fields = append(fields, article.FieldIPLocation)
	}
	if m.FieldCleared(article.FieldPrimaryColor) {
		fields = append(fields, article.FieldPrimaryColor)
	}
	if m.FieldCleared(article.FieldTopImgURL) {
		fields = append(fields, article.FieldTopImgURL)
	}
	if m.FieldCleared(article.FieldSummaries) {
		fields = append(fields, article.FieldSummaries)
	}
	if m.FieldCleared(article.FieldAbbrlink) {
		fields = append(fields, article.FieldAbbrlink)
	}
	if m.FieldCleared(article.FieldCopyrightAuthor) {
		fields = append(fields, article.FieldCopyrightAuthor)
	}
	if m.FieldCleared(article.FieldCopyrightAuthorHref) {
		fields = append(fields, article.FieldCopyrightAuthorHref)
	}
	if m.FieldCleared(article.FieldCopyrightURL) {
		fields = append(fields, article.FieldCopyrightURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArticleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArticleMutation) ClearField(name string) error {
	switch name {
	case article.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case article.FieldContentMd:
		m.ClearContentMd()
		return nil
	case article.FieldContentHTML:
		m.ClearContentHTML()
		return nil
	case article.FieldCoverURL:
		m.ClearCoverURL()
		return nil
	case article.FieldIPLocation:
		m.ClearIPLocation()
		return nil
	case article.FieldPrimaryColor:
		m.ClearPrimaryColor()
		return nil
	case article.FieldTopImgURL:
		m.ClearTopImgURL()
		return nil
	case article.FieldSummaries:
		m.ClearSummaries()
		return nil
	case article.FieldAbbrlink:
		m.ClearAbbrlink()
		return nil
	case article.FieldCopyrightAuthor:
		m.ClearCopyrightAuthor()
		return nil
	case article.FieldCopyrightAuthorHref:
		m.ClearCopyrightAuthorHref()
		return nil
	case article.FieldCopyrightURL:
		m.ClearCopyrightURL()
		return nil
	}
	return fmt.Errorf("unknown Article nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArticleMutation) ResetField(name string) error {
	switch name {
	case article.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case article.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case article.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case article.FieldTitle:
		m.ResetTitle()
		return nil
	case article.FieldContentMd:
		m.ResetContentMd()
		return nil
	case article.FieldContentHTML:
		m.ResetContentHTML()
		return nil
	case article.FieldCoverURL:
		m.ResetCoverURL()
		return nil
	case article.FieldStatus:
		m.ResetStatus()
		return nil
	case article.FieldViewCount:
		m.ResetViewCount()
		return nil
	case article.FieldWordCount:
		m.ResetWordCount()
		return nil
	case article.FieldReadingTime:
		m.ResetReadingTime()
		return nil
	case article.FieldIPLocation:
		m.ResetIPLocation()
		return nil
	case article.FieldPrimaryColor:
		m.ResetPrimaryColor()
		return nil
	case article.FieldIsPrimaryColorManual:
		m.ResetIsPrimaryColorManual()
		return nil
	case article.FieldHomeSort:
		m.ResetHomeSort()
		return nil
	case article.FieldPinSort:
		m.ResetPinSort()
		return nil
	case article.FieldTopImgURL:
		m.ResetTopImgURL()
		return nil
	case article.FieldSummaries:
		m.ResetSummaries()
		return nil
	case article.FieldAbbrlink:
		m.ResetAbbrlink()
		return nil
	case article.FieldCopyright:
		m.ResetCopyright()
		return nil
	case article.FieldCopyrightAuthor:
		m.ResetCopyrightAuthor()
		return nil
	case article.FieldCopyrightAuthorHref:
		m.ResetCopyrightAuthorHref()
		return nil
	case article.FieldCopyrightURL:
		m.ResetCopyrightURL()
		return nil
	}
	return fmt.Errorf("unknown Article field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArticleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.post_tags != nil {
		edges = append(edges, article.EdgePostTags)
	}
	if m.post_categories != nil {
		edges = append(edges, article.EdgePostCategories)
	}
	if m.comments != nil {
		edges = append(edges, article.EdgeComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArticleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case article.EdgePostTags:
		ids := make([]ent.Value, 0, len(m.post_tags))
		for id := range m.post_tags {
			ids = append(ids, id)
		}
		return ids
	case article.EdgePostCategories:
		ids := make([]ent.Value, 0, len(m.post_categories))
		for id := range m.post_categories {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArticleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpost_tags != nil {
		edges = append(edges, article.EdgePostTags)
	}
	if m.removedpost_categories != nil {
		edges = append(edges, article.EdgePostCategories)
	}
	if m.removedcomments != nil {
		edges = append(edges, article.EdgeComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArticleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case article.EdgePostTags:
		ids := make([]ent.Value, 0, len(m.removedpost_tags))
		for id := range m.removedpost_tags {
			ids = append(ids, id)
		}
		return ids
	case article.EdgePostCategories:
		ids := make([]ent.Value, 0, len(m.removedpost_categories))
		for id := range m.removedpost_categories {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArticleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpost_tags {
		edges = append(edges, article.EdgePostTags)
	}
	if m.clearedpost_categories {
		edges = append(edges, article.EdgePostCategories)
	}
	if m.clearedcomments {
		edges = append(edges, article.EdgeComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArticleMutation) EdgeCleared(name string) bool {
	switch name {
	case article.EdgePostTags:
		return m.clearedpost_tags
	case article.EdgePostCategories:
		return m.clearedpost_categories
	case article.EdgeComments:
		return m.clearedcomments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArticleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Article unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArticleMutation) ResetEdge(name string) error {
	switch name {
	case article.EdgePostTags:
		m.ResetPostTags()
		return nil
	case article.EdgePostCategories:
		m.ResetPostCategories()
		return nil
	case article.EdgeComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown Article edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint
	deleted_at         *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	target_path        *string
	target_title       *string
	nickname           *string
	email              *string
	email_md5          *string
	website            *string
	content            *string
	content_html       *string
	status             *int
	addstatus          *int
	is_admin_comment   *bool
	allow_notification *bool
	user_agent         *string
	ip_address         *string
	ip_location        *string
	like_count         *int
	addlike_count      *int
	pinned_at          *time.Time
	clearedFields      map[string]struct{}
	user               *uint
	cleareduser        bool
	children           *uint
	clearedchildren    bool
	parent             map[uint]struct{}
	removedparent      map[uint]struct{}
	clearedparent      bool
	done               bool
	oldValue           func(context.Context) (*Comment, error)
	predicates         []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id uint) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CommentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[comment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CommentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[comment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, comment.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTargetPath sets the "target_path" field.
func (m *CommentMutation) SetTargetPath(s string) {
	m.target_path = &s
}

// TargetPath returns the value of the "target_path" field in the mutation.
func (m *CommentMutation) TargetPath() (r string, exists bool) {
	v := m.target_path
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetPath returns the old "target_path" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldTargetPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetPath: %w", err)
	}
	return oldValue.TargetPath, nil
}

// ResetTargetPath resets all changes to the "target_path" field.
func (m *CommentMutation) ResetTargetPath() {
	m.target_path = nil
}

// SetTargetTitle sets the "target_title" field.
func (m *CommentMutation) SetTargetTitle(s string) {
	m.target_title = &s
}

// TargetTitle returns the value of the "target_title" field in the mutation.
func (m *CommentMutation) TargetTitle() (r string, exists bool) {
	v := m.target_title
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetTitle returns the old "target_title" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldTargetTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetTitle: %w", err)
	}
	return oldValue.TargetTitle, nil
}

// ClearTargetTitle clears the value of the "target_title" field.
func (m *CommentMutation) ClearTargetTitle() {
	m.target_title = nil
	m.clearedFields[comment.FieldTargetTitle] = struct{}{}
}

// TargetTitleCleared returns if the "target_title" field was cleared in this mutation.
func (m *CommentMutation) TargetTitleCleared() bool {
	_, ok := m.clearedFields[comment.FieldTargetTitle]
	return ok
}

// ResetTargetTitle resets all changes to the "target_title" field.
func (m *CommentMutation) ResetTargetTitle() {
	m.target_title = nil
	delete(m.clearedFields, comment.FieldTargetTitle)
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(u uint) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r uint, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CommentMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[comment.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CommentMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, comment.FieldUserID)
}

// SetParentID sets the "parent_id" field.
func (m *CommentMutation) SetParentID(u uint) {
	m.children = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CommentMutation) ParentID() (r uint, exists bool) {
	v := m.children
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CommentMutation) ClearParentID() {
	m.children = nil
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CommentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CommentMutation) ResetParentID() {
	m.children = nil
	delete(m.clearedFields, comment.FieldParentID)
}

// SetNickname sets the "nickname" field.
func (m *CommentMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *CommentMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *CommentMutation) ResetNickname() {
	m.nickname = nil
}

// SetEmail sets the "email" field.
func (m *CommentMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CommentMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *CommentMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[comment.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *CommentMutation) EmailCleared() bool {
	_, ok := m.clearedFields[comment.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *CommentMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, comment.FieldEmail)
}

// SetEmailMd5 sets the "email_md5" field.
func (m *CommentMutation) SetEmailMd5(s string) {
	m.email_md5 = &s
}

// EmailMd5 returns the value of the "email_md5" field in the mutation.
func (m *CommentMutation) EmailMd5() (r string, exists bool) {
	v := m.email_md5
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailMd5 returns the old "email_md5" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldEmailMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailMd5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailMd5: %w", err)
	}
	return oldValue.EmailMd5, nil
}

// ResetEmailMd5 resets all changes to the "email_md5" field.
func (m *CommentMutation) ResetEmailMd5() {
	m.email_md5 = nil
}

// SetWebsite sets the "website" field.
func (m *CommentMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *CommentMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldWebsite(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *CommentMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[comment.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *CommentMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[comment.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *CommentMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, comment.FieldWebsite)
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
}

// SetContentHTML sets the "content_html" field.
func (m *CommentMutation) SetContentHTML(s string) {
	m.content_html = &s
}

// ContentHTML returns the value of the "content_html" field in the mutation.
func (m *CommentMutation) ContentHTML() (r string, exists bool) {
	v := m.content_html
	if v == nil {
		return
	}
	return *v, true
}

// OldContentHTML returns the old "content_html" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContentHTML(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentHTML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentHTML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentHTML: %w", err)
	}
	return oldValue.ContentHTML, nil
}

// ResetContentHTML resets all changes to the "content_html" field.
func (m *CommentMutation) ResetContentHTML() {
	m.content_html = nil
}

// SetStatus sets the "status" field.
func (m *CommentMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CommentMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CommentMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CommentMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CommentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetIsAdminComment sets the "is_admin_comment" field.
func (m *CommentMutation) SetIsAdminComment(b bool) {
	m.is_admin_comment = &b
}

// IsAdminComment returns the value of the "is_admin_comment" field in the mutation.
func (m *CommentMutation) IsAdminComment() (r bool, exists bool) {
	v := m.is_admin_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdminComment returns the old "is_admin_comment" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIsAdminComment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdminComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdminComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdminComment: %w", err)
	}
	return oldValue.IsAdminComment, nil
}

// ResetIsAdminComment resets all changes to the "is_admin_comment" field.
func (m *CommentMutation) ResetIsAdminComment() {
	m.is_admin_comment = nil
}

// SetAllowNotification sets the "allow_notification" field.
func (m *CommentMutation) SetAllowNotification(b bool) {
	m.allow_notification = &b
}

// AllowNotification returns the value of the "allow_notification" field in the mutation.
func (m *CommentMutation) AllowNotification() (r bool, exists bool) {
	v := m.allow_notification
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowNotification returns the old "allow_notification" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAllowNotification(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowNotification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowNotification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowNotification: %w", err)
	}
	return oldValue.AllowNotification, nil
}

// ResetAllowNotification resets all changes to the "allow_notification" field.
func (m *CommentMutation) ResetAllowNotification() {
	m.allow_notification = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *CommentMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *CommentMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *CommentMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[comment.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *CommentMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *CommentMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, comment.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *CommentMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *CommentMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *CommentMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetIPLocation sets the "ip_location" field.
func (m *CommentMutation) SetIPLocation(s string) {
	m.ip_location = &s
}

// IPLocation returns the value of the "ip_location" field in the mutation.
func (m *CommentMutation) IPLocation() (r string, exists bool) {
	v := m.ip_location
	if v == nil {
		return
	}
	return *v, true
}

// OldIPLocation returns the old "ip_location" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIPLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPLocation: %w", err)
	}
	return oldValue.IPLocation, nil
}

// ClearIPLocation clears the value of the "ip_location" field.
func (m *CommentMutation) ClearIPLocation() {
	m.ip_location = nil
	m.clearedFields[comment.FieldIPLocation] = struct{}{}
}

// IPLocationCleared returns if the "ip_location" field was cleared in this mutation.
func (m *CommentMutation) IPLocationCleared() bool {
	_, ok := m.clearedFields[comment.FieldIPLocation]
	return ok
}

// ResetIPLocation resets all changes to the "ip_location" field.
func (m *CommentMutation) ResetIPLocation() {
	m.ip_location = nil
	delete(m.clearedFields, comment.FieldIPLocation)
}

// SetLikeCount sets the "like_count" field.
func (m *CommentMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *CommentMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *CommentMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *CommentMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *CommentMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetPinnedAt sets the "pinned_at" field.
func (m *CommentMutation) SetPinnedAt(t time.Time) {
	m.pinned_at = &t
}

// PinnedAt returns the value of the "pinned_at" field in the mutation.
func (m *CommentMutation) PinnedAt() (r time.Time, exists bool) {
	v := m.pinned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPinnedAt returns the old "pinned_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPinnedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinnedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinnedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinnedAt: %w", err)
	}
	return oldValue.PinnedAt, nil
}

// ClearPinnedAt clears the value of the "pinned_at" field.
func (m *CommentMutation) ClearPinnedAt() {
	m.pinned_at = nil
	m.clearedFields[comment.FieldPinnedAt] = struct{}{}
}

// PinnedAtCleared returns if the "pinned_at" field was cleared in this mutation.
func (m *CommentMutation) PinnedAtCleared() bool {
	_, ok := m.clearedFields[comment.FieldPinnedAt]
	return ok
}

// ResetPinnedAt resets all changes to the "pinned_at" field.
func (m *CommentMutation) ResetPinnedAt() {
	m.pinned_at = nil
	delete(m.clearedFields, comment.FieldPinnedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *CommentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[comment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CommentMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) UserIDs() (ids []uint) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetChildrenID sets the "children" edge to the Comment entity by id.
func (m *CommentMutation) SetChildrenID(id uint) {
	m.children = &id
}

// ClearChildren clears the "children" edge to the Comment entity.
func (m *CommentMutation) ClearChildren() {
	m.clearedchildren = true
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ChildrenCleared reports if the "children" edge to the Comment entity was cleared.
func (m *CommentMutation) ChildrenCleared() bool {
	return m.ParentIDCleared() || m.clearedchildren
}

// ChildrenID returns the "children" edge ID in the mutation.
func (m *CommentMutation) ChildrenID() (id uint, exists bool) {
	if m.children != nil {
		return *m.children, true
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChildrenID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ChildrenIDs() (ids []uint) {
	if id := m.children; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CommentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
}

// AddParentIDs adds the "parent" edge to the Comment entity by ids.
func (m *CommentMutation) AddParentIDs(ids ...uint) {
	if m.parent == nil {
		m.parent = make(map[uint]struct{})
	}
	for i := range ids {
		m.parent[ids[i]] = struct{}{}
	}
}

// ClearParent clears the "parent" edge to the Comment entity.
func (m *CommentMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Comment entity was cleared.
func (m *CommentMutation) ParentCleared() bool {
	return m.clearedparent
}

// RemoveParentIDs removes the "parent" edge to the Comment entity by IDs.
func (m *CommentMutation) RemoveParentIDs(ids ...uint) {
	if m.removedparent == nil {
		m.removedparent = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.parent, ids[i])
		m.removedparent[ids[i]] = struct{}{}
	}
}

// RemovedParent returns the removed IDs of the "parent" edge to the Comment entity.
func (m *CommentMutation) RemovedParentIDs() (ids []uint) {
	for id := range m.removedparent {
		ids = append(ids, id)
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
func (m *CommentMutation) ParentIDs() (ids []uint) {
	for id := range m.parent {
		ids = append(ids, id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
	m.removedparent = nil
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.deleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.target_path != nil {
		fields = append(fields, comment.FieldTargetPath)
	}
	if m.target_title != nil {
		fields = append(fields, comment.FieldTargetTitle)
	}
	if m.user != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.children != nil {
		fields = append(fields, comment.FieldParentID)
	}
	if m.nickname != nil {
		fields = append(fields, comment.FieldNickname)
	}
	if m.email != nil {
		fields = append(fields, comment.FieldEmail)
	}
	if m.email_md5 != nil {
		fields = append(fields, comment.FieldEmailMd5)
	}
	if m.website != nil {
		fields = append(fields, comment.FieldWebsite)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.content_html != nil {
		fields = append(fields, comment.FieldContentHTML)
	}
	if m.status != nil {
		fields = append(fields, comment.FieldStatus)
	}
	if m.is_admin_comment != nil {
		fields = append(fields, comment.FieldIsAdminComment)
	}
	if m.allow_notification != nil {
		fields = append(fields, comment.FieldAllowNotification)
	}
	if m.user_agent != nil {
		fields = append(fields, comment.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, comment.FieldIPAddress)
	}
	if m.ip_location != nil {
		fields = append(fields, comment.FieldIPLocation)
	}
	if m.like_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	if m.pinned_at != nil {
		fields = append(fields, comment.FieldPinnedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldDeletedAt:
		return m.DeletedAt()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldTargetPath:
		return m.TargetPath()
	case comment.FieldTargetTitle:
		return m.TargetTitle()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldParentID:
		return m.ParentID()
	case comment.FieldNickname:
		return m.Nickname()
	case comment.FieldEmail:
		return m.Email()
	case comment.FieldEmailMd5:
		return m.EmailMd5()
	case comment.FieldWebsite:
		return m.Website()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldContentHTML:
		return m.ContentHTML()
	case comment.FieldStatus:
		return m.Status()
	case comment.FieldIsAdminComment:
		return m.IsAdminComment()
	case comment.FieldAllowNotification:
		return m.AllowNotification()
	case comment.FieldUserAgent:
		return m.UserAgent()
	case comment.FieldIPAddress:
		return m.IPAddress()
	case comment.FieldIPLocation:
		return m.IPLocation()
	case comment.FieldLikeCount:
		return m.LikeCount()
	case comment.FieldPinnedAt:
		return m.PinnedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldTargetPath:
		return m.OldTargetPath(ctx)
	case comment.FieldTargetTitle:
		return m.OldTargetTitle(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldParentID:
		return m.OldParentID(ctx)
	case comment.FieldNickname:
		return m.OldNickname(ctx)
	case comment.FieldEmail:
		return m.OldEmail(ctx)
	case comment.FieldEmailMd5:
		return m.OldEmailMd5(ctx)
	case comment.FieldWebsite:
		return m.OldWebsite(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldContentHTML:
		return m.OldContentHTML(ctx)
	case comment.FieldStatus:
		return m.OldStatus(ctx)
	case comment.FieldIsAdminComment:
		return m.OldIsAdminComment(ctx)
	case comment.FieldAllowNotification:
		return m.OldAllowNotification(ctx)
	case comment.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case comment.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case comment.FieldIPLocation:
		return m.OldIPLocation(ctx)
	case comment.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case comment.FieldPinnedAt:
		return m.OldPinnedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldTargetPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetPath(v)
		return nil
	case comment.FieldTargetTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetTitle(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case comment.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case comment.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case comment.FieldEmailMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailMd5(v)
		return nil
	case comment.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldContentHTML:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentHTML(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case comment.FieldIsAdminComment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdminComment(v)
		return nil
	case comment.FieldAllowNotification:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowNotification(v)
		return nil
	case comment.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case comment.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case comment.FieldIPLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPLocation(v)
		return nil
	case comment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case comment.FieldPinnedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinnedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, comment.FieldStatus)
	}
	if m.addlike_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldStatus:
		return m.AddedStatus()
	case comment.FieldLikeCount:
		return m.AddedLikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case comment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldDeletedAt) {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.FieldCleared(comment.FieldTargetTitle) {
		fields = append(fields, comment.FieldTargetTitle)
	}
	if m.FieldCleared(comment.FieldUserID) {
		fields = append(fields, comment.FieldUserID)
	}
	if m.FieldCleared(comment.FieldParentID) {
		fields = append(fields, comment.FieldParentID)
	}
	if m.FieldCleared(comment.FieldEmail) {
		fields = append(fields, comment.FieldEmail)
	}
	if m.FieldCleared(comment.FieldWebsite) {
		fields = append(fields, comment.FieldWebsite)
	}
	if m.FieldCleared(comment.FieldUserAgent) {
		fields = append(fields, comment.FieldUserAgent)
	}
	if m.FieldCleared(comment.FieldIPLocation) {
		fields = append(fields, comment.FieldIPLocation)
	}
	if m.FieldCleared(comment.FieldPinnedAt) {
		fields = append(fields, comment.FieldPinnedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case comment.FieldTargetTitle:
		m.ClearTargetTitle()
		return nil
	case comment.FieldUserID:
		m.ClearUserID()
		return nil
	case comment.FieldParentID:
		m.ClearParentID()
		return nil
	case comment.FieldEmail:
		m.ClearEmail()
		return nil
	case comment.FieldWebsite:
		m.ClearWebsite()
		return nil
	case comment.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case comment.FieldIPLocation:
		m.ClearIPLocation()
		return nil
	case comment.FieldPinnedAt:
		m.ClearPinnedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldTargetPath:
		m.ResetTargetPath()
		return nil
	case comment.FieldTargetTitle:
		m.ResetTargetTitle()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldParentID:
		m.ResetParentID()
		return nil
	case comment.FieldNickname:
		m.ResetNickname()
		return nil
	case comment.FieldEmail:
		m.ResetEmail()
		return nil
	case comment.FieldEmailMd5:
		m.ResetEmailMd5()
		return nil
	case comment.FieldWebsite:
		m.ResetWebsite()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldContentHTML:
		m.ResetContentHTML()
		return nil
	case comment.FieldStatus:
		m.ResetStatus()
		return nil
	case comment.FieldIsAdminComment:
		m.ResetIsAdminComment()
		return nil
	case comment.FieldAllowNotification:
		m.ResetAllowNotification()
		return nil
	case comment.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case comment.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case comment.FieldIPLocation:
		m.ResetIPLocation()
		return nil
	case comment.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case comment.FieldPinnedAt:
		m.ResetPinnedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, comment.EdgeUser)
	}
	if m.children != nil {
		edges = append(edges, comment.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, comment.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeChildren:
		if id := m.children; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeParent:
		ids := make([]ent.Value, 0, len(m.parent))
		for id := range m.parent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedparent != nil {
		edges = append(edges, comment.EdgeParent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeParent:
		ids := make([]ent.Value, 0, len(m.removedparent))
		for id := range m.removedparent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, comment.EdgeUser)
	}
	if m.clearedchildren {
		edges = append(edges, comment.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, comment.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeUser:
		return m.cleareduser
	case comment.EdgeChildren:
		return m.clearedchildren
	case comment.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeUser:
		m.ClearUser()
		return nil
	case comment.EdgeChildren:
		m.ClearChildren()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeUser:
		m.ResetUser()
		return nil
	case comment.EdgeChildren:
		m.ResetChildren()
		return nil
	case comment.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// DirectLinkMutation represents an operation that mutates the DirectLink nodes in the graph.
type DirectLinkMutation struct {
	config
	op             Op
	typ            string
	id             *uint
	deleted_at     *time.Time
	created_at     *time.Time
	updated_at     *time.Time
	file_name      *string
	speed_limit    *int64
	addspeed_limit *int64
	downloads      *int64
	adddownloads   *int64
	clearedFields  map[string]struct{}
	file           *uint
	clearedfile    bool
	done           bool
	oldValue       func(context.Context) (*DirectLink, error)
	predicates     []predicate.DirectLink
}

var _ ent.Mutation = (*DirectLinkMutation)(nil)

// directlinkOption allows management of the mutation configuration using functional options.
type directlinkOption func(*DirectLinkMutation)

// newDirectLinkMutation creates new mutation for the DirectLink entity.
func newDirectLinkMutation(c config, op Op, opts ...directlinkOption) *DirectLinkMutation {
	m := &DirectLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeDirectLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDirectLinkID sets the ID field of the mutation.
func withDirectLinkID(id uint) directlinkOption {
	return func(m *DirectLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *DirectLink
		)
		m.oldValue = func(ctx context.Context) (*DirectLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DirectLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDirectLink sets the old DirectLink of the mutation.
func withDirectLink(node *DirectLink) directlinkOption {
	return func(m *DirectLinkMutation) {
		m.oldValue = func(context.Context) (*DirectLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DirectLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DirectLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DirectLink entities.
func (m *DirectLinkMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DirectLinkMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DirectLinkMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DirectLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DirectLinkMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DirectLinkMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DirectLinkMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[directlink.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DirectLinkMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[directlink.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DirectLinkMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, directlink.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *DirectLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DirectLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DirectLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DirectLinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DirectLinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DirectLinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFileID sets the "file_id" field.
func (m *DirectLinkMutation) SetFileID(u uint) {
	m.file = &u
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *DirectLinkMutation) FileID() (r uint, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldFileID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *DirectLinkMutation) ResetFileID() {
	m.file = nil
}

// SetFileName sets the "file_name" field.
func (m *DirectLinkMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *DirectLinkMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *DirectLinkMutation) ResetFileName() {
	m.file_name = nil
}

// SetSpeedLimit sets the "speed_limit" field.
func (m *DirectLinkMutation) SetSpeedLimit(i int64) {
	m.speed_limit = &i
	m.addspeed_limit = nil
}

// SpeedLimit returns the value of the "speed_limit" field in the mutation.
func (m *DirectLinkMutation) SpeedLimit() (r int64, exists bool) {
	v := m.speed_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeedLimit returns the old "speed_limit" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldSpeedLimit(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeedLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeedLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeedLimit: %w", err)
	}
	return oldValue.SpeedLimit, nil
}

// AddSpeedLimit adds i to the "speed_limit" field.
func (m *DirectLinkMutation) AddSpeedLimit(i int64) {
	if m.addspeed_limit != nil {
		*m.addspeed_limit += i
	} else {
		m.addspeed_limit = &i
	}
}

// AddedSpeedLimit returns the value that was added to the "speed_limit" field in this mutation.
func (m *DirectLinkMutation) AddedSpeedLimit() (r int64, exists bool) {
	v := m.addspeed_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpeedLimit resets all changes to the "speed_limit" field.
func (m *DirectLinkMutation) ResetSpeedLimit() {
	m.speed_limit = nil
	m.addspeed_limit = nil
}

// SetDownloads sets the "downloads" field.
func (m *DirectLinkMutation) SetDownloads(i int64) {
	m.downloads = &i
	m.adddownloads = nil
}

// Downloads returns the value of the "downloads" field in the mutation.
func (m *DirectLinkMutation) Downloads() (r int64, exists bool) {
	v := m.downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloads returns the old "downloads" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldDownloads(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloads: %w", err)
	}
	return oldValue.Downloads, nil
}

// AddDownloads adds i to the "downloads" field.
func (m *DirectLinkMutation) AddDownloads(i int64) {
	if m.adddownloads != nil {
		*m.adddownloads += i
	} else {
		m.adddownloads = &i
	}
}

// AddedDownloads returns the value that was added to the "downloads" field in this mutation.
func (m *DirectLinkMutation) AddedDownloads() (r int64, exists bool) {
	v := m.adddownloads
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloads resets all changes to the "downloads" field.
func (m *DirectLinkMutation) ResetDownloads() {
	m.downloads = nil
	m.adddownloads = nil
}

// ClearFile clears the "file" edge to the File entity.
func (m *DirectLinkMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[directlink.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *DirectLinkMutation) FileCleared() bool {
	return m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *DirectLinkMutation) FileIDs() (ids []uint) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *DirectLinkMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the DirectLinkMutation builder.
func (m *DirectLinkMutation) Where(ps ...predicate.DirectLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DirectLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DirectLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DirectLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DirectLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DirectLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DirectLink).
func (m *DirectLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DirectLinkMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.deleted_at != nil {
		fields = append(fields, directlink.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, directlink.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, directlink.FieldUpdatedAt)
	}
	if m.file != nil {
		fields = append(fields, directlink.FieldFileID)
	}
	if m.file_name != nil {
		fields = append(fields, directlink.FieldFileName)
	}
	if m.speed_limit != nil {
		fields = append(fields, directlink.FieldSpeedLimit)
	}
	if m.downloads != nil {
		fields = append(fields, directlink.FieldDownloads)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DirectLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case directlink.FieldDeletedAt:
		return m.DeletedAt()
	case directlink.FieldCreatedAt:
		return m.CreatedAt()
	case directlink.FieldUpdatedAt:
		return m.UpdatedAt()
	case directlink.FieldFileID:
		return m.FileID()
	case directlink.FieldFileName:
		return m.FileName()
	case directlink.FieldSpeedLimit:
		return m.SpeedLimit()
	case directlink.FieldDownloads:
		return m.Downloads()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DirectLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case directlink.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case directlink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case directlink.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case directlink.FieldFileID:
		return m.OldFileID(ctx)
	case directlink.FieldFileName:
		return m.OldFileName(ctx)
	case directlink.FieldSpeedLimit:
		return m.OldSpeedLimit(ctx)
	case directlink.FieldDownloads:
		return m.OldDownloads(ctx)
	}
	return nil, fmt.Errorf("unknown DirectLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case directlink.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case directlink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case directlink.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case directlink.FieldFileID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case directlink.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case directlink.FieldSpeedLimit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeedLimit(v)
		return nil
	case directlink.FieldDownloads:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloads(v)
		return nil
	}
	return fmt.Errorf("unknown DirectLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DirectLinkMutation) AddedFields() []string {
	var fields []string
	if m.addspeed_limit != nil {
		fields = append(fields, directlink.FieldSpeedLimit)
	}
	if m.adddownloads != nil {
		fields = append(fields, directlink.FieldDownloads)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DirectLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case directlink.FieldSpeedLimit:
		return m.AddedSpeedLimit()
	case directlink.FieldDownloads:
		return m.AddedDownloads()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case directlink.FieldSpeedLimit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeedLimit(v)
		return nil
	case directlink.FieldDownloads:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloads(v)
		return nil
	}
	return fmt.Errorf("unknown DirectLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DirectLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(directlink.FieldDeletedAt) {
		fields = append(fields, directlink.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DirectLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DirectLinkMutation) ClearField(name string) error {
	switch name {
	case directlink.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DirectLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DirectLinkMutation) ResetField(name string) error {
	switch name {
	case directlink.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case directlink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case directlink.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case directlink.FieldFileID:
		m.ResetFileID()
		return nil
	case directlink.FieldFileName:
		m.ResetFileName()
		return nil
	case directlink.FieldSpeedLimit:
		m.ResetSpeedLimit()
		return nil
	case directlink.FieldDownloads:
		m.ResetDownloads()
		return nil
	}
	return fmt.Errorf("unknown DirectLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DirectLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, directlink.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DirectLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case directlink.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DirectLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DirectLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DirectLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, directlink.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DirectLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case directlink.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DirectLinkMutation) ClearEdge(name string) error {
	switch name {
	case directlink.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown DirectLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DirectLinkMutation) ResetEdge(name string) error {
	switch name {
	case directlink.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown DirectLink edge %s", name)
}

// EntityMutation represents an operation that mutates the Entity nodes in the graph.
type EntityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint
	created_at           *time.Time
	updated_at           *time.Time
	_type                *string
	source               *string
	size                 *int64
	addsize              *int64
	upload_session_id    *string
	recycle_options      *string
	policy_id            *uint
	addpolicy_id         *int
	created_by           *uint64
	addcreated_by        *int64
	etag                 *string
	mime_type            *string
	dimension            *string
	storage_metadata     *model.JSONMap
	clearedFields        map[string]struct{}
	file_versions        map[uint]struct{}
	removedfile_versions map[uint]struct{}
	clearedfile_versions bool
	done                 bool
	oldValue             func(context.Context) (*Entity, error)
	predicates           []predicate.Entity
}

var _ ent.Mutation = (*EntityMutation)(nil)

// entityOption allows management of the mutation configuration using functional options.
type entityOption func(*EntityMutation)

// newEntityMutation creates new mutation for the Entity entity.
func newEntityMutation(c config, op Op, opts ...entityOption) *EntityMutation {
	m := &EntityMutation{
		config:        c,
		op:            op,
		typ:           TypeEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityID sets the ID field of the mutation.
func withEntityID(id uint) entityOption {
	return func(m *EntityMutation) {
		var (
			err   error
			once  sync.Once
			value *Entity
		)
		m.oldValue = func(ctx context.Context) (*Entity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntity sets the old Entity of the mutation.
func withEntity(node *Entity) entityOption {
	return func(m *EntityMutation) {
		m.oldValue = func(context.Context) (*Entity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entity entities.
func (m *EntityMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *EntityMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *EntityMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EntityMutation) ResetType() {
	m._type = nil
}

// SetSource sets the "source" field.
func (m *EntityMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *EntityMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSource(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *EntityMutation) ClearSource() {
	m.source = nil
	m.clearedFields[entity.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *EntityMutation) SourceCleared() bool {
	_, ok := m.clearedFields[entity.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *EntityMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, entity.FieldSource)
}

// SetSize sets the "size" field.
func (m *EntityMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *EntityMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *EntityMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *EntityMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *EntityMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetUploadSessionID sets the "upload_session_id" field.
func (m *EntityMutation) SetUploadSessionID(s string) {
	m.upload_session_id = &s
}

// UploadSessionID returns the value of the "upload_session_id" field in the mutation.
func (m *EntityMutation) UploadSessionID() (r string, exists bool) {
	v := m.upload_session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadSessionID returns the old "upload_session_id" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldUploadSessionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadSessionID: %w", err)
	}
	return oldValue.UploadSessionID, nil
}

// ClearUploadSessionID clears the value of the "upload_session_id" field.
func (m *EntityMutation) ClearUploadSessionID() {
	m.upload_session_id = nil
	m.clearedFields[entity.FieldUploadSessionID] = struct{}{}
}

// UploadSessionIDCleared returns if the "upload_session_id" field was cleared in this mutation.
func (m *EntityMutation) UploadSessionIDCleared() bool {
	_, ok := m.clearedFields[entity.FieldUploadSessionID]
	return ok
}

// ResetUploadSessionID resets all changes to the "upload_session_id" field.
func (m *EntityMutation) ResetUploadSessionID() {
	m.upload_session_id = nil
	delete(m.clearedFields, entity.FieldUploadSessionID)
}

// SetRecycleOptions sets the "recycle_options" field.
func (m *EntityMutation) SetRecycleOptions(s string) {
	m.recycle_options = &s
}

// RecycleOptions returns the value of the "recycle_options" field in the mutation.
func (m *EntityMutation) RecycleOptions() (r string, exists bool) {
	v := m.recycle_options
	if v == nil {
		return
	}
	return *v, true
}

// OldRecycleOptions returns the old "recycle_options" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldRecycleOptions(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecycleOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecycleOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecycleOptions: %w", err)
	}
	return oldValue.RecycleOptions, nil
}

// ClearRecycleOptions clears the value of the "recycle_options" field.
func (m *EntityMutation) ClearRecycleOptions() {
	m.recycle_options = nil
	m.clearedFields[entity.FieldRecycleOptions] = struct{}{}
}

// RecycleOptionsCleared returns if the "recycle_options" field was cleared in this mutation.
func (m *EntityMutation) RecycleOptionsCleared() bool {
	_, ok := m.clearedFields[entity.FieldRecycleOptions]
	return ok
}

// ResetRecycleOptions resets all changes to the "recycle_options" field.
func (m *EntityMutation) ResetRecycleOptions() {
	m.recycle_options = nil
	delete(m.clearedFields, entity.FieldRecycleOptions)
}

// SetPolicyID sets the "policy_id" field.
func (m *EntityMutation) SetPolicyID(u uint) {
	m.policy_id = &u
	m.addpolicy_id = nil
}

// PolicyID returns the value of the "policy_id" field in the mutation.
func (m *EntityMutation) PolicyID() (r uint, exists bool) {
	v := m.policy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicyID returns the old "policy_id" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldPolicyID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicyID: %w", err)
	}
	return oldValue.PolicyID, nil
}

// AddPolicyID adds u to the "policy_id" field.
func (m *EntityMutation) AddPolicyID(u int) {
	if m.addpolicy_id != nil {
		*m.addpolicy_id += u
	} else {
		m.addpolicy_id = &u
	}
}

// AddedPolicyID returns the value that was added to the "policy_id" field in this mutation.
func (m *EntityMutation) AddedPolicyID() (r int, exists bool) {
	v := m.addpolicy_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPolicyID resets all changes to the "policy_id" field.
func (m *EntityMutation) ResetPolicyID() {
	m.policy_id = nil
	m.addpolicy_id = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EntityMutation) SetCreatedBy(u uint64) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntityMutation) CreatedBy() (r uint64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldCreatedBy(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *EntityMutation) AddCreatedBy(u int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EntityMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntityMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[entity.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntityMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entity.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntityMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, entity.FieldCreatedBy)
}

// SetEtag sets the "etag" field.
func (m *EntityMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *EntityMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldEtag(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ClearEtag clears the value of the "etag" field.
func (m *EntityMutation) ClearEtag() {
	m.etag = nil
	m.clearedFields[entity.FieldEtag] = struct{}{}
}

// EtagCleared returns if the "etag" field was cleared in this mutation.
func (m *EntityMutation) EtagCleared() bool {
	_, ok := m.clearedFields[entity.FieldEtag]
	return ok
}

// ResetEtag resets all changes to the "etag" field.
func (m *EntityMutation) ResetEtag() {
	m.etag = nil
	delete(m.clearedFields, entity.FieldEtag)
}

// SetMimeType sets the "mime_type" field.
func (m *EntityMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *EntityMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldMimeType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *EntityMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[entity.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *EntityMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[entity.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *EntityMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, entity.FieldMimeType)
}

// SetDimension sets the "dimension" field.
func (m *EntityMutation) SetDimension(s string) {
	m.dimension = &s
}

// Dimension returns the value of the "dimension" field in the mutation.
func (m *EntityMutation) Dimension() (r string, exists bool) {
	v := m.dimension
	if v == nil {
		return
	}
	return *v, true
}

// OldDimension returns the old "dimension" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldDimension(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimension: %w", err)
	}
	return oldValue.Dimension, nil
}

// ClearDimension clears the value of the "dimension" field.
func (m *EntityMutation) ClearDimension() {
	m.dimension = nil
	m.clearedFields[entity.FieldDimension] = struct{}{}
}

// DimensionCleared returns if the "dimension" field was cleared in this mutation.
func (m *EntityMutation) DimensionCleared() bool {
	_, ok := m.clearedFields[entity.FieldDimension]
	return ok
}

// ResetDimension resets all changes to the "dimension" field.
func (m *EntityMutation) ResetDimension() {
	m.dimension = nil
	delete(m.clearedFields, entity.FieldDimension)
}

// SetStorageMetadata sets the "storage_metadata" field.
func (m *EntityMutation) SetStorageMetadata(mm model.JSONMap) {
	m.storage_metadata = &mm
}

// StorageMetadata returns the value of the "storage_metadata" field in the mutation.
func (m *EntityMutation) StorageMetadata() (r model.JSONMap, exists bool) {
	v := m.storage_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageMetadata returns the old "storage_metadata" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldStorageMetadata(ctx context.Context) (v model.JSONMap, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageMetadata: %w", err)
	}
	return oldValue.StorageMetadata, nil
}

// ClearStorageMetadata clears the value of the "storage_metadata" field.
func (m *EntityMutation) ClearStorageMetadata() {
	m.storage_metadata = nil
	m.clearedFields[entity.FieldStorageMetadata] = struct{}{}
}

// StorageMetadataCleared returns if the "storage_metadata" field was cleared in this mutation.
func (m *EntityMutation) StorageMetadataCleared() bool {
	_, ok := m.clearedFields[entity.FieldStorageMetadata]
	return ok
}

// ResetStorageMetadata resets all changes to the "storage_metadata" field.
func (m *EntityMutation) ResetStorageMetadata() {
	m.storage_metadata = nil
	delete(m.clearedFields, entity.FieldStorageMetadata)
}

// AddFileVersionIDs adds the "file_versions" edge to the FileEntity entity by ids.
func (m *EntityMutation) AddFileVersionIDs(ids ...uint) {
	if m.file_versions == nil {
		m.file_versions = make(map[uint]struct{})
	}
	for i := range ids {
		m.file_versions[ids[i]] = struct{}{}
	}
}

// ClearFileVersions clears the "file_versions" edge to the FileEntity entity.
func (m *EntityMutation) ClearFileVersions() {
	m.clearedfile_versions = true
}

// FileVersionsCleared reports if the "file_versions" edge to the FileEntity entity was cleared.
func (m *EntityMutation) FileVersionsCleared() bool {
	return m.clearedfile_versions
}

// RemoveFileVersionIDs removes the "file_versions" edge to the FileEntity entity by IDs.
func (m *EntityMutation) RemoveFileVersionIDs(ids ...uint) {
	if m.removedfile_versions == nil {
		m.removedfile_versions = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.file_versions, ids[i])
		m.removedfile_versions[ids[i]] = struct{}{}
	}
}

// RemovedFileVersions returns the removed IDs of the "file_versions" edge to the FileEntity entity.
func (m *EntityMutation) RemovedFileVersionsIDs() (ids []uint) {
	for id := range m.removedfile_versions {
		ids = append(ids, id)
	}
	return
}

// FileVersionsIDs returns the "file_versions" edge IDs in the mutation.
func (m *EntityMutation) FileVersionsIDs() (ids []uint) {
	for id := range m.file_versions {
		ids = append(ids, id)
	}
	return
}

// ResetFileVersions resets all changes to the "file_versions" edge.
func (m *EntityMutation) ResetFileVersions() {
	m.file_versions = nil
	m.clearedfile_versions = false
	m.removedfile_versions = nil
}

// Where appends a list predicates to the EntityMutation builder.
func (m *EntityMutation) Where(ps ...predicate.Entity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entity).
func (m *EntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, entity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entity.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, entity.FieldType)
	}
	if m.source != nil {
		fields = append(fields, entity.FieldSource)
	}
	if m.size != nil {
		fields = append(fields, entity.FieldSize)
	}
	if m.upload_session_id != nil {
		fields = append(fields, entity.FieldUploadSessionID)
	}
	if m.recycle_options != nil {
		fields = append(fields, entity.FieldRecycleOptions)
	}
	if m.policy_id != nil {
		fields = append(fields, entity.FieldPolicyID)
	}
	if m.created_by != nil {
		fields = append(fields, entity.FieldCreatedBy)
	}
	if m.etag != nil {
		fields = append(fields, entity.FieldEtag)
	}
	if m.mime_type != nil {
		fields = append(fields, entity.FieldMimeType)
	}
	if m.dimension != nil {
		fields = append(fields, entity.FieldDimension)
	}
	if m.storage_metadata != nil {
		fields = append(fields, entity.FieldStorageMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entity.FieldCreatedAt:
		return m.CreatedAt()
	case entity.FieldUpdatedAt:
		return m.UpdatedAt()
	case entity.FieldType:
		return m.GetType()
	case entity.FieldSource:
		return m.Source()
	case entity.FieldSize:
		return m.Size()
	case entity.FieldUploadSessionID:
		return m.UploadSessionID()
	case entity.FieldRecycleOptions:
		return m.RecycleOptions()
	case entity.FieldPolicyID:
		return m.PolicyID()
	case entity.FieldCreatedBy:
		return m.CreatedBy()
	case entity.FieldEtag:
		return m.Etag()
	case entity.FieldMimeType:
		return m.MimeType()
	case entity.FieldDimension:
		return m.Dimension()
	case entity.FieldStorageMetadata:
		return m.StorageMetadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entity.FieldType:
		return m.OldType(ctx)
	case entity.FieldSource:
		return m.OldSource(ctx)
	case entity.FieldSize:
		return m.OldSize(ctx)
	case entity.FieldUploadSessionID:
		return m.OldUploadSessionID(ctx)
	case entity.FieldRecycleOptions:
		return m.OldRecycleOptions(ctx)
	case entity.FieldPolicyID:
		return m.OldPolicyID(ctx)
	case entity.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entity.FieldEtag:
		return m.OldEtag(ctx)
	case entity.FieldMimeType:
		return m.OldMimeType(ctx)
	case entity.FieldDimension:
		return m.OldDimension(ctx)
	case entity.FieldStorageMetadata:
		return m.OldStorageMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Entity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entity.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case entity.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case entity.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case entity.FieldUploadSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadSessionID(v)
		return nil
	case entity.FieldRecycleOptions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecycleOptions(v)
		return nil
	case entity.FieldPolicyID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicyID(v)
		return nil
	case entity.FieldCreatedBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entity.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case entity.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case entity.FieldDimension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimension(v)
		return nil
	case entity.FieldStorageMetadata:
		v, ok := value.(model.JSONMap)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, entity.FieldSize)
	}
	if m.addpolicy_id != nil {
		fields = append(fields, entity.FieldPolicyID)
	}
	if m.addcreated_by != nil {
		fields = append(fields, entity.FieldCreatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entity.FieldSize:
		return m.AddedSize()
	case entity.FieldPolicyID:
		return m.AddedPolicyID()
	case entity.FieldCreatedBy:
		return m.AddedCreatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entity.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case entity.FieldPolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPolicyID(v)
		return nil
	case entity.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Entity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entity.FieldSource) {
		fields = append(fields, entity.FieldSource)
	}
	if m.FieldCleared(entity.FieldUploadSessionID) {
		fields = append(fields, entity.FieldUploadSessionID)
	}
	if m.FieldCleared(entity.FieldRecycleOptions) {
		fields = append(fields, entity.FieldRecycleOptions)
	}
	if m.FieldCleared(entity.FieldCreatedBy) {
		fields = append(fields, entity.FieldCreatedBy)
	}
	if m.FieldCleared(entity.FieldEtag) {
		fields = append(fields, entity.FieldEtag)
	}
	if m.FieldCleared(entity.FieldMimeType) {
		fields = append(fields, entity.FieldMimeType)
	}
	if m.FieldCleared(entity.FieldDimension) {
		fields = append(fields, entity.FieldDimension)
	}
	if m.FieldCleared(entity.FieldStorageMetadata) {
		fields = append(fields, entity.FieldStorageMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityMutation) ClearField(name string) error {
	switch name {
	case entity.FieldSource:
		m.ClearSource()
		return nil
	case entity.FieldUploadSessionID:
		m.ClearUploadSessionID()
		return nil
	case entity.FieldRecycleOptions:
		m.ClearRecycleOptions()
		return nil
	case entity.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entity.FieldEtag:
		m.ClearEtag()
		return nil
	case entity.FieldMimeType:
		m.ClearMimeType()
		return nil
	case entity.FieldDimension:
		m.ClearDimension()
		return nil
	case entity.FieldStorageMetadata:
		m.ClearStorageMetadata()
		return nil
	}
	return fmt.Errorf("unknown Entity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityMutation) ResetField(name string) error {
	switch name {
	case entity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entity.FieldType:
		m.ResetType()
		return nil
	case entity.FieldSource:
		m.ResetSource()
		return nil
	case entity.FieldSize:
		m.ResetSize()
		return nil
	case entity.FieldUploadSessionID:
		m.ResetUploadSessionID()
		return nil
	case entity.FieldRecycleOptions:
		m.ResetRecycleOptions()
		return nil
	case entity.FieldPolicyID:
		m.ResetPolicyID()
		return nil
	case entity.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entity.FieldEtag:
		m.ResetEtag()
		return nil
	case entity.FieldMimeType:
		m.ResetMimeType()
		return nil
	case entity.FieldDimension:
		m.ResetDimension()
		return nil
	case entity.FieldStorageMetadata:
		m.ResetStorageMetadata()
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file_versions != nil {
		edges = append(edges, entity.EdgeFileVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeFileVersions:
		ids := make([]ent.Value, 0, len(m.file_versions))
		for id := range m.file_versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfile_versions != nil {
		edges = append(edges, entity.EdgeFileVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeFileVersions:
		ids := make([]ent.Value, 0, len(m.removedfile_versions))
		for id := range m.removedfile_versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile_versions {
		edges = append(edges, entity.EdgeFileVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityMutation) EdgeCleared(name string) bool {
	switch name {
	case entity.EdgeFileVersions:
		return m.clearedfile_versions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Entity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityMutation) ResetEdge(name string) error {
	switch name {
	case entity.EdgeFileVersions:
		m.ResetFileVersions()
		return nil
	}
	return fmt.Errorf("unknown Entity edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint
	deleted_at            *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	_type                 *int
	add_type              *int
	name                  *string
	size                  *int64
	addsize               *int64
	children_count        *int64
	addchildren_count     *int64
	view_config           *string
	clearedFields         map[string]struct{}
	owner                 *uint
	clearedowner          bool
	parent                *uint
	clearedparent         bool
	children              map[uint]struct{}
	removedchildren       map[uint]struct{}
	clearedchildren       bool
	primary_entity        *uint
	clearedprimary_entity bool
	versions              map[uint]struct{}
	removedversions       map[uint]struct{}
	clearedversions       bool
	direct_link           *uint
	cleareddirect_link    bool
	metadata              map[uint]struct{}
	removedmetadata       map[uint]struct{}
	clearedmetadata       bool
	done                  bool
	oldValue              func(context.Context) (*File, error)
	predicates            []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id uint) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[file.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, file.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *FileMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *FileMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *FileMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *FileMutation) SetOwnerID(u uint) {
	m.owner = &u
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *FileMutation) OwnerID() (r uint, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldOwnerID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *FileMutation) ResetOwnerID() {
	m.owner = nil
}

// SetParentID sets the "parent_id" field.
func (m *FileMutation) SetParentID(u uint) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *FileMutation) ParentID() (r uint, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldParentID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *FileMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[file.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *FileMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[file.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *FileMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, file.FieldParentID)
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetPrimaryEntityID sets the "primary_entity_id" field.
func (m *FileMutation) SetPrimaryEntityID(u uint) {
	m.primary_entity = &u
}

// PrimaryEntityID returns the value of the "primary_entity_id" field in the mutation.
func (m *FileMutation) PrimaryEntityID() (r uint, exists bool) {
	v := m.primary_entity
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryEntityID returns the old "primary_entity_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPrimaryEntityID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryEntityID: %w", err)
	}
	return oldValue.PrimaryEntityID, nil
}

// ClearPrimaryEntityID clears the value of the "primary_entity_id" field.
func (m *FileMutation) ClearPrimaryEntityID() {
	m.primary_entity = nil
	m.clearedFields[file.FieldPrimaryEntityID] = struct{}{}
}

// PrimaryEntityIDCleared returns if the "primary_entity_id" field was cleared in this mutation.
func (m *FileMutation) PrimaryEntityIDCleared() bool {
	_, ok := m.clearedFields[file.FieldPrimaryEntityID]
	return ok
}

// ResetPrimaryEntityID resets all changes to the "primary_entity_id" field.
func (m *FileMutation) ResetPrimaryEntityID() {
	m.primary_entity = nil
	delete(m.clearedFields, file.FieldPrimaryEntityID)
}

// SetChildrenCount sets the "children_count" field.
func (m *FileMutation) SetChildrenCount(i int64) {
	m.children_count = &i
	m.addchildren_count = nil
}

// ChildrenCount returns the value of the "children_count" field in the mutation.
func (m *FileMutation) ChildrenCount() (r int64, exists bool) {
	v := m.children_count
	if v == nil {
		return
	}
	return *v, true
}

// OldChildrenCount returns the old "children_count" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldChildrenCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildrenCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildrenCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildrenCount: %w", err)
	}
	return oldValue.ChildrenCount, nil
}

// AddChildrenCount adds i to the "children_count" field.
func (m *FileMutation) AddChildrenCount(i int64) {
	if m.addchildren_count != nil {
		*m.addchildren_count += i
	} else {
		m.addchildren_count = &i
	}
}

// AddedChildrenCount returns the value that was added to the "children_count" field in this mutation.
func (m *FileMutation) AddedChildrenCount() (r int64, exists bool) {
	v := m.addchildren_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetChildrenCount resets all changes to the "children_count" field.
func (m *FileMutation) ResetChildrenCount() {
	m.children_count = nil
	m.addchildren_count = nil
}

// SetViewConfig sets the "view_config" field.
func (m *FileMutation) SetViewConfig(s string) {
	m.view_config = &s
}

// ViewConfig returns the value of the "view_config" field in the mutation.
func (m *FileMutation) ViewConfig() (r string, exists bool) {
	v := m.view_config
	if v == nil {
		return
	}
	return *v, true
}

// OldViewConfig returns the old "view_config" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldViewConfig(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewConfig: %w", err)
	}
	return oldValue.ViewConfig, nil
}

// ClearViewConfig clears the value of the "view_config" field.
func (m *FileMutation) ClearViewConfig() {
	m.view_config = nil
	m.clearedFields[file.FieldViewConfig] = struct{}{}
}

// ViewConfigCleared returns if the "view_config" field was cleared in this mutation.
func (m *FileMutation) ViewConfigCleared() bool {
	_, ok := m.clearedFields[file.FieldViewConfig]
	return ok
}

// ResetViewConfig resets all changes to the "view_config" field.
func (m *FileMutation) ResetViewConfig() {
	m.view_config = nil
	delete(m.clearedFields, file.FieldViewConfig)
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FileMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[file.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FileMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FileMutation) OwnerIDs() (ids []uint) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FileMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// ClearParent clears the "parent" edge to the File entity.
func (m *FileMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[file.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the File entity was cleared.
func (m *FileMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FileMutation) ParentIDs() (ids []uint) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FileMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the File entity by ids.
func (m *FileMutation) AddChildIDs(ids ...uint) {
	if m.children == nil {
		m.children = make(map[uint]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the File entity.
func (m *FileMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the File entity was cleared.
func (m *FileMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the File entity by IDs.
func (m *FileMutation) RemoveChildIDs(ids ...uint) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the File entity.
func (m *FileMutation) RemovedChildrenIDs() (ids []uint) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *FileMutation) ChildrenIDs() (ids []uint) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *FileMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearPrimaryEntity clears the "primary_entity" edge to the Entity entity.
func (m *FileMutation) ClearPrimaryEntity() {
	m.clearedprimary_entity = true
	m.clearedFields[file.FieldPrimaryEntityID] = struct{}{}
}

// PrimaryEntityCleared reports if the "primary_entity" edge to the Entity entity was cleared.
func (m *FileMutation) PrimaryEntityCleared() bool {
	return m.PrimaryEntityIDCleared() || m.clearedprimary_entity
}

// PrimaryEntityIDs returns the "primary_entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryEntityID instead. It exists only for internal usage by the builders.
func (m *FileMutation) PrimaryEntityIDs() (ids []uint) {
	if id := m.primary_entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryEntity resets all changes to the "primary_entity" edge.
func (m *FileMutation) ResetPrimaryEntity() {
	m.primary_entity = nil
	m.clearedprimary_entity = false
}

// AddVersionIDs adds the "versions" edge to the FileEntity entity by ids.
func (m *FileMutation) AddVersionIDs(ids ...uint) {
	if m.versions == nil {
		m.versions = make(map[uint]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the FileEntity entity.
func (m *FileMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the FileEntity entity was cleared.
func (m *FileMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the FileEntity entity by IDs.
func (m *FileMutation) RemoveVersionIDs(ids ...uint) {
	if m.removedversions == nil {
		m.removedversions = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the FileEntity entity.
func (m *FileMutation) RemovedVersionsIDs() (ids []uint) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *FileMutation) VersionsIDs() (ids []uint) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *FileMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// SetDirectLinkID sets the "direct_link" edge to the DirectLink entity by id.
func (m *FileMutation) SetDirectLinkID(id uint) {
	m.direct_link = &id
}

// ClearDirectLink clears the "direct_link" edge to the DirectLink entity.
func (m *FileMutation) ClearDirectLink() {
	m.cleareddirect_link = true
}

// DirectLinkCleared reports if the "direct_link" edge to the DirectLink entity was cleared.
func (m *FileMutation) DirectLinkCleared() bool {
	return m.cleareddirect_link
}

// DirectLinkID returns the "direct_link" edge ID in the mutation.
func (m *FileMutation) DirectLinkID() (id uint, exists bool) {
	if m.direct_link != nil {
		return *m.direct_link, true
	}
	return
}

// DirectLinkIDs returns the "direct_link" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DirectLinkID instead. It exists only for internal usage by the builders.
func (m *FileMutation) DirectLinkIDs() (ids []uint) {
	if id := m.direct_link; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDirectLink resets all changes to the "direct_link" edge.
func (m *FileMutation) ResetDirectLink() {
	m.direct_link = nil
	m.cleareddirect_link = false
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *FileMutation) AddMetadatumIDs(ids ...uint) {
	if m.metadata == nil {
		m.metadata = make(map[uint]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *FileMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *FileMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *FileMutation) RemoveMetadatumIDs(ids ...uint) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *FileMutation) RemovedMetadataIDs() (ids []uint) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *FileMutation) MetadataIDs() (ids []uint) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *FileMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.deleted_at != nil {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.owner != nil {
		fields = append(fields, file.FieldOwnerID)
	}
	if m.parent != nil {
		fields = append(fields, file.FieldParentID)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.primary_entity != nil {
		fields = append(fields, file.FieldPrimaryEntityID)
	}
	if m.children_count != nil {
		fields = append(fields, file.FieldChildrenCount)
	}
	if m.view_config != nil {
		fields = append(fields, file.FieldViewConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldDeletedAt:
		return m.DeletedAt()
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldType:
		return m.GetType()
	case file.FieldOwnerID:
		return m.OwnerID()
	case file.FieldParentID:
		return m.ParentID()
	case file.FieldName:
		return m.Name()
	case file.FieldSize:
		return m.Size()
	case file.FieldPrimaryEntityID:
		return m.PrimaryEntityID()
	case file.FieldChildrenCount:
		return m.ChildrenCount()
	case file.FieldViewConfig:
		return m.ViewConfig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case file.FieldParentID:
		return m.OldParentID(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldPrimaryEntityID:
		return m.OldPrimaryEntityID(ctx)
	case file.FieldChildrenCount:
		return m.OldChildrenCount(ctx)
	case file.FieldViewConfig:
		return m.OldViewConfig(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldOwnerID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case file.FieldParentID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldPrimaryEntityID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryEntityID(v)
		return nil
	case file.FieldChildrenCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildrenCount(v)
		return nil
	case file.FieldViewConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewConfig(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.addchildren_count != nil {
		fields = append(fields, file.FieldChildrenCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldType:
		return m.AddedType()
	case file.FieldSize:
		return m.AddedSize()
	case file.FieldChildrenCount:
		return m.AddedChildrenCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case file.FieldChildrenCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChildrenCount(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldDeletedAt) {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.FieldCleared(file.FieldParentID) {
		fields = append(fields, file.FieldParentID)
	}
	if m.FieldCleared(file.FieldPrimaryEntityID) {
		fields = append(fields, file.FieldPrimaryEntityID)
	}
	if m.FieldCleared(file.FieldViewConfig) {
		fields = append(fields, file.FieldViewConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case file.FieldParentID:
		m.ClearParentID()
		return nil
	case file.FieldPrimaryEntityID:
		m.ClearPrimaryEntityID()
		return nil
	case file.FieldViewConfig:
		m.ClearViewConfig()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case file.FieldParentID:
		m.ResetParentID()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldPrimaryEntityID:
		m.ResetPrimaryEntityID()
		return nil
	case file.FieldChildrenCount:
		m.ResetChildrenCount()
		return nil
	case file.FieldViewConfig:
		m.ResetViewConfig()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.owner != nil {
		edges = append(edges, file.EdgeOwner)
	}
	if m.parent != nil {
		edges = append(edges, file.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, file.EdgeChildren)
	}
	if m.primary_entity != nil {
		edges = append(edges, file.EdgePrimaryEntity)
	}
	if m.versions != nil {
		edges = append(edges, file.EdgeVersions)
	}
	if m.direct_link != nil {
		edges = append(edges, file.EdgeDirectLink)
	}
	if m.metadata != nil {
		edges = append(edges, file.EdgeMetadata)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case file.EdgePrimaryEntity:
		if id := m.primary_entity; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeDirectLink:
		if id := m.direct_link; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedchildren != nil {
		edges = append(edges, file.EdgeChildren)
	}
	if m.removedversions != nil {
		edges = append(edges, file.EdgeVersions)
	}
	if m.removedmetadata != nil {
		edges = append(edges, file.EdgeMetadata)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedowner {
		edges = append(edges, file.EdgeOwner)
	}
	if m.clearedparent {
		edges = append(edges, file.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, file.EdgeChildren)
	}
	if m.clearedprimary_entity {
		edges = append(edges, file.EdgePrimaryEntity)
	}
	if m.clearedversions {
		edges = append(edges, file.EdgeVersions)
	}
	if m.cleareddirect_link {
		edges = append(edges, file.EdgeDirectLink)
	}
	if m.clearedmetadata {
		edges = append(edges, file.EdgeMetadata)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeOwner:
		return m.clearedowner
	case file.EdgeParent:
		return m.clearedparent
	case file.EdgeChildren:
		return m.clearedchildren
	case file.EdgePrimaryEntity:
		return m.clearedprimary_entity
	case file.EdgeVersions:
		return m.clearedversions
	case file.EdgeDirectLink:
		return m.cleareddirect_link
	case file.EdgeMetadata:
		return m.clearedmetadata
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ClearOwner()
		return nil
	case file.EdgeParent:
		m.ClearParent()
		return nil
	case file.EdgePrimaryEntity:
		m.ClearPrimaryEntity()
		return nil
	case file.EdgeDirectLink:
		m.ClearDirectLink()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ResetOwner()
		return nil
	case file.EdgeParent:
		m.ResetParent()
		return nil
	case file.EdgeChildren:
		m.ResetChildren()
		return nil
	case file.EdgePrimaryEntity:
		m.ResetPrimaryEntity()
		return nil
	case file.EdgeVersions:
		m.ResetVersions()
		return nil
	case file.EdgeDirectLink:
		m.ResetDirectLink()
		return nil
	case file.EdgeMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// FileEntityMutation represents an operation that mutates the FileEntity nodes in the graph.
type FileEntityMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint
	deleted_at             *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	version                *string
	is_current             *bool
	uploaded_by_user_id    *uint64
	adduploaded_by_user_id *int64
	clearedFields          map[string]struct{}
	file                   *uint
	clearedfile            bool
	entity                 *uint
	clearedentity          bool
	done                   bool
	oldValue               func(context.Context) (*FileEntity, error)
	predicates             []predicate.FileEntity
}

var _ ent.Mutation = (*FileEntityMutation)(nil)

// fileentityOption allows management of the mutation configuration using functional options.
type fileentityOption func(*FileEntityMutation)

// newFileEntityMutation creates new mutation for the FileEntity entity.
func newFileEntityMutation(c config, op Op, opts ...fileentityOption) *FileEntityMutation {
	m := &FileEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeFileEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileEntityID sets the ID field of the mutation.
func withFileEntityID(id uint) fileentityOption {
	return func(m *FileEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *FileEntity
		)
		m.oldValue = func(ctx context.Context) (*FileEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileEntity sets the old FileEntity of the mutation.
func withFileEntity(node *FileEntity) fileentityOption {
	return func(m *FileEntityMutation) {
		m.oldValue = func(context.Context) (*FileEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileEntity entities.
func (m *FileEntityMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileEntityMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileEntityMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileEntityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileEntityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileEntityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[fileentity.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileEntityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[fileentity.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileEntityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, fileentity.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *FileEntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileEntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileEntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileEntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileEntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileEntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFileID sets the "file_id" field.
func (m *FileEntityMutation) SetFileID(u uint) {
	m.file = &u
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *FileEntityMutation) FileID() (r uint, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldFileID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *FileEntityMutation) ResetFileID() {
	m.file = nil
}

// SetEntityID sets the "entity_id" field.
func (m *FileEntityMutation) SetEntityID(u uint) {
	m.entity = &u
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *FileEntityMutation) EntityID() (r uint, exists bool) {
	v := m.entity
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldEntityID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *FileEntityMutation) ResetEntityID() {
	m.entity = nil
}

// SetVersion sets the "version" field.
func (m *FileEntityMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *FileEntityMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldVersion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *FileEntityMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[fileentity.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *FileEntityMutation) VersionCleared() bool {
	_, ok := m.clearedFields[fileentity.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *FileEntityMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, fileentity.FieldVersion)
}

// SetIsCurrent sets the "is_current" field.
func (m *FileEntityMutation) SetIsCurrent(b bool) {
	m.is_current = &b
}

// IsCurrent returns the value of the "is_current" field in the mutation.
func (m *FileEntityMutation) IsCurrent() (r bool, exists bool) {
	v := m.is_current
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCurrent returns the old "is_current" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldIsCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCurrent: %w", err)
	}
	return oldValue.IsCurrent, nil
}

// ResetIsCurrent resets all changes to the "is_current" field.
func (m *FileEntityMutation) ResetIsCurrent() {
	m.is_current = nil
}

// SetUploadedByUserID sets the "uploaded_by_user_id" field.
func (m *FileEntityMutation) SetUploadedByUserID(u uint64) {
	m.uploaded_by_user_id = &u
	m.adduploaded_by_user_id = nil
}

// UploadedByUserID returns the value of the "uploaded_by_user_id" field in the mutation.
func (m *FileEntityMutation) UploadedByUserID() (r uint64, exists bool) {
	v := m.uploaded_by_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedByUserID returns the old "uploaded_by_user_id" field's value of the FileEntity entity.
// If the FileEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileEntityMutation) OldUploadedByUserID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedByUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedByUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedByUserID: %w", err)
	}
	return oldValue.UploadedByUserID, nil
}

// AddUploadedByUserID adds u to the "uploaded_by_user_id" field.
func (m *FileEntityMutation) AddUploadedByUserID(u int64) {
	if m.adduploaded_by_user_id != nil {
		*m.adduploaded_by_user_id += u
	} else {
		m.adduploaded_by_user_id = &u
	}
}

// AddedUploadedByUserID returns the value that was added to the "uploaded_by_user_id" field in this mutation.
func (m *FileEntityMutation) AddedUploadedByUserID() (r int64, exists bool) {
	v := m.adduploaded_by_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUploadedByUserID clears the value of the "uploaded_by_user_id" field.
func (m *FileEntityMutation) ClearUploadedByUserID() {
	m.uploaded_by_user_id = nil
	m.adduploaded_by_user_id = nil
	m.clearedFields[fileentity.FieldUploadedByUserID] = struct{}{}
}

// UploadedByUserIDCleared returns if the "uploaded_by_user_id" field was cleared in this mutation.
func (m *FileEntityMutation) UploadedByUserIDCleared() bool {
	_, ok := m.clearedFields[fileentity.FieldUploadedByUserID]
	return ok
}

// ResetUploadedByUserID resets all changes to the "uploaded_by_user_id" field.
func (m *FileEntityMutation) ResetUploadedByUserID() {
	m.uploaded_by_user_id = nil
	m.adduploaded_by_user_id = nil
	delete(m.clearedFields, fileentity.FieldUploadedByUserID)
}

// ClearFile clears the "file" edge to the File entity.
func (m *FileEntityMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[fileentity.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *FileEntityMutation) FileCleared() bool {
	return m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *FileEntityMutation) FileIDs() (ids []uint) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *FileEntityMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *FileEntityMutation) ClearEntity() {
	m.clearedentity = true
	m.clearedFields[fileentity.FieldEntityID] = struct{}{}
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *FileEntityMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *FileEntityMutation) EntityIDs() (ids []uint) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *FileEntityMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// Where appends a list predicates to the FileEntityMutation builder.
func (m *FileEntityMutation) Where(ps ...predicate.FileEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileEntity).
func (m *FileEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileEntityMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.deleted_at != nil {
		fields = append(fields, fileentity.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, fileentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fileentity.FieldUpdatedAt)
	}
	if m.file != nil {
		fields = append(fields, fileentity.FieldFileID)
	}
	if m.entity != nil {
		fields = append(fields, fileentity.FieldEntityID)
	}
	if m.version != nil {
		fields = append(fields, fileentity.FieldVersion)
	}
	if m.is_current != nil {
		fields = append(fields, fileentity.FieldIsCurrent)
	}
	if m.uploaded_by_user_id != nil {
		fields = append(fields, fileentity.FieldUploadedByUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fileentity.FieldDeletedAt:
		return m.DeletedAt()
	case fileentity.FieldCreatedAt:
		return m.CreatedAt()
	case fileentity.FieldUpdatedAt:
		return m.UpdatedAt()
	case fileentity.FieldFileID:
		return m.FileID()
	case fileentity.FieldEntityID:
		return m.EntityID()
	case fileentity.FieldVersion:
		return m.Version()
	case fileentity.FieldIsCurrent:
		return m.IsCurrent()
	case fileentity.FieldUploadedByUserID:
		return m.UploadedByUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fileentity.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case fileentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fileentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fileentity.FieldFileID:
		return m.OldFileID(ctx)
	case fileentity.FieldEntityID:
		return m.OldEntityID(ctx)
	case fileentity.FieldVersion:
		return m.OldVersion(ctx)
	case fileentity.FieldIsCurrent:
		return m.OldIsCurrent(ctx)
	case fileentity.FieldUploadedByUserID:
		return m.OldUploadedByUserID(ctx)
	}
	return nil, fmt.Errorf("unknown FileEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fileentity.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case fileentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fileentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fileentity.FieldFileID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case fileentity.FieldEntityID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case fileentity.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case fileentity.FieldIsCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCurrent(v)
		return nil
	case fileentity.FieldUploadedByUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedByUserID(v)
		return nil
	}
	return fmt.Errorf("unknown FileEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileEntityMutation) AddedFields() []string {
	var fields []string
	if m.adduploaded_by_user_id != nil {
		fields = append(fields, fileentity.FieldUploadedByUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileEntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fileentity.FieldUploadedByUserID:
		return m.AddedUploadedByUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fileentity.FieldUploadedByUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUploadedByUserID(v)
		return nil
	}
	return fmt.Errorf("unknown FileEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileEntityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fileentity.FieldDeletedAt) {
		fields = append(fields, fileentity.FieldDeletedAt)
	}
	if m.FieldCleared(fileentity.FieldVersion) {
		fields = append(fields, fileentity.FieldVersion)
	}
	if m.FieldCleared(fileentity.FieldUploadedByUserID) {
		fields = append(fields, fileentity.FieldUploadedByUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileEntityMutation) ClearField(name string) error {
	switch name {
	case fileentity.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case fileentity.FieldVersion:
		m.ClearVersion()
		return nil
	case fileentity.FieldUploadedByUserID:
		m.ClearUploadedByUserID()
		return nil
	}
	return fmt.Errorf("unknown FileEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileEntityMutation) ResetField(name string) error {
	switch name {
	case fileentity.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case fileentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fileentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fileentity.FieldFileID:
		m.ResetFileID()
		return nil
	case fileentity.FieldEntityID:
		m.ResetEntityID()
		return nil
	case fileentity.FieldVersion:
		m.ResetVersion()
		return nil
	case fileentity.FieldIsCurrent:
		m.ResetIsCurrent()
		return nil
	case fileentity.FieldUploadedByUserID:
		m.ResetUploadedByUserID()
		return nil
	}
	return fmt.Errorf("unknown FileEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.file != nil {
		edges = append(edges, fileentity.EdgeFile)
	}
	if m.entity != nil {
		edges = append(edges, fileentity.EdgeEntity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileEntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fileentity.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case fileentity.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileEntityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfile {
		edges = append(edges, fileentity.EdgeFile)
	}
	if m.clearedentity {
		edges = append(edges, fileentity.EdgeEntity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileEntityMutation) EdgeCleared(name string) bool {
	switch name {
	case fileentity.EdgeFile:
		return m.clearedfile
	case fileentity.EdgeEntity:
		return m.clearedentity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileEntityMutation) ClearEdge(name string) error {
	switch name {
	case fileentity.EdgeFile:
		m.ClearFile()
		return nil
	case fileentity.EdgeEntity:
		m.ClearEntity()
		return nil
	}
	return fmt.Errorf("unknown FileEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileEntityMutation) ResetEdge(name string) error {
	switch name {
	case fileentity.EdgeFile:
		m.ResetFile()
		return nil
	case fileentity.EdgeEntity:
		m.ResetEntity()
		return nil
	}
	return fmt.Errorf("unknown FileEntity edge %s", name)
}

// LinkMutation represents an operation that mutates the Link nodes in the graph.
type LinkMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	url               *string
	logo              *string
	description       *string
	status            *link.Status
	siteshot          *string
	sort_order        *int
	addsort_order     *int
	skip_health_check *bool
	clearedFields     map[string]struct{}
	category          *int
	clearedcategory   bool
	tags              map[int]struct{}
	removedtags       map[int]struct{}
	clearedtags       bool
	done              bool
	oldValue          func(context.Context) (*Link, error)
	predicates        []predicate.Link
}

var _ ent.Mutation = (*LinkMutation)(nil)

// linkOption allows management of the mutation configuration using functional options.
type linkOption func(*LinkMutation)

// newLinkMutation creates new mutation for the Link entity.
func newLinkMutation(c config, op Op, opts ...linkOption) *LinkMutation {
	m := &LinkMutation{
		config:        c,
		op:            op,
		typ:           TypeLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkID sets the ID field of the mutation.
func withLinkID(id int) linkOption {
	return func(m *LinkMutation) {
		var (
			err   error
			once  sync.Once
			value *Link
		)
		m.oldValue = func(ctx context.Context) (*Link, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Link.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLink sets the old Link of the mutation.
func withLink(node *Link) linkOption {
	return func(m *LinkMutation) {
		m.oldValue = func(context.Context) (*Link, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Link.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LinkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LinkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LinkMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *LinkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *LinkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *LinkMutation) ResetURL() {
	m.url = nil
}

// SetLogo sets the "logo" field.
func (m *LinkMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *LinkMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *LinkMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[link.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *LinkMutation) LogoCleared() bool {
	_, ok := m.clearedFields[link.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *LinkMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, link.FieldLogo)
}

// SetDescription sets the "description" field.
func (m *LinkMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LinkMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LinkMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[link.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LinkMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[link.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LinkMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, link.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *LinkMutation) SetStatus(l link.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LinkMutation) Status() (r link.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldStatus(ctx context.Context) (v link.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LinkMutation) ResetStatus() {
	m.status = nil
}

// SetSiteshot sets the "siteshot" field.
func (m *LinkMutation) SetSiteshot(s string) {
	m.siteshot = &s
}

// Siteshot returns the value of the "siteshot" field in the mutation.
func (m *LinkMutation) Siteshot() (r string, exists bool) {
	v := m.siteshot
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteshot returns the old "siteshot" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldSiteshot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteshot: %w", err)
	}
	return oldValue.Siteshot, nil
}

// ClearSiteshot clears the value of the "siteshot" field.
func (m *LinkMutation) ClearSiteshot() {
	m.siteshot = nil
	m.clearedFields[link.FieldSiteshot] = struct{}{}
}

// SiteshotCleared returns if the "siteshot" field was cleared in this mutation.
func (m *LinkMutation) SiteshotCleared() bool {
	_, ok := m.clearedFields[link.FieldSiteshot]
	return ok
}

// ResetSiteshot resets all changes to the "siteshot" field.
func (m *LinkMutation) ResetSiteshot() {
	m.siteshot = nil
	delete(m.clearedFields, link.FieldSiteshot)
}

// SetSortOrder sets the "sort_order" field.
func (m *LinkMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *LinkMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *LinkMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *LinkMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *LinkMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetSkipHealthCheck sets the "skip_health_check" field.
func (m *LinkMutation) SetSkipHealthCheck(b bool) {
	m.skip_health_check = &b
}

// SkipHealthCheck returns the value of the "skip_health_check" field in the mutation.
func (m *LinkMutation) SkipHealthCheck() (r bool, exists bool) {
	v := m.skip_health_check
	if v == nil {
		return
	}
	return *v, true
}

// OldSkipHealthCheck returns the old "skip_health_check" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldSkipHealthCheck(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkipHealthCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkipHealthCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkipHealthCheck: %w", err)
	}
	return oldValue.SkipHealthCheck, nil
}

// ResetSkipHealthCheck resets all changes to the "skip_health_check" field.
func (m *LinkMutation) ResetSkipHealthCheck() {
	m.skip_health_check = nil
}

// SetCategoryID sets the "category" edge to the LinkCategory entity by id.
func (m *LinkMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the LinkCategory entity.
func (m *LinkMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the LinkCategory entity was cleared.
func (m *LinkMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *LinkMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *LinkMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *LinkMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddTagIDs adds the "tags" edge to the LinkTag entity by ids.
func (m *LinkMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the LinkTag entity.
func (m *LinkMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the LinkTag entity was cleared.
func (m *LinkMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the LinkTag entity by IDs.
func (m *LinkMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the LinkTag entity.
func (m *LinkMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *LinkMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *LinkMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the LinkMutation builder.
func (m *LinkMutation) Where(ps ...predicate.Link) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Link, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Link).
func (m *LinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, link.FieldName)
	}
	if m.url != nil {
		fields = append(fields, link.FieldURL)
	}
	if m.logo != nil {
		fields = append(fields, link.FieldLogo)
	}
	if m.description != nil {
		fields = append(fields, link.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, link.FieldStatus)
	}
	if m.siteshot != nil {
		fields = append(fields, link.FieldSiteshot)
	}
	if m.sort_order != nil {
		fields = append(fields, link.FieldSortOrder)
	}
	if m.skip_health_check != nil {
		fields = append(fields, link.FieldSkipHealthCheck)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case link.FieldName:
		return m.Name()
	case link.FieldURL:
		return m.URL()
	case link.FieldLogo:
		return m.Logo()
	case link.FieldDescription:
		return m.Description()
	case link.FieldStatus:
		return m.Status()
	case link.FieldSiteshot:
		return m.Siteshot()
	case link.FieldSortOrder:
		return m.SortOrder()
	case link.FieldSkipHealthCheck:
		return m.SkipHealthCheck()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case link.FieldName:
		return m.OldName(ctx)
	case link.FieldURL:
		return m.OldURL(ctx)
	case link.FieldLogo:
		return m.OldLogo(ctx)
	case link.FieldDescription:
		return m.OldDescription(ctx)
	case link.FieldStatus:
		return m.OldStatus(ctx)
	case link.FieldSiteshot:
		return m.OldSiteshot(ctx)
	case link.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case link.FieldSkipHealthCheck:
		return m.OldSkipHealthCheck(ctx)
	}
	return nil, fmt.Errorf("unknown Link field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case link.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case link.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case link.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case link.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case link.FieldStatus:
		v, ok := value.(link.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case link.FieldSiteshot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteshot(v)
		return nil
	case link.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case link.FieldSkipHealthCheck:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkipHealthCheck(v)
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, link.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case link.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case link.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Link numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(link.FieldLogo) {
		fields = append(fields, link.FieldLogo)
	}
	if m.FieldCleared(link.FieldDescription) {
		fields = append(fields, link.FieldDescription)
	}
	if m.FieldCleared(link.FieldSiteshot) {
		fields = append(fields, link.FieldSiteshot)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkMutation) ClearField(name string) error {
	switch name {
	case link.FieldLogo:
		m.ClearLogo()
		return nil
	case link.FieldDescription:
		m.ClearDescription()
		return nil
	case link.FieldSiteshot:
		m.ClearSiteshot()
		return nil
	}
	return fmt.Errorf("unknown Link nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkMutation) ResetField(name string) error {
	switch name {
	case link.FieldName:
		m.ResetName()
		return nil
	case link.FieldURL:
		m.ResetURL()
		return nil
	case link.FieldLogo:
		m.ResetLogo()
		return nil
	case link.FieldDescription:
		m.ResetDescription()
		return nil
	case link.FieldStatus:
		m.ResetStatus()
		return nil
	case link.FieldSiteshot:
		m.ResetSiteshot()
		return nil
	case link.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case link.FieldSkipHealthCheck:
		m.ResetSkipHealthCheck()
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.category != nil {
		edges = append(edges, link.EdgeCategory)
	}
	if m.tags != nil {
		edges = append(edges, link.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case link.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case link.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtags != nil {
		edges = append(edges, link.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case link.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcategory {
		edges = append(edges, link.EdgeCategory)
	}
	if m.clearedtags {
		edges = append(edges, link.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkMutation) EdgeCleared(name string) bool {
	switch name {
	case link.EdgeCategory:
		return m.clearedcategory
	case link.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkMutation) ClearEdge(name string) error {
	switch name {
	case link.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Link unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkMutation) ResetEdge(name string) error {
	switch name {
	case link.EdgeCategory:
		m.ResetCategory()
		return nil
	case link.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Link edge %s", name)
}

// LinkCategoryMutation represents an operation that mutates the LinkCategory nodes in the graph.
type LinkCategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	style         *linkcategory.Style
	clearedFields map[string]struct{}
	links         map[int]struct{}
	removedlinks  map[int]struct{}
	clearedlinks  bool
	done          bool
	oldValue      func(context.Context) (*LinkCategory, error)
	predicates    []predicate.LinkCategory
}

var _ ent.Mutation = (*LinkCategoryMutation)(nil)

// linkcategoryOption allows management of the mutation configuration using functional options.
type linkcategoryOption func(*LinkCategoryMutation)

// newLinkCategoryMutation creates new mutation for the LinkCategory entity.
func newLinkCategoryMutation(c config, op Op, opts ...linkcategoryOption) *LinkCategoryMutation {
	m := &LinkCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeLinkCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkCategoryID sets the ID field of the mutation.
func withLinkCategoryID(id int) linkcategoryOption {
	return func(m *LinkCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *LinkCategory
		)
		m.oldValue = func(ctx context.Context) (*LinkCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LinkCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLinkCategory sets the old LinkCategory of the mutation.
func withLinkCategory(node *LinkCategory) linkcategoryOption {
	return func(m *LinkCategoryMutation) {
		m.oldValue = func(context.Context) (*LinkCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LinkCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LinkCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LinkCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the LinkCategory entity.
// If the LinkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LinkCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *LinkCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LinkCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LinkCategory entity.
// If the LinkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LinkCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[linkcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LinkCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[linkcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LinkCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, linkcategory.FieldDescription)
}

// SetStyle sets the "style" field.
func (m *LinkCategoryMutation) SetStyle(l linkcategory.Style) {
	m.style = &l
}

// Style returns the value of the "style" field in the mutation.
func (m *LinkCategoryMutation) Style() (r linkcategory.Style, exists bool) {
	v := m.style
	if v == nil {
		return
	}
	return *v, true
}

// OldStyle returns the old "style" field's value of the LinkCategory entity.
// If the LinkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkCategoryMutation) OldStyle(ctx context.Context) (v linkcategory.Style, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStyle: %w", err)
	}
	return oldValue.Style, nil
}

// ResetStyle resets all changes to the "style" field.
func (m *LinkCategoryMutation) ResetStyle() {
	m.style = nil
}

// AddLinkIDs adds the "links" edge to the Link entity by ids.
func (m *LinkCategoryMutation) AddLinkIDs(ids ...int) {
	if m.links == nil {
		m.links = make(map[int]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the "links" edge to the Link entity.
func (m *LinkCategoryMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared reports if the "links" edge to the Link entity was cleared.
func (m *LinkCategoryMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the "links" edge to the Link entity by IDs.
func (m *LinkCategoryMutation) RemoveLinkIDs(ids ...int) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.links, ids[i])
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed IDs of the "links" edge to the Link entity.
func (m *LinkCategoryMutation) RemovedLinksIDs() (ids []int) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the "links" edge IDs in the mutation.
func (m *LinkCategoryMutation) LinksIDs() (ids []int) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks resets all changes to the "links" edge.
func (m *LinkCategoryMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// Where appends a list predicates to the LinkCategoryMutation builder.
func (m *LinkCategoryMutation) Where(ps ...predicate.LinkCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LinkCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LinkCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LinkCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LinkCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LinkCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LinkCategory).
func (m *LinkCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, linkcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, linkcategory.FieldDescription)
	}
	if m.style != nil {
		fields = append(fields, linkcategory.FieldStyle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case linkcategory.FieldName:
		return m.Name()
	case linkcategory.FieldDescription:
		return m.Description()
	case linkcategory.FieldStyle:
		return m.Style()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case linkcategory.FieldName:
		return m.OldName(ctx)
	case linkcategory.FieldDescription:
		return m.OldDescription(ctx)
	case linkcategory.FieldStyle:
		return m.OldStyle(ctx)
	}
	return nil, fmt.Errorf("unknown LinkCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case linkcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case linkcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case linkcategory.FieldStyle:
		v, ok := value.(linkcategory.Style)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStyle(v)
		return nil
	}
	return fmt.Errorf("unknown LinkCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LinkCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(linkcategory.FieldDescription) {
		fields = append(fields, linkcategory.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkCategoryMutation) ClearField(name string) error {
	switch name {
	case linkcategory.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown LinkCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkCategoryMutation) ResetField(name string) error {
	switch name {
	case linkcategory.FieldName:
		m.ResetName()
		return nil
	case linkcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case linkcategory.FieldStyle:
		m.ResetStyle()
		return nil
	}
	return fmt.Errorf("unknown LinkCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.links != nil {
		edges = append(edges, linkcategory.EdgeLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case linkcategory.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlinks != nil {
		edges = append(edges, linkcategory.EdgeLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case linkcategory.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlinks {
		edges = append(edges, linkcategory.EdgeLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case linkcategory.EdgeLinks:
		return m.clearedlinks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LinkCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkCategoryMutation) ResetEdge(name string) error {
	switch name {
	case linkcategory.EdgeLinks:
		m.ResetLinks()
		return nil
	}
	return fmt.Errorf("unknown LinkCategory edge %s", name)
}

// LinkTagMutation represents an operation that mutates the LinkTag nodes in the graph.
type LinkTagMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	color         *string
	clearedFields map[string]struct{}
	links         map[int]struct{}
	removedlinks  map[int]struct{}
	clearedlinks  bool
	done          bool
	oldValue      func(context.Context) (*LinkTag, error)
	predicates    []predicate.LinkTag
}

var _ ent.Mutation = (*LinkTagMutation)(nil)

// linktagOption allows management of the mutation configuration using functional options.
type linktagOption func(*LinkTagMutation)

// newLinkTagMutation creates new mutation for the LinkTag entity.
func newLinkTagMutation(c config, op Op, opts ...linktagOption) *LinkTagMutation {
	m := &LinkTagMutation{
		config:        c,
		op:            op,
		typ:           TypeLinkTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkTagID sets the ID field of the mutation.
func withLinkTagID(id int) linktagOption {
	return func(m *LinkTagMutation) {
		var (
			err   error
			once  sync.Once
			value *LinkTag
		)
		m.oldValue = func(ctx context.Context) (*LinkTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LinkTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLinkTag sets the old LinkTag of the mutation.
func withLinkTag(node *LinkTag) linktagOption {
	return func(m *LinkTagMutation) {
		m.oldValue = func(context.Context) (*LinkTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkTagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LinkTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LinkTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LinkTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the LinkTag entity.
// If the LinkTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LinkTagMutation) ResetName() {
	m.name = nil
}

// SetColor sets the "color" field.
func (m *LinkTagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *LinkTagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the LinkTag entity.
// If the LinkTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkTagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *LinkTagMutation) ResetColor() {
	m.color = nil
}

// AddLinkIDs adds the "links" edge to the Link entity by ids.
func (m *LinkTagMutation) AddLinkIDs(ids ...int) {
	if m.links == nil {
		m.links = make(map[int]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the "links" edge to the Link entity.
func (m *LinkTagMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared reports if the "links" edge to the Link entity was cleared.
func (m *LinkTagMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the "links" edge to the Link entity by IDs.
func (m *LinkTagMutation) RemoveLinkIDs(ids ...int) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.links, ids[i])
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed IDs of the "links" edge to the Link entity.
func (m *LinkTagMutation) RemovedLinksIDs() (ids []int) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the "links" edge IDs in the mutation.
func (m *LinkTagMutation) LinksIDs() (ids []int) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks resets all changes to the "links" edge.
func (m *LinkTagMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// Where appends a list predicates to the LinkTagMutation builder.
func (m *LinkTagMutation) Where(ps ...predicate.LinkTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LinkTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LinkTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LinkTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LinkTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LinkTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LinkTag).
func (m *LinkTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, linktag.FieldName)
	}
	if m.color != nil {
		fields = append(fields, linktag.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case linktag.FieldName:
		return m.Name()
	case linktag.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case linktag.FieldName:
		return m.OldName(ctx)
	case linktag.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown LinkTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case linktag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case linktag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown LinkTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LinkTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LinkTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkTagMutation) ResetField(name string) error {
	switch name {
	case linktag.FieldName:
		m.ResetName()
		return nil
	case linktag.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown LinkTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.links != nil {
		edges = append(edges, linktag.EdgeLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case linktag.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlinks != nil {
		edges = append(edges, linktag.EdgeLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case linktag.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlinks {
		edges = append(edges, linktag.EdgeLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkTagMutation) EdgeCleared(name string) bool {
	switch name {
	case linktag.EdgeLinks:
		return m.clearedlinks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LinkTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkTagMutation) ResetEdge(name string) error {
	switch name {
	case linktag.EdgeLinks:
		m.ResetLinks()
		return nil
	}
	return fmt.Errorf("unknown LinkTag edge %s", name)
}

// MetadataMutation represents an operation that mutates the Metadata nodes in the graph.
type MetadataMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	deleted_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	value         *string
	clearedFields map[string]struct{}
	file          *uint
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*Metadata, error)
	predicates    []predicate.Metadata
}

var _ ent.Mutation = (*MetadataMutation)(nil)

// metadataOption allows management of the mutation configuration using functional options.
type metadataOption func(*MetadataMutation)

// newMetadataMutation creates new mutation for the Metadata entity.
func newMetadataMutation(c config, op Op, opts ...metadataOption) *MetadataMutation {
	m := &MetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataID sets the ID field of the mutation.
func withMetadataID(id uint) metadataOption {
	return func(m *MetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *Metadata
		)
		m.oldValue = func(ctx context.Context) (*Metadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadata sets the old Metadata of the mutation.
func withMetadata(node *Metadata) metadataOption {
	return func(m *MetadataMutation) {
		m.oldValue = func(context.Context) (*Metadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Metadata entities.
func (m *MetadataMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetadataMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetadataMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MetadataMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MetadataMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MetadataMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[metadata.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MetadataMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[metadata.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MetadataMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, metadata.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *MetadataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetadataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetadataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetadataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetadataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetadataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *MetadataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MetadataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MetadataMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *MetadataMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *MetadataMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *MetadataMutation) ClearValue() {
	m.value = nil
	m.clearedFields[metadata.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *MetadataMutation) ValueCleared() bool {
	_, ok := m.clearedFields[metadata.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *MetadataMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, metadata.FieldValue)
}

// SetFileID sets the "file_id" field.
func (m *MetadataMutation) SetFileID(u uint) {
	m.file = &u
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *MetadataMutation) FileID() (r uint, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldFileID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *MetadataMutation) ResetFileID() {
	m.file = nil
}

// ClearFile clears the "file" edge to the File entity.
func (m *MetadataMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[metadata.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *MetadataMutation) FileCleared() bool {
	return m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) FileIDs() (ids []uint) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *MetadataMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the MetadataMutation builder.
func (m *MetadataMutation) Where(ps ...predicate.Metadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Metadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Metadata).
func (m *MetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetadataMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, metadata.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, metadata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metadata.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, metadata.FieldName)
	}
	if m.value != nil {
		fields = append(fields, metadata.FieldValue)
	}
	if m.file != nil {
		fields = append(fields, metadata.FieldFileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadata.FieldDeletedAt:
		return m.DeletedAt()
	case metadata.FieldCreatedAt:
		return m.CreatedAt()
	case metadata.FieldUpdatedAt:
		return m.UpdatedAt()
	case metadata.FieldName:
		return m.Name()
	case metadata.FieldValue:
		return m.Value()
	case metadata.FieldFileID:
		return m.FileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadata.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case metadata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metadata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metadata.FieldName:
		return m.OldName(ctx)
	case metadata.FieldValue:
		return m.OldValue(ctx)
	case metadata.FieldFileID:
		return m.OldFileID(ctx)
	}
	return nil, fmt.Errorf("unknown Metadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadata.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case metadata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metadata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metadata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case metadata.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case metadata.FieldFileID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetadataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetadataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Metadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(metadata.FieldDeletedAt) {
		fields = append(fields, metadata.FieldDeletedAt)
	}
	if m.FieldCleared(metadata.FieldValue) {
		fields = append(fields, metadata.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataMutation) ClearField(name string) error {
	switch name {
	case metadata.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case metadata.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown Metadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetadataMutation) ResetField(name string) error {
	switch name {
	case metadata.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case metadata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metadata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metadata.FieldName:
		m.ResetName()
		return nil
	case metadata.FieldValue:
		m.ResetValue()
		return nil
	case metadata.FieldFileID:
		m.ResetFileID()
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, metadata.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metadata.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, metadata.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case metadata.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetadataMutation) ClearEdge(name string) error {
	switch name {
	case metadata.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Metadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetadataMutation) ResetEdge(name string) error {
	switch name {
	case metadata.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Metadata edge %s", name)
}

// PageMutation represents an operation that mutates the Page nodes in the graph.
type PageMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	deleted_at    *time.Time
	title         *string
	_path         *string
	content       *string
	description   *string
	is_published  *bool
	sort          *int
	addsort       *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Page, error)
	predicates    []predicate.Page
}

var _ ent.Mutation = (*PageMutation)(nil)

// pageOption allows management of the mutation configuration using functional options.
type pageOption func(*PageMutation)

// newPageMutation creates new mutation for the Page entity.
func newPageMutation(c config, op Op, opts ...pageOption) *PageMutation {
	m := &PageMutation{
		config:        c,
		op:            op,
		typ:           TypePage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPageID sets the ID field of the mutation.
func withPageID(id uint) pageOption {
	return func(m *PageMutation) {
		var (
			err   error
			once  sync.Once
			value *Page
		)
		m.oldValue = func(ctx context.Context) (*Page, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Page.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPage sets the old Page of the mutation.
func withPage(node *Page) pageOption {
	return func(m *PageMutation) {
		m.oldValue = func(context.Context) (*Page, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Page entities.
func (m *PageMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PageMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PageMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Page.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[page.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[page.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, page.FieldDeletedAt)
}

// SetTitle sets the "title" field.
func (m *PageMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PageMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PageMutation) ResetTitle() {
	m.title = nil
}

// SetPath sets the "path" field.
func (m *PageMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *PageMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *PageMutation) ResetPath() {
	m._path = nil
}

// SetContent sets the "content" field.
func (m *PageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PageMutation) ResetContent() {
	m.content = nil
}

// SetDescription sets the "description" field.
func (m *PageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PageMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[page.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PageMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[page.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PageMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, page.FieldDescription)
}

// SetIsPublished sets the "is_published" field.
func (m *PageMutation) SetIsPublished(b bool) {
	m.is_published = &b
}

// IsPublished returns the value of the "is_published" field in the mutation.
func (m *PageMutation) IsPublished() (r bool, exists bool) {
	v := m.is_published
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublished returns the old "is_published" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldIsPublished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublished: %w", err)
	}
	return oldValue.IsPublished, nil
}

// ResetIsPublished resets all changes to the "is_published" field.
func (m *PageMutation) ResetIsPublished() {
	m.is_published = nil
}

// SetSort sets the "sort" field.
func (m *PageMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *PageMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *PageMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *PageMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *PageMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the PageMutation builder.
func (m *PageMutation) Where(ps ...predicate.Page) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Page, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Page).
func (m *PageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PageMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.deleted_at != nil {
		fields = append(fields, page.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, page.FieldTitle)
	}
	if m._path != nil {
		fields = append(fields, page.FieldPath)
	}
	if m.content != nil {
		fields = append(fields, page.FieldContent)
	}
	if m.description != nil {
		fields = append(fields, page.FieldDescription)
	}
	if m.is_published != nil {
		fields = append(fields, page.FieldIsPublished)
	}
	if m.sort != nil {
		fields = append(fields, page.FieldSort)
	}
	if m.created_at != nil {
		fields = append(fields, page.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, page.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case page.FieldDeletedAt:
		return m.DeletedAt()
	case page.FieldTitle:
		return m.Title()
	case page.FieldPath:
		return m.Path()
	case page.FieldContent:
		return m.Content()
	case page.FieldDescription:
		return m.Description()
	case page.FieldIsPublished:
		return m.IsPublished()
	case page.FieldSort:
		return m.Sort()
	case page.FieldCreatedAt:
		return m.CreatedAt()
	case page.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case page.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case page.FieldTitle:
		return m.OldTitle(ctx)
	case page.FieldPath:
		return m.OldPath(ctx)
	case page.FieldContent:
		return m.OldContent(ctx)
	case page.FieldDescription:
		return m.OldDescription(ctx)
	case page.FieldIsPublished:
		return m.OldIsPublished(ctx)
	case page.FieldSort:
		return m.OldSort(ctx)
	case page.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case page.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Page field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case page.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case page.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case page.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case page.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case page.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case page.FieldIsPublished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublished(v)
		return nil
	case page.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case page.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case page.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Page field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PageMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, page.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case page.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case page.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Page numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(page.FieldDeletedAt) {
		fields = append(fields, page.FieldDeletedAt)
	}
	if m.FieldCleared(page.FieldDescription) {
		fields = append(fields, page.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PageMutation) ClearField(name string) error {
	switch name {
	case page.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case page.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Page nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PageMutation) ResetField(name string) error {
	switch name {
	case page.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case page.FieldTitle:
		m.ResetTitle()
		return nil
	case page.FieldPath:
		m.ResetPath()
		return nil
	case page.FieldContent:
		m.ResetContent()
		return nil
	case page.FieldDescription:
		m.ResetDescription()
		return nil
	case page.FieldIsPublished:
		m.ResetIsPublished()
		return nil
	case page.FieldSort:
		m.ResetSort()
		return nil
	case page.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case page.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Page field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Page unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Page edge %s", name)
}

// PostCategoryMutation represents an operation that mutates the PostCategory nodes in the graph.
type PostCategoryMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	deleted_at      *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	count           *int
	addcount        *int
	is_series       *bool
	clearedFields   map[string]struct{}
	articles        map[uint]struct{}
	removedarticles map[uint]struct{}
	clearedarticles bool
	done            bool
	oldValue        func(context.Context) (*PostCategory, error)
	predicates      []predicate.PostCategory
}

var _ ent.Mutation = (*PostCategoryMutation)(nil)

// postcategoryOption allows management of the mutation configuration using functional options.
type postcategoryOption func(*PostCategoryMutation)

// newPostCategoryMutation creates new mutation for the PostCategory entity.
func newPostCategoryMutation(c config, op Op, opts ...postcategoryOption) *PostCategoryMutation {
	m := &PostCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypePostCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostCategoryID sets the ID field of the mutation.
func withPostCategoryID(id uint) postcategoryOption {
	return func(m *PostCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PostCategory
		)
		m.oldValue = func(ctx context.Context) (*PostCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostCategory sets the old PostCategory of the mutation.
func withPostCategory(node *PostCategory) postcategoryOption {
	return func(m *PostCategoryMutation) {
		m.oldValue = func(context.Context) (*PostCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostCategory entities.
func (m *PostCategoryMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostCategoryMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostCategoryMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PostCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PostCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PostCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[postcategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PostCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PostCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, postcategory.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PostCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PostCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PostCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PostCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PostCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PostCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[postcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PostCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PostCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, postcategory.FieldDescription)
}

// SetCount sets the "count" field.
func (m *PostCategoryMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *PostCategoryMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *PostCategoryMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *PostCategoryMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *PostCategoryMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetIsSeries sets the "is_series" field.
func (m *PostCategoryMutation) SetIsSeries(b bool) {
	m.is_series = &b
}

// IsSeries returns the value of the "is_series" field in the mutation.
func (m *PostCategoryMutation) IsSeries() (r bool, exists bool) {
	v := m.is_series
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSeries returns the old "is_series" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldIsSeries(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSeries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSeries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSeries: %w", err)
	}
	return oldValue.IsSeries, nil
}

// ResetIsSeries resets all changes to the "is_series" field.
func (m *PostCategoryMutation) ResetIsSeries() {
	m.is_series = nil
}

// AddArticleIDs adds the "articles" edge to the Article entity by ids.
func (m *PostCategoryMutation) AddArticleIDs(ids ...uint) {
	if m.articles == nil {
		m.articles = make(map[uint]struct{})
	}
	for i := range ids {
		m.articles[ids[i]] = struct{}{}
	}
}

// ClearArticles clears the "articles" edge to the Article entity.
func (m *PostCategoryMutation) ClearArticles() {
	m.clearedarticles = true
}

// ArticlesCleared reports if the "articles" edge to the Article entity was cleared.
func (m *PostCategoryMutation) ArticlesCleared() bool {
	return m.clearedarticles
}

// RemoveArticleIDs removes the "articles" edge to the Article entity by IDs.
func (m *PostCategoryMutation) RemoveArticleIDs(ids ...uint) {
	if m.removedarticles == nil {
		m.removedarticles = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.articles, ids[i])
		m.removedarticles[ids[i]] = struct{}{}
	}
}

// RemovedArticles returns the removed IDs of the "articles" edge to the Article entity.
func (m *PostCategoryMutation) RemovedArticlesIDs() (ids []uint) {
	for id := range m.removedarticles {
		ids = append(ids, id)
	}
	return
}

// ArticlesIDs returns the "articles" edge IDs in the mutation.
func (m *PostCategoryMutation) ArticlesIDs() (ids []uint) {
	for id := range m.articles {
		ids = append(ids, id)
	}
	return
}

// ResetArticles resets all changes to the "articles" edge.
func (m *PostCategoryMutation) ResetArticles() {
	m.articles = nil
	m.clearedarticles = false
	m.removedarticles = nil
}

// Where appends a list predicates to the PostCategoryMutation builder.
func (m *PostCategoryMutation) Where(ps ...predicate.PostCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostCategory).
func (m *PostCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostCategoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.deleted_at != nil {
		fields = append(fields, postcategory.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, postcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, postcategory.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, postcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, postcategory.FieldDescription)
	}
	if m.count != nil {
		fields = append(fields, postcategory.FieldCount)
	}
	if m.is_series != nil {
		fields = append(fields, postcategory.FieldIsSeries)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postcategory.FieldDeletedAt:
		return m.DeletedAt()
	case postcategory.FieldCreatedAt:
		return m.CreatedAt()
	case postcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case postcategory.FieldName:
		return m.Name()
	case postcategory.FieldDescription:
		return m.Description()
	case postcategory.FieldCount:
		return m.Count()
	case postcategory.FieldIsSeries:
		return m.IsSeries()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postcategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case postcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case postcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case postcategory.FieldName:
		return m.OldName(ctx)
	case postcategory.FieldDescription:
		return m.OldDescription(ctx)
	case postcategory.FieldCount:
		return m.OldCount(ctx)
	case postcategory.FieldIsSeries:
		return m.OldIsSeries(ctx)
	}
	return nil, fmt.Errorf("unknown PostCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postcategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case postcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case postcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case postcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case postcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case postcategory.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case postcategory.FieldIsSeries:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSeries(v)
		return nil
	}
	return fmt.Errorf("unknown PostCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, postcategory.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case postcategory.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case postcategory.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown PostCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(postcategory.FieldDeletedAt) {
		fields = append(fields, postcategory.FieldDeletedAt)
	}
	if m.FieldCleared(postcategory.FieldDescription) {
		fields = append(fields, postcategory.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostCategoryMutation) ClearField(name string) error {
	switch name {
	case postcategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case postcategory.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown PostCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostCategoryMutation) ResetField(name string) error {
	switch name {
	case postcategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case postcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case postcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case postcategory.FieldName:
		m.ResetName()
		return nil
	case postcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case postcategory.FieldCount:
		m.ResetCount()
		return nil
	case postcategory.FieldIsSeries:
		m.ResetIsSeries()
		return nil
	}
	return fmt.Errorf("unknown PostCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.articles != nil {
		edges = append(edges, postcategory.EdgeArticles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postcategory.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.articles))
		for id := range m.articles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedarticles != nil {
		edges = append(edges, postcategory.EdgeArticles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case postcategory.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.removedarticles))
		for id := range m.removedarticles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedarticles {
		edges = append(edges, postcategory.EdgeArticles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case postcategory.EdgeArticles:
		return m.clearedarticles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PostCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostCategoryMutation) ResetEdge(name string) error {
	switch name {
	case postcategory.EdgeArticles:
		m.ResetArticles()
		return nil
	}
	return fmt.Errorf("unknown PostCategory edge %s", name)
}

// PostTagMutation represents an operation that mutates the PostTag nodes in the graph.
type PostTagMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	deleted_at      *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	count           *int
	addcount        *int
	clearedFields   map[string]struct{}
	articles        map[uint]struct{}
	removedarticles map[uint]struct{}
	clearedarticles bool
	done            bool
	oldValue        func(context.Context) (*PostTag, error)
	predicates      []predicate.PostTag
}

var _ ent.Mutation = (*PostTagMutation)(nil)

// posttagOption allows management of the mutation configuration using functional options.
type posttagOption func(*PostTagMutation)

// newPostTagMutation creates new mutation for the PostTag entity.
func newPostTagMutation(c config, op Op, opts ...posttagOption) *PostTagMutation {
	m := &PostTagMutation{
		config:        c,
		op:            op,
		typ:           TypePostTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostTagID sets the ID field of the mutation.
func withPostTagID(id uint) posttagOption {
	return func(m *PostTagMutation) {
		var (
			err   error
			once  sync.Once
			value *PostTag
		)
		m.oldValue = func(ctx context.Context) (*PostTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostTag sets the old PostTag of the mutation.
func withPostTag(node *PostTag) posttagOption {
	return func(m *PostTagMutation) {
		m.oldValue = func(context.Context) (*PostTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostTag entities.
func (m *PostTagMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostTagMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostTagMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PostTagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PostTagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PostTagMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[posttag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PostTagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[posttag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PostTagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, posttag.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PostTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PostTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PostTagMutation) ResetName() {
	m.name = nil
}

// SetCount sets the "count" field.
func (m *PostTagMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *PostTagMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *PostTagMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *PostTagMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *PostTagMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// AddArticleIDs adds the "articles" edge to the Article entity by ids.
func (m *PostTagMutation) AddArticleIDs(ids ...uint) {
	if m.articles == nil {
		m.articles = make(map[uint]struct{})
	}
	for i := range ids {
		m.articles[ids[i]] = struct{}{}
	}
}

// ClearArticles clears the "articles" edge to the Article entity.
func (m *PostTagMutation) ClearArticles() {
	m.clearedarticles = true
}

// ArticlesCleared reports if the "articles" edge to the Article entity was cleared.
func (m *PostTagMutation) ArticlesCleared() bool {
	return m.clearedarticles
}

// RemoveArticleIDs removes the "articles" edge to the Article entity by IDs.
func (m *PostTagMutation) RemoveArticleIDs(ids ...uint) {
	if m.removedarticles == nil {
		m.removedarticles = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.articles, ids[i])
		m.removedarticles[ids[i]] = struct{}{}
	}
}

// RemovedArticles returns the removed IDs of the "articles" edge to the Article entity.
func (m *PostTagMutation) RemovedArticlesIDs() (ids []uint) {
	for id := range m.removedarticles {
		ids = append(ids, id)
	}
	return
}

// ArticlesIDs returns the "articles" edge IDs in the mutation.
func (m *PostTagMutation) ArticlesIDs() (ids []uint) {
	for id := range m.articles {
		ids = append(ids, id)
	}
	return
}

// ResetArticles resets all changes to the "articles" edge.
func (m *PostTagMutation) ResetArticles() {
	m.articles = nil
	m.clearedarticles = false
	m.removedarticles = nil
}

// Where appends a list predicates to the PostTagMutation builder.
func (m *PostTagMutation) Where(ps ...predicate.PostTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostTag).
func (m *PostTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostTagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.deleted_at != nil {
		fields = append(fields, posttag.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, posttag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, posttag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, posttag.FieldName)
	}
	if m.count != nil {
		fields = append(fields, posttag.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case posttag.FieldDeletedAt:
		return m.DeletedAt()
	case posttag.FieldCreatedAt:
		return m.CreatedAt()
	case posttag.FieldUpdatedAt:
		return m.UpdatedAt()
	case posttag.FieldName:
		return m.Name()
	case posttag.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case posttag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case posttag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case posttag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case posttag.FieldName:
		return m.OldName(ctx)
	case posttag.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown PostTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case posttag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case posttag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case posttag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case posttag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case posttag.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown PostTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostTagMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, posttag.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case posttag.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case posttag.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown PostTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(posttag.FieldDeletedAt) {
		fields = append(fields, posttag.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostTagMutation) ClearField(name string) error {
	switch name {
	case posttag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PostTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostTagMutation) ResetField(name string) error {
	switch name {
	case posttag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case posttag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case posttag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case posttag.FieldName:
		m.ResetName()
		return nil
	case posttag.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown PostTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.articles != nil {
		edges = append(edges, posttag.EdgeArticles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case posttag.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.articles))
		for id := range m.articles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedarticles != nil {
		edges = append(edges, posttag.EdgeArticles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case posttag.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.removedarticles))
		for id := range m.removedarticles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedarticles {
		edges = append(edges, posttag.EdgeArticles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostTagMutation) EdgeCleared(name string) bool {
	switch name {
	case posttag.EdgeArticles:
		return m.clearedarticles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PostTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostTagMutation) ResetEdge(name string) error {
	switch name {
	case posttag.EdgeArticles:
		m.ResetArticles()
		return nil
	}
	return fmt.Errorf("unknown PostTag edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	deleted_at    *time.Time
	config_key    *string
	value         *string
	comment       *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SettingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[setting.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SettingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[setting.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, setting.FieldDeletedAt)
}

// SetConfigKey sets the "config_key" field.
func (m *SettingMutation) SetConfigKey(s string) {
	m.config_key = &s
}

// ConfigKey returns the value of the "config_key" field in the mutation.
func (m *SettingMutation) ConfigKey() (r string, exists bool) {
	v := m.config_key
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigKey returns the old "config_key" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldConfigKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigKey: %w", err)
	}
	return oldValue.ConfigKey, nil
}

// ResetConfigKey resets all changes to the "config_key" field.
func (m *SettingMutation) ResetConfigKey() {
	m.config_key = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetComment sets the "comment" field.
func (m *SettingMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *SettingMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *SettingMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[setting.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *SettingMutation) CommentCleared() bool {
	_, ok := m.clearedFields[setting.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *SettingMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, setting.FieldComment)
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, setting.FieldDeletedAt)
	}
	if m.config_key != nil {
		fields = append(fields, setting.FieldConfigKey)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.comment != nil {
		fields = append(fields, setting.FieldComment)
	}
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldDeletedAt:
		return m.DeletedAt()
	case setting.FieldConfigKey:
		return m.ConfigKey()
	case setting.FieldValue:
		return m.Value()
	case setting.FieldComment:
		return m.Comment()
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case setting.FieldConfigKey:
		return m.OldConfigKey(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldComment:
		return m.OldComment(ctx)
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case setting.FieldConfigKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigKey(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldDeletedAt) {
		fields = append(fields, setting.FieldDeletedAt)
	}
	if m.FieldCleared(setting.FieldComment) {
		fields = append(fields, setting.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case setting.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case setting.FieldConfigKey:
		m.ResetConfigKey()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldComment:
		m.ResetComment()
		return nil
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// StoragePolicyMutation represents an operation that mutates the StoragePolicy nodes in the graph.
type StoragePolicyMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	deleted_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	_type         *string
	flag          *string
	server        *string
	bucket_name   *string
	is_private    *bool
	access_key    *string
	secret_key    *string
	max_size      *int64
	addmax_size   *int64
	base_path     *string
	virtual_path  *string
	settings      *model.StoragePolicySettings
	node_id       *uint
	addnode_id    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*StoragePolicy, error)
	predicates    []predicate.StoragePolicy
}

var _ ent.Mutation = (*StoragePolicyMutation)(nil)

// storagepolicyOption allows management of the mutation configuration using functional options.
type storagepolicyOption func(*StoragePolicyMutation)

// newStoragePolicyMutation creates new mutation for the StoragePolicy entity.
func newStoragePolicyMutation(c config, op Op, opts ...storagepolicyOption) *StoragePolicyMutation {
	m := &StoragePolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeStoragePolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoragePolicyID sets the ID field of the mutation.
func withStoragePolicyID(id uint) storagepolicyOption {
	return func(m *StoragePolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *StoragePolicy
		)
		m.oldValue = func(ctx context.Context) (*StoragePolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoragePolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoragePolicy sets the old StoragePolicy of the mutation.
func withStoragePolicy(node *StoragePolicy) storagepolicyOption {
	return func(m *StoragePolicyMutation) {
		m.oldValue = func(context.Context) (*StoragePolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoragePolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoragePolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StoragePolicy entities.
func (m *StoragePolicyMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoragePolicyMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoragePolicyMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoragePolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoragePolicyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoragePolicyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StoragePolicyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[storagepolicy.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StoragePolicyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoragePolicyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, storagepolicy.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *StoragePolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoragePolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoragePolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoragePolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoragePolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoragePolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *StoragePolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StoragePolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StoragePolicyMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *StoragePolicyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *StoragePolicyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *StoragePolicyMutation) ResetType() {
	m._type = nil
}

// SetFlag sets the "flag" field.
func (m *StoragePolicyMutation) SetFlag(s string) {
	m.flag = &s
}

// Flag returns the value of the "flag" field in the mutation.
func (m *StoragePolicyMutation) Flag() (r string, exists bool) {
	v := m.flag
	if v == nil {
		return
	}
	return *v, true
}

// OldFlag returns the old "flag" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlag: %w", err)
	}
	return oldValue.Flag, nil
}

// ClearFlag clears the value of the "flag" field.
func (m *StoragePolicyMutation) ClearFlag() {
	m.flag = nil
	m.clearedFields[storagepolicy.FieldFlag] = struct{}{}
}

// FlagCleared returns if the "flag" field was cleared in this mutation.
func (m *StoragePolicyMutation) FlagCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldFlag]
	return ok
}

// ResetFlag resets all changes to the "flag" field.
func (m *StoragePolicyMutation) ResetFlag() {
	m.flag = nil
	delete(m.clearedFields, storagepolicy.FieldFlag)
}

// SetServer sets the "server" field.
func (m *StoragePolicyMutation) SetServer(s string) {
	m.server = &s
}

// Server returns the value of the "server" field in the mutation.
func (m *StoragePolicyMutation) Server() (r string, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServer returns the old "server" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServer: %w", err)
	}
	return oldValue.Server, nil
}

// ClearServer clears the value of the "server" field.
func (m *StoragePolicyMutation) ClearServer() {
	m.server = nil
	m.clearedFields[storagepolicy.FieldServer] = struct{}{}
}

// ServerCleared returns if the "server" field was cleared in this mutation.
func (m *StoragePolicyMutation) ServerCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldServer]
	return ok
}

// ResetServer resets all changes to the "server" field.
func (m *StoragePolicyMutation) ResetServer() {
	m.server = nil
	delete(m.clearedFields, storagepolicy.FieldServer)
}

// SetBucketName sets the "bucket_name" field.
func (m *StoragePolicyMutation) SetBucketName(s string) {
	m.bucket_name = &s
}

// BucketName returns the value of the "bucket_name" field in the mutation.
func (m *StoragePolicyMutation) BucketName() (r string, exists bool) {
	v := m.bucket_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketName returns the old "bucket_name" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldBucketName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketName: %w", err)
	}
	return oldValue.BucketName, nil
}

// ClearBucketName clears the value of the "bucket_name" field.
func (m *StoragePolicyMutation) ClearBucketName() {
	m.bucket_name = nil
	m.clearedFields[storagepolicy.FieldBucketName] = struct{}{}
}

// BucketNameCleared returns if the "bucket_name" field was cleared in this mutation.
func (m *StoragePolicyMutation) BucketNameCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldBucketName]
	return ok
}

// ResetBucketName resets all changes to the "bucket_name" field.
func (m *StoragePolicyMutation) ResetBucketName() {
	m.bucket_name = nil
	delete(m.clearedFields, storagepolicy.FieldBucketName)
}

// SetIsPrivate sets the "is_private" field.
func (m *StoragePolicyMutation) SetIsPrivate(b bool) {
	m.is_private = &b
}

// IsPrivate returns the value of the "is_private" field in the mutation.
func (m *StoragePolicyMutation) IsPrivate() (r bool, exists bool) {
	v := m.is_private
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrivate returns the old "is_private" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldIsPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrivate: %w", err)
	}
	return oldValue.IsPrivate, nil
}

// ClearIsPrivate clears the value of the "is_private" field.
func (m *StoragePolicyMutation) ClearIsPrivate() {
	m.is_private = nil
	m.clearedFields[storagepolicy.FieldIsPrivate] = struct{}{}
}

// IsPrivateCleared returns if the "is_private" field was cleared in this mutation.
func (m *StoragePolicyMutation) IsPrivateCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldIsPrivate]
	return ok
}

// ResetIsPrivate resets all changes to the "is_private" field.
func (m *StoragePolicyMutation) ResetIsPrivate() {
	m.is_private = nil
	delete(m.clearedFields, storagepolicy.FieldIsPrivate)
}

// SetAccessKey sets the "access_key" field.
func (m *StoragePolicyMutation) SetAccessKey(s string) {
	m.access_key = &s
}

// AccessKey returns the value of the "access_key" field in the mutation.
func (m *StoragePolicyMutation) AccessKey() (r string, exists bool) {
	v := m.access_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessKey returns the old "access_key" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldAccessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessKey: %w", err)
	}
	return oldValue.AccessKey, nil
}

// ClearAccessKey clears the value of the "access_key" field.
func (m *StoragePolicyMutation) ClearAccessKey() {
	m.access_key = nil
	m.clearedFields[storagepolicy.FieldAccessKey] = struct{}{}
}

// AccessKeyCleared returns if the "access_key" field was cleared in this mutation.
func (m *StoragePolicyMutation) AccessKeyCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldAccessKey]
	return ok
}

// ResetAccessKey resets all changes to the "access_key" field.
func (m *StoragePolicyMutation) ResetAccessKey() {
	m.access_key = nil
	delete(m.clearedFields, storagepolicy.FieldAccessKey)
}

// SetSecretKey sets the "secret_key" field.
func (m *StoragePolicyMutation) SetSecretKey(s string) {
	m.secret_key = &s
}

// SecretKey returns the value of the "secret_key" field in the mutation.
func (m *StoragePolicyMutation) SecretKey() (r string, exists bool) {
	v := m.secret_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "secret_key" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ClearSecretKey clears the value of the "secret_key" field.
func (m *StoragePolicyMutation) ClearSecretKey() {
	m.secret_key = nil
	m.clearedFields[storagepolicy.FieldSecretKey] = struct{}{}
}

// SecretKeyCleared returns if the "secret_key" field was cleared in this mutation.
func (m *StoragePolicyMutation) SecretKeyCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldSecretKey]
	return ok
}

// ResetSecretKey resets all changes to the "secret_key" field.
func (m *StoragePolicyMutation) ResetSecretKey() {
	m.secret_key = nil
	delete(m.clearedFields, storagepolicy.FieldSecretKey)
}

// SetMaxSize sets the "max_size" field.
func (m *StoragePolicyMutation) SetMaxSize(i int64) {
	m.max_size = &i
	m.addmax_size = nil
}

// MaxSize returns the value of the "max_size" field in the mutation.
func (m *StoragePolicyMutation) MaxSize() (r int64, exists bool) {
	v := m.max_size
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxSize returns the old "max_size" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldMaxSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxSize: %w", err)
	}
	return oldValue.MaxSize, nil
}

// AddMaxSize adds i to the "max_size" field.
func (m *StoragePolicyMutation) AddMaxSize(i int64) {
	if m.addmax_size != nil {
		*m.addmax_size += i
	} else {
		m.addmax_size = &i
	}
}

// AddedMaxSize returns the value that was added to the "max_size" field in this mutation.
func (m *StoragePolicyMutation) AddedMaxSize() (r int64, exists bool) {
	v := m.addmax_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxSize clears the value of the "max_size" field.
func (m *StoragePolicyMutation) ClearMaxSize() {
	m.max_size = nil
	m.addmax_size = nil
	m.clearedFields[storagepolicy.FieldMaxSize] = struct{}{}
}

// MaxSizeCleared returns if the "max_size" field was cleared in this mutation.
func (m *StoragePolicyMutation) MaxSizeCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldMaxSize]
	return ok
}

// ResetMaxSize resets all changes to the "max_size" field.
func (m *StoragePolicyMutation) ResetMaxSize() {
	m.max_size = nil
	m.addmax_size = nil
	delete(m.clearedFields, storagepolicy.FieldMaxSize)
}

// SetBasePath sets the "base_path" field.
func (m *StoragePolicyMutation) SetBasePath(s string) {
	m.base_path = &s
}

// BasePath returns the value of the "base_path" field in the mutation.
func (m *StoragePolicyMutation) BasePath() (r string, exists bool) {
	v := m.base_path
	if v == nil {
		return
	}
	return *v, true
}

// OldBasePath returns the old "base_path" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldBasePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasePath: %w", err)
	}
	return oldValue.BasePath, nil
}

// ClearBasePath clears the value of the "base_path" field.
func (m *StoragePolicyMutation) ClearBasePath() {
	m.base_path = nil
	m.clearedFields[storagepolicy.FieldBasePath] = struct{}{}
}

// BasePathCleared returns if the "base_path" field was cleared in this mutation.
func (m *StoragePolicyMutation) BasePathCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldBasePath]
	return ok
}

// ResetBasePath resets all changes to the "base_path" field.
func (m *StoragePolicyMutation) ResetBasePath() {
	m.base_path = nil
	delete(m.clearedFields, storagepolicy.FieldBasePath)
}

// SetVirtualPath sets the "virtual_path" field.
func (m *StoragePolicyMutation) SetVirtualPath(s string) {
	m.virtual_path = &s
}

// VirtualPath returns the value of the "virtual_path" field in the mutation.
func (m *StoragePolicyMutation) VirtualPath() (r string, exists bool) {
	v := m.virtual_path
	if v == nil {
		return
	}
	return *v, true
}

// OldVirtualPath returns the old "virtual_path" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldVirtualPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVirtualPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVirtualPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVirtualPath: %w", err)
	}
	return oldValue.VirtualPath, nil
}

// ClearVirtualPath clears the value of the "virtual_path" field.
func (m *StoragePolicyMutation) ClearVirtualPath() {
	m.virtual_path = nil
	m.clearedFields[storagepolicy.FieldVirtualPath] = struct{}{}
}

// VirtualPathCleared returns if the "virtual_path" field was cleared in this mutation.
func (m *StoragePolicyMutation) VirtualPathCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldVirtualPath]
	return ok
}

// ResetVirtualPath resets all changes to the "virtual_path" field.
func (m *StoragePolicyMutation) ResetVirtualPath() {
	m.virtual_path = nil
	delete(m.clearedFields, storagepolicy.FieldVirtualPath)
}

// SetSettings sets the "settings" field.
func (m *StoragePolicyMutation) SetSettings(mps model.StoragePolicySettings) {
	m.settings = &mps
}

// Settings returns the value of the "settings" field in the mutation.
func (m *StoragePolicyMutation) Settings() (r model.StoragePolicySettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldSettings(ctx context.Context) (v model.StoragePolicySettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *StoragePolicyMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[storagepolicy.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *StoragePolicyMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *StoragePolicyMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, storagepolicy.FieldSettings)
}

// SetNodeID sets the "node_id" field.
func (m *StoragePolicyMutation) SetNodeID(u uint) {
	m.node_id = &u
	m.addnode_id = nil
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *StoragePolicyMutation) NodeID() (r uint, exists bool) {
	v := m.node_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldNodeID(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// AddNodeID adds u to the "node_id" field.
func (m *StoragePolicyMutation) AddNodeID(u int) {
	if m.addnode_id != nil {
		*m.addnode_id += u
	} else {
		m.addnode_id = &u
	}
}

// AddedNodeID returns the value that was added to the "node_id" field in this mutation.
func (m *StoragePolicyMutation) AddedNodeID() (r int, exists bool) {
	v := m.addnode_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearNodeID clears the value of the "node_id" field.
func (m *StoragePolicyMutation) ClearNodeID() {
	m.node_id = nil
	m.addnode_id = nil
	m.clearedFields[storagepolicy.FieldNodeID] = struct{}{}
}

// NodeIDCleared returns if the "node_id" field was cleared in this mutation.
func (m *StoragePolicyMutation) NodeIDCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldNodeID]
	return ok
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *StoragePolicyMutation) ResetNodeID() {
	m.node_id = nil
	m.addnode_id = nil
	delete(m.clearedFields, storagepolicy.FieldNodeID)
}

// Where appends a list predicates to the StoragePolicyMutation builder.
func (m *StoragePolicyMutation) Where(ps ...predicate.StoragePolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoragePolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoragePolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoragePolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoragePolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoragePolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoragePolicy).
func (m *StoragePolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoragePolicyMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.deleted_at != nil {
		fields = append(fields, storagepolicy.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, storagepolicy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storagepolicy.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, storagepolicy.FieldName)
	}
	if m._type != nil {
		fields = append(fields, storagepolicy.FieldType)
	}
	if m.flag != nil {
		fields = append(fields, storagepolicy.FieldFlag)
	}
	if m.server != nil {
		fields = append(fields, storagepolicy.FieldServer)
	}
	if m.bucket_name != nil {
		fields = append(fields, storagepolicy.FieldBucketName)
	}
	if m.is_private != nil {
		fields = append(fields, storagepolicy.FieldIsPrivate)
	}
	if m.access_key != nil {
		fields = append(fields, storagepolicy.FieldAccessKey)
	}
	if m.secret_key != nil {
		fields = append(fields, storagepolicy.FieldSecretKey)
	}
	if m.max_size != nil {
		fields = append(fields, storagepolicy.FieldMaxSize)
	}
	if m.base_path != nil {
		fields = append(fields, storagepolicy.FieldBasePath)
	}
	if m.virtual_path != nil {
		fields = append(fields, storagepolicy.FieldVirtualPath)
	}
	if m.settings != nil {
		fields = append(fields, storagepolicy.FieldSettings)
	}
	if m.node_id != nil {
		fields = append(fields, storagepolicy.FieldNodeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoragePolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storagepolicy.FieldDeletedAt:
		return m.DeletedAt()
	case storagepolicy.FieldCreatedAt:
		return m.CreatedAt()
	case storagepolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case storagepolicy.FieldName:
		return m.Name()
	case storagepolicy.FieldType:
		return m.GetType()
	case storagepolicy.FieldFlag:
		return m.Flag()
	case storagepolicy.FieldServer:
		return m.Server()
	case storagepolicy.FieldBucketName:
		return m.BucketName()
	case storagepolicy.FieldIsPrivate:
		return m.IsPrivate()
	case storagepolicy.FieldAccessKey:
		return m.AccessKey()
	case storagepolicy.FieldSecretKey:
		return m.SecretKey()
	case storagepolicy.FieldMaxSize:
		return m.MaxSize()
	case storagepolicy.FieldBasePath:
		return m.BasePath()
	case storagepolicy.FieldVirtualPath:
		return m.VirtualPath()
	case storagepolicy.FieldSettings:
		return m.Settings()
	case storagepolicy.FieldNodeID:
		return m.NodeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoragePolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storagepolicy.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case storagepolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storagepolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storagepolicy.FieldName:
		return m.OldName(ctx)
	case storagepolicy.FieldType:
		return m.OldType(ctx)
	case storagepolicy.FieldFlag:
		return m.OldFlag(ctx)
	case storagepolicy.FieldServer:
		return m.OldServer(ctx)
	case storagepolicy.FieldBucketName:
		return m.OldBucketName(ctx)
	case storagepolicy.FieldIsPrivate:
		return m.OldIsPrivate(ctx)
	case storagepolicy.FieldAccessKey:
		return m.OldAccessKey(ctx)
	case storagepolicy.FieldSecretKey:
		return m.OldSecretKey(ctx)
	case storagepolicy.FieldMaxSize:
		return m.OldMaxSize(ctx)
	case storagepolicy.FieldBasePath:
		return m.OldBasePath(ctx)
	case storagepolicy.FieldVirtualPath:
		return m.OldVirtualPath(ctx)
	case storagepolicy.FieldSettings:
		return m.OldSettings(ctx)
	case storagepolicy.FieldNodeID:
		return m.OldNodeID(ctx)
	}
	return nil, fmt.Errorf("unknown StoragePolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoragePolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storagepolicy.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case storagepolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storagepolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storagepolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case storagepolicy.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case storagepolicy.FieldFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlag(v)
		return nil
	case storagepolicy.FieldServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServer(v)
		return nil
	case storagepolicy.FieldBucketName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketName(v)
		return nil
	case storagepolicy.FieldIsPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrivate(v)
		return nil
	case storagepolicy.FieldAccessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessKey(v)
		return nil
	case storagepolicy.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	case storagepolicy.FieldMaxSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxSize(v)
		return nil
	case storagepolicy.FieldBasePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasePath(v)
		return nil
	case storagepolicy.FieldVirtualPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVirtualPath(v)
		return nil
	case storagepolicy.FieldSettings:
		v, ok := value.(model.StoragePolicySettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case storagepolicy.FieldNodeID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoragePolicyMutation) AddedFields() []string {
	var fields []string
	if m.addmax_size != nil {
		fields = append(fields, storagepolicy.FieldMaxSize)
	}
	if m.addnode_id != nil {
		fields = append(fields, storagepolicy.FieldNodeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoragePolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case storagepolicy.FieldMaxSize:
		return m.AddedMaxSize()
	case storagepolicy.FieldNodeID:
		return m.AddedNodeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoragePolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case storagepolicy.FieldMaxSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxSize(v)
		return nil
	case storagepolicy.FieldNodeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNodeID(v)
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoragePolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storagepolicy.FieldDeletedAt) {
		fields = append(fields, storagepolicy.FieldDeletedAt)
	}
	if m.FieldCleared(storagepolicy.FieldFlag) {
		fields = append(fields, storagepolicy.FieldFlag)
	}
	if m.FieldCleared(storagepolicy.FieldServer) {
		fields = append(fields, storagepolicy.FieldServer)
	}
	if m.FieldCleared(storagepolicy.FieldBucketName) {
		fields = append(fields, storagepolicy.FieldBucketName)
	}
	if m.FieldCleared(storagepolicy.FieldIsPrivate) {
		fields = append(fields, storagepolicy.FieldIsPrivate)
	}
	if m.FieldCleared(storagepolicy.FieldAccessKey) {
		fields = append(fields, storagepolicy.FieldAccessKey)
	}
	if m.FieldCleared(storagepolicy.FieldSecretKey) {
		fields = append(fields, storagepolicy.FieldSecretKey)
	}
	if m.FieldCleared(storagepolicy.FieldMaxSize) {
		fields = append(fields, storagepolicy.FieldMaxSize)
	}
	if m.FieldCleared(storagepolicy.FieldBasePath) {
		fields = append(fields, storagepolicy.FieldBasePath)
	}
	if m.FieldCleared(storagepolicy.FieldVirtualPath) {
		fields = append(fields, storagepolicy.FieldVirtualPath)
	}
	if m.FieldCleared(storagepolicy.FieldSettings) {
		fields = append(fields, storagepolicy.FieldSettings)
	}
	if m.FieldCleared(storagepolicy.FieldNodeID) {
		fields = append(fields, storagepolicy.FieldNodeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoragePolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoragePolicyMutation) ClearField(name string) error {
	switch name {
	case storagepolicy.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case storagepolicy.FieldFlag:
		m.ClearFlag()
		return nil
	case storagepolicy.FieldServer:
		m.ClearServer()
		return nil
	case storagepolicy.FieldBucketName:
		m.ClearBucketName()
		return nil
	case storagepolicy.FieldIsPrivate:
		m.ClearIsPrivate()
		return nil
	case storagepolicy.FieldAccessKey:
		m.ClearAccessKey()
		return nil
	case storagepolicy.FieldSecretKey:
		m.ClearSecretKey()
		return nil
	case storagepolicy.FieldMaxSize:
		m.ClearMaxSize()
		return nil
	case storagepolicy.FieldBasePath:
		m.ClearBasePath()
		return nil
	case storagepolicy.FieldVirtualPath:
		m.ClearVirtualPath()
		return nil
	case storagepolicy.FieldSettings:
		m.ClearSettings()
		return nil
	case storagepolicy.FieldNodeID:
		m.ClearNodeID()
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoragePolicyMutation) ResetField(name string) error {
	switch name {
	case storagepolicy.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case storagepolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storagepolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storagepolicy.FieldName:
		m.ResetName()
		return nil
	case storagepolicy.FieldType:
		m.ResetType()
		return nil
	case storagepolicy.FieldFlag:
		m.ResetFlag()
		return nil
	case storagepolicy.FieldServer:
		m.ResetServer()
		return nil
	case storagepolicy.FieldBucketName:
		m.ResetBucketName()
		return nil
	case storagepolicy.FieldIsPrivate:
		m.ResetIsPrivate()
		return nil
	case storagepolicy.FieldAccessKey:
		m.ResetAccessKey()
		return nil
	case storagepolicy.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	case storagepolicy.FieldMaxSize:
		m.ResetMaxSize()
		return nil
	case storagepolicy.FieldBasePath:
		m.ResetBasePath()
		return nil
	case storagepolicy.FieldVirtualPath:
		m.ResetVirtualPath()
		return nil
	case storagepolicy.FieldSettings:
		m.ResetSettings()
		return nil
	case storagepolicy.FieldNodeID:
		m.ResetNodeID()
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoragePolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoragePolicyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoragePolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoragePolicyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoragePolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoragePolicyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoragePolicyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StoragePolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoragePolicyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StoragePolicy edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	deleted_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uint) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TagMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tag.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.deleted_at != nil {
		fields = append(fields, tag.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldDeletedAt:
		return m.DeletedAt()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDeletedAt) {
		fields = append(fields, tag.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tag edge %s", name)
}

// URLStatMutation represents an operation that mutates the URLStat nodes in the graph.
type URLStatMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	created_at      *time.Time
	updated_at      *time.Time
	url_path        *string
	page_title      *string
	total_views     *int64
	addtotal_views  *int64
	unique_views    *int64
	addunique_views *int64
	bounce_count    *int64
	addbounce_count *int64
	avg_duration    *float64
	addavg_duration *float64
	last_visited_at *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*URLStat, error)
	predicates      []predicate.URLStat
}

var _ ent.Mutation = (*URLStatMutation)(nil)

// urlstatOption allows management of the mutation configuration using functional options.
type urlstatOption func(*URLStatMutation)

// newURLStatMutation creates new mutation for the URLStat entity.
func newURLStatMutation(c config, op Op, opts ...urlstatOption) *URLStatMutation {
	m := &URLStatMutation{
		config:        c,
		op:            op,
		typ:           TypeURLStat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withURLStatID sets the ID field of the mutation.
func withURLStatID(id uint) urlstatOption {
	return func(m *URLStatMutation) {
		var (
			err   error
			once  sync.Once
			value *URLStat
		)
		m.oldValue = func(ctx context.Context) (*URLStat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().URLStat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withURLStat sets the old URLStat of the mutation.
func withURLStat(node *URLStat) urlstatOption {
	return func(m *URLStatMutation) {
		m.oldValue = func(context.Context) (*URLStat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m URLStatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m URLStatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of URLStat entities.
func (m *URLStatMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *URLStatMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *URLStatMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().URLStat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *URLStatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *URLStatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *URLStatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *URLStatMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *URLStatMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *URLStatMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetURLPath sets the "url_path" field.
func (m *URLStatMutation) SetURLPath(s string) {
	m.url_path = &s
}

// URLPath returns the value of the "url_path" field in the mutation.
func (m *URLStatMutation) URLPath() (r string, exists bool) {
	v := m.url_path
	if v == nil {
		return
	}
	return *v, true
}

// OldURLPath returns the old "url_path" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldURLPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLPath: %w", err)
	}
	return oldValue.URLPath, nil
}

// ResetURLPath resets all changes to the "url_path" field.
func (m *URLStatMutation) ResetURLPath() {
	m.url_path = nil
}

// SetPageTitle sets the "page_title" field.
func (m *URLStatMutation) SetPageTitle(s string) {
	m.page_title = &s
}

// PageTitle returns the value of the "page_title" field in the mutation.
func (m *URLStatMutation) PageTitle() (r string, exists bool) {
	v := m.page_title
	if v == nil {
		return
	}
	return *v, true
}

// OldPageTitle returns the old "page_title" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldPageTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageTitle: %w", err)
	}
	return oldValue.PageTitle, nil
}

// ClearPageTitle clears the value of the "page_title" field.
func (m *URLStatMutation) ClearPageTitle() {
	m.page_title = nil
	m.clearedFields[urlstat.FieldPageTitle] = struct{}{}
}

// PageTitleCleared returns if the "page_title" field was cleared in this mutation.
func (m *URLStatMutation) PageTitleCleared() bool {
	_, ok := m.clearedFields[urlstat.FieldPageTitle]
	return ok
}

// ResetPageTitle resets all changes to the "page_title" field.
func (m *URLStatMutation) ResetPageTitle() {
	m.page_title = nil
	delete(m.clearedFields, urlstat.FieldPageTitle)
}

// SetTotalViews sets the "total_views" field.
func (m *URLStatMutation) SetTotalViews(i int64) {
	m.total_views = &i
	m.addtotal_views = nil
}

// TotalViews returns the value of the "total_views" field in the mutation.
func (m *URLStatMutation) TotalViews() (r int64, exists bool) {
	v := m.total_views
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalViews returns the old "total_views" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldTotalViews(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalViews: %w", err)
	}
	return oldValue.TotalViews, nil
}

// AddTotalViews adds i to the "total_views" field.
func (m *URLStatMutation) AddTotalViews(i int64) {
	if m.addtotal_views != nil {
		*m.addtotal_views += i
	} else {
		m.addtotal_views = &i
	}
}

// AddedTotalViews returns the value that was added to the "total_views" field in this mutation.
func (m *URLStatMutation) AddedTotalViews() (r int64, exists bool) {
	v := m.addtotal_views
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalViews resets all changes to the "total_views" field.
func (m *URLStatMutation) ResetTotalViews() {
	m.total_views = nil
	m.addtotal_views = nil
}

// SetUniqueViews sets the "unique_views" field.
func (m *URLStatMutation) SetUniqueViews(i int64) {
	m.unique_views = &i
	m.addunique_views = nil
}

// UniqueViews returns the value of the "unique_views" field in the mutation.
func (m *URLStatMutation) UniqueViews() (r int64, exists bool) {
	v := m.unique_views
	if v == nil {
		return
	}
	return *v, true
}

// OldUniqueViews returns the old "unique_views" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldUniqueViews(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniqueViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniqueViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniqueViews: %w", err)
	}
	return oldValue.UniqueViews, nil
}

// AddUniqueViews adds i to the "unique_views" field.
func (m *URLStatMutation) AddUniqueViews(i int64) {
	if m.addunique_views != nil {
		*m.addunique_views += i
	} else {
		m.addunique_views = &i
	}
}

// AddedUniqueViews returns the value that was added to the "unique_views" field in this mutation.
func (m *URLStatMutation) AddedUniqueViews() (r int64, exists bool) {
	v := m.addunique_views
	if v == nil {
		return
	}
	return *v, true
}

// ResetUniqueViews resets all changes to the "unique_views" field.
func (m *URLStatMutation) ResetUniqueViews() {
	m.unique_views = nil
	m.addunique_views = nil
}

// SetBounceCount sets the "bounce_count" field.
func (m *URLStatMutation) SetBounceCount(i int64) {
	m.bounce_count = &i
	m.addbounce_count = nil
}

// BounceCount returns the value of the "bounce_count" field in the mutation.
func (m *URLStatMutation) BounceCount() (r int64, exists bool) {
	v := m.bounce_count
	if v == nil {
		return
	}
	return *v, true
}

// OldBounceCount returns the old "bounce_count" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldBounceCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBounceCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBounceCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBounceCount: %w", err)
	}
	return oldValue.BounceCount, nil
}

// AddBounceCount adds i to the "bounce_count" field.
func (m *URLStatMutation) AddBounceCount(i int64) {
	if m.addbounce_count != nil {
		*m.addbounce_count += i
	} else {
		m.addbounce_count = &i
	}
}

// AddedBounceCount returns the value that was added to the "bounce_count" field in this mutation.
func (m *URLStatMutation) AddedBounceCount() (r int64, exists bool) {
	v := m.addbounce_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetBounceCount resets all changes to the "bounce_count" field.
func (m *URLStatMutation) ResetBounceCount() {
	m.bounce_count = nil
	m.addbounce_count = nil
}

// SetAvgDuration sets the "avg_duration" field.
func (m *URLStatMutation) SetAvgDuration(f float64) {
	m.avg_duration = &f
	m.addavg_duration = nil
}

// AvgDuration returns the value of the "avg_duration" field in the mutation.
func (m *URLStatMutation) AvgDuration() (r float64, exists bool) {
	v := m.avg_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgDuration returns the old "avg_duration" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldAvgDuration(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgDuration: %w", err)
	}
	return oldValue.AvgDuration, nil
}

// AddAvgDuration adds f to the "avg_duration" field.
func (m *URLStatMutation) AddAvgDuration(f float64) {
	if m.addavg_duration != nil {
		*m.addavg_duration += f
	} else {
		m.addavg_duration = &f
	}
}

// AddedAvgDuration returns the value that was added to the "avg_duration" field in this mutation.
func (m *URLStatMutation) AddedAvgDuration() (r float64, exists bool) {
	v := m.addavg_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvgDuration resets all changes to the "avg_duration" field.
func (m *URLStatMutation) ResetAvgDuration() {
	m.avg_duration = nil
	m.addavg_duration = nil
}

// SetLastVisitedAt sets the "last_visited_at" field.
func (m *URLStatMutation) SetLastVisitedAt(t time.Time) {
	m.last_visited_at = &t
}

// LastVisitedAt returns the value of the "last_visited_at" field in the mutation.
func (m *URLStatMutation) LastVisitedAt() (r time.Time, exists bool) {
	v := m.last_visited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastVisitedAt returns the old "last_visited_at" field's value of the URLStat entity.
// If the URLStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLStatMutation) OldLastVisitedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastVisitedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastVisitedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastVisitedAt: %w", err)
	}
	return oldValue.LastVisitedAt, nil
}

// ClearLastVisitedAt clears the value of the "last_visited_at" field.
func (m *URLStatMutation) ClearLastVisitedAt() {
	m.last_visited_at = nil
	m.clearedFields[urlstat.FieldLastVisitedAt] = struct{}{}
}

// LastVisitedAtCleared returns if the "last_visited_at" field was cleared in this mutation.
func (m *URLStatMutation) LastVisitedAtCleared() bool {
	_, ok := m.clearedFields[urlstat.FieldLastVisitedAt]
	return ok
}

// ResetLastVisitedAt resets all changes to the "last_visited_at" field.
func (m *URLStatMutation) ResetLastVisitedAt() {
	m.last_visited_at = nil
	delete(m.clearedFields, urlstat.FieldLastVisitedAt)
}

// Where appends a list predicates to the URLStatMutation builder.
func (m *URLStatMutation) Where(ps ...predicate.URLStat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the URLStatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *URLStatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.URLStat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *URLStatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *URLStatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (URLStat).
func (m *URLStatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *URLStatMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, urlstat.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, urlstat.FieldUpdatedAt)
	}
	if m.url_path != nil {
		fields = append(fields, urlstat.FieldURLPath)
	}
	if m.page_title != nil {
		fields = append(fields, urlstat.FieldPageTitle)
	}
	if m.total_views != nil {
		fields = append(fields, urlstat.FieldTotalViews)
	}
	if m.unique_views != nil {
		fields = append(fields, urlstat.FieldUniqueViews)
	}
	if m.bounce_count != nil {
		fields = append(fields, urlstat.FieldBounceCount)
	}
	if m.avg_duration != nil {
		fields = append(fields, urlstat.FieldAvgDuration)
	}
	if m.last_visited_at != nil {
		fields = append(fields, urlstat.FieldLastVisitedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *URLStatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case urlstat.FieldCreatedAt:
		return m.CreatedAt()
	case urlstat.FieldUpdatedAt:
		return m.UpdatedAt()
	case urlstat.FieldURLPath:
		return m.URLPath()
	case urlstat.FieldPageTitle:
		return m.PageTitle()
	case urlstat.FieldTotalViews:
		return m.TotalViews()
	case urlstat.FieldUniqueViews:
		return m.UniqueViews()
	case urlstat.FieldBounceCount:
		return m.BounceCount()
	case urlstat.FieldAvgDuration:
		return m.AvgDuration()
	case urlstat.FieldLastVisitedAt:
		return m.LastVisitedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *URLStatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case urlstat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case urlstat.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case urlstat.FieldURLPath:
		return m.OldURLPath(ctx)
	case urlstat.FieldPageTitle:
		return m.OldPageTitle(ctx)
	case urlstat.FieldTotalViews:
		return m.OldTotalViews(ctx)
	case urlstat.FieldUniqueViews:
		return m.OldUniqueViews(ctx)
	case urlstat.FieldBounceCount:
		return m.OldBounceCount(ctx)
	case urlstat.FieldAvgDuration:
		return m.OldAvgDuration(ctx)
	case urlstat.FieldLastVisitedAt:
		return m.OldLastVisitedAt(ctx)
	}
	return nil, fmt.Errorf("unknown URLStat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *URLStatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case urlstat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case urlstat.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case urlstat.FieldURLPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLPath(v)
		return nil
	case urlstat.FieldPageTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageTitle(v)
		return nil
	case urlstat.FieldTotalViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalViews(v)
		return nil
	case urlstat.FieldUniqueViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniqueViews(v)
		return nil
	case urlstat.FieldBounceCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBounceCount(v)
		return nil
	case urlstat.FieldAvgDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgDuration(v)
		return nil
	case urlstat.FieldLastVisitedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastVisitedAt(v)
		return nil
	}
	return fmt.Errorf("unknown URLStat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *URLStatMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_views != nil {
		fields = append(fields, urlstat.FieldTotalViews)
	}
	if m.addunique_views != nil {
		fields = append(fields, urlstat.FieldUniqueViews)
	}
	if m.addbounce_count != nil {
		fields = append(fields, urlstat.FieldBounceCount)
	}
	if m.addavg_duration != nil {
		fields = append(fields, urlstat.FieldAvgDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *URLStatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case urlstat.FieldTotalViews:
		return m.AddedTotalViews()
	case urlstat.FieldUniqueViews:
		return m.AddedUniqueViews()
	case urlstat.FieldBounceCount:
		return m.AddedBounceCount()
	case urlstat.FieldAvgDuration:
		return m.AddedAvgDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *URLStatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case urlstat.FieldTotalViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalViews(v)
		return nil
	case urlstat.FieldUniqueViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUniqueViews(v)
		return nil
	case urlstat.FieldBounceCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBounceCount(v)
		return nil
	case urlstat.FieldAvgDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgDuration(v)
		return nil
	}
	return fmt.Errorf("unknown URLStat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *URLStatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(urlstat.FieldPageTitle) {
		fields = append(fields, urlstat.FieldPageTitle)
	}
	if m.FieldCleared(urlstat.FieldLastVisitedAt) {
		fields = append(fields, urlstat.FieldLastVisitedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *URLStatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *URLStatMutation) ClearField(name string) error {
	switch name {
	case urlstat.FieldPageTitle:
		m.ClearPageTitle()
		return nil
	case urlstat.FieldLastVisitedAt:
		m.ClearLastVisitedAt()
		return nil
	}
	return fmt.Errorf("unknown URLStat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *URLStatMutation) ResetField(name string) error {
	switch name {
	case urlstat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case urlstat.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case urlstat.FieldURLPath:
		m.ResetURLPath()
		return nil
	case urlstat.FieldPageTitle:
		m.ResetPageTitle()
		return nil
	case urlstat.FieldTotalViews:
		m.ResetTotalViews()
		return nil
	case urlstat.FieldUniqueViews:
		m.ResetUniqueViews()
		return nil
	case urlstat.FieldBounceCount:
		m.ResetBounceCount()
		return nil
	case urlstat.FieldAvgDuration:
		m.ResetAvgDuration()
		return nil
	case urlstat.FieldLastVisitedAt:
		m.ResetLastVisitedAt()
		return nil
	}
	return fmt.Errorf("unknown URLStat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *URLStatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *URLStatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *URLStatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *URLStatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *URLStatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *URLStatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *URLStatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown URLStat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *URLStatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown URLStat edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uint
	deleted_at              *time.Time
	created_at              *time.Time
	updated_at              *time.Time
	username                *string
	password_hash           *string
	nickname                *string
	avatar                  *string
	email                   *string
	last_login_at           *time.Time
	status                  *int
	addstatus               *int
	clearedFields           map[string]struct{}
	user_group              *uint
	cleareduser_group       bool
	files                   map[uint]struct{}
	removedfiles            map[uint]struct{}
	clearedfiles            bool
	comments                map[uint]struct{}
	removedcomments         map[uint]struct{}
	clearedcomments         bool
	installed_themes        map[uint]struct{}
	removedinstalled_themes map[uint]struct{}
	clearedinstalled_themes bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *UserMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[user.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *UserMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[user.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, user.FieldNickname)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetUserGroupID sets the "user_group" edge to the UserGroup entity by id.
func (m *UserMutation) SetUserGroupID(id uint) {
	m.user_group = &id
}

// ClearUserGroup clears the "user_group" edge to the UserGroup entity.
func (m *UserMutation) ClearUserGroup() {
	m.cleareduser_group = true
}

// UserGroupCleared reports if the "user_group" edge to the UserGroup entity was cleared.
func (m *UserMutation) UserGroupCleared() bool {
	return m.cleareduser_group
}

// UserGroupID returns the "user_group" edge ID in the mutation.
func (m *UserMutation) UserGroupID() (id uint, exists bool) {
	if m.user_group != nil {
		return *m.user_group, true
	}
	return
}

// UserGroupIDs returns the "user_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserGroupID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UserGroupIDs() (ids []uint) {
	if id := m.user_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserGroup resets all changes to the "user_group" edge.
func (m *UserMutation) ResetUserGroup() {
	m.user_group = nil
	m.cleareduser_group = false
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *UserMutation) AddFileIDs(ids ...uint) {
	if m.files == nil {
		m.files = make(map[uint]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *UserMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *UserMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *UserMutation) RemoveFileIDs(ids ...uint) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *UserMutation) RemovedFilesIDs() (ids []uint) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *UserMutation) FilesIDs() (ids []uint) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *UserMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...uint) {
	if m.comments == nil {
		m.comments = make(map[uint]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *UserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *UserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...uint) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *UserMutation) RemovedCommentsIDs() (ids []uint) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *UserMutation) CommentsIDs() (ids []uint) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddInstalledThemeIDs adds the "installed_themes" edge to the UserInstalledTheme entity by ids.
func (m *UserMutation) AddInstalledThemeIDs(ids ...uint) {
	if m.installed_themes == nil {
		m.installed_themes = make(map[uint]struct{})
	}
	for i := range ids {
		m.installed_themes[ids[i]] = struct{}{}
	}
}

// ClearInstalledThemes clears the "installed_themes" edge to the UserInstalledTheme entity.
func (m *UserMutation) ClearInstalledThemes() {
	m.clearedinstalled_themes = true
}

// InstalledThemesCleared reports if the "installed_themes" edge to the UserInstalledTheme entity was cleared.
func (m *UserMutation) InstalledThemesCleared() bool {
	return m.clearedinstalled_themes
}

// RemoveInstalledThemeIDs removes the "installed_themes" edge to the UserInstalledTheme entity by IDs.
func (m *UserMutation) RemoveInstalledThemeIDs(ids ...uint) {
	if m.removedinstalled_themes == nil {
		m.removedinstalled_themes = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.installed_themes, ids[i])
		m.removedinstalled_themes[ids[i]] = struct{}{}
	}
}

// RemovedInstalledThemes returns the removed IDs of the "installed_themes" edge to the UserInstalledTheme entity.
func (m *UserMutation) RemovedInstalledThemesIDs() (ids []uint) {
	for id := range m.removedinstalled_themes {
		ids = append(ids, id)
	}
	return
}

// InstalledThemesIDs returns the "installed_themes" edge IDs in the mutation.
func (m *UserMutation) InstalledThemesIDs() (ids []uint) {
	for id := range m.installed_themes {
		ids = append(ids, id)
	}
	return
}

// ResetInstalledThemes resets all changes to the "installed_themes" edge.
func (m *UserMutation) ResetInstalledThemes() {
	m.installed_themes = nil
	m.clearedinstalled_themes = false
	m.removedinstalled_themes = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldEmail:
		return m.Email()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldNickname) {
		fields = append(fields, user.FieldNickname)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldNickname:
		m.ClearNickname()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user_group != nil {
		edges = append(edges, user.EdgeUserGroup)
	}
	if m.files != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.comments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.installed_themes != nil {
		edges = append(edges, user.EdgeInstalledThemes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserGroup:
		if id := m.user_group; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInstalledThemes:
		ids := make([]ent.Value, 0, len(m.installed_themes))
		for id := range m.installed_themes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedfiles != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.removedcomments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.removedinstalled_themes != nil {
		edges = append(edges, user.EdgeInstalledThemes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInstalledThemes:
		ids := make([]ent.Value, 0, len(m.removedinstalled_themes))
		for id := range m.removedinstalled_themes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser_group {
		edges = append(edges, user.EdgeUserGroup)
	}
	if m.clearedfiles {
		edges = append(edges, user.EdgeFiles)
	}
	if m.clearedcomments {
		edges = append(edges, user.EdgeComments)
	}
	if m.clearedinstalled_themes {
		edges = append(edges, user.EdgeInstalledThemes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserGroup:
		return m.cleareduser_group
	case user.EdgeFiles:
		return m.clearedfiles
	case user.EdgeComments:
		return m.clearedcomments
	case user.EdgeInstalledThemes:
		return m.clearedinstalled_themes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeUserGroup:
		m.ClearUserGroup()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserGroup:
		m.ResetUserGroup()
		return nil
	case user.EdgeFiles:
		m.ResetFiles()
		return nil
	case user.EdgeComments:
		m.ResetComments()
		return nil
	case user.EdgeInstalledThemes:
		m.ResetInstalledThemes()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserGroupMutation represents an operation that mutates the UserGroup nodes in the graph.
type UserGroupMutation struct {
	config
	op             Op
	typ            string
	id             *uint
	deleted_at     *time.Time
	created_at     *time.Time
	updated_at     *time.Time
	name           *string
	description    *string
	permissions    *model.Boolset
	max_storage    *int64
	addmax_storage *int64
	speed_limit    *int64
	addspeed_limit *int64
	settings       **model.GroupSettings
	clearedFields  map[string]struct{}
	users          map[uint]struct{}
	removedusers   map[uint]struct{}
	clearedusers   bool
	done           bool
	oldValue       func(context.Context) (*UserGroup, error)
	predicates     []predicate.UserGroup
}

var _ ent.Mutation = (*UserGroupMutation)(nil)

// usergroupOption allows management of the mutation configuration using functional options.
type usergroupOption func(*UserGroupMutation)

// newUserGroupMutation creates new mutation for the UserGroup entity.
func newUserGroupMutation(c config, op Op, opts ...usergroupOption) *UserGroupMutation {
	m := &UserGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserGroupID sets the ID field of the mutation.
func withUserGroupID(id uint) usergroupOption {
	return func(m *UserGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *UserGroup
		)
		m.oldValue = func(ctx context.Context) (*UserGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserGroup sets the old UserGroup of the mutation.
func withUserGroup(node *UserGroup) usergroupOption {
	return func(m *UserGroupMutation) {
		m.oldValue = func(context.Context) (*UserGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserGroup entities.
func (m *UserGroupMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserGroupMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserGroupMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserGroupMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserGroupMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserGroupMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usergroup.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserGroupMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usergroup.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserGroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usergroup.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UserGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserGroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UserGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UserGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[usergroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UserGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[usergroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UserGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, usergroup.FieldDescription)
}

// SetPermissions sets the "permissions" field.
func (m *UserGroupMutation) SetPermissions(value model.Boolset) {
	m.permissions = &value
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *UserGroupMutation) Permissions() (r model.Boolset, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldPermissions(ctx context.Context) (v model.Boolset, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *UserGroupMutation) ResetPermissions() {
	m.permissions = nil
}

// SetMaxStorage sets the "max_storage" field.
func (m *UserGroupMutation) SetMaxStorage(i int64) {
	m.max_storage = &i
	m.addmax_storage = nil
}

// MaxStorage returns the value of the "max_storage" field in the mutation.
func (m *UserGroupMutation) MaxStorage() (r int64, exists bool) {
	v := m.max_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxStorage returns the old "max_storage" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldMaxStorage(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxStorage: %w", err)
	}
	return oldValue.MaxStorage, nil
}

// AddMaxStorage adds i to the "max_storage" field.
func (m *UserGroupMutation) AddMaxStorage(i int64) {
	if m.addmax_storage != nil {
		*m.addmax_storage += i
	} else {
		m.addmax_storage = &i
	}
}

// AddedMaxStorage returns the value that was added to the "max_storage" field in this mutation.
func (m *UserGroupMutation) AddedMaxStorage() (r int64, exists bool) {
	v := m.addmax_storage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxStorage resets all changes to the "max_storage" field.
func (m *UserGroupMutation) ResetMaxStorage() {
	m.max_storage = nil
	m.addmax_storage = nil
}

// SetSpeedLimit sets the "speed_limit" field.
func (m *UserGroupMutation) SetSpeedLimit(i int64) {
	m.speed_limit = &i
	m.addspeed_limit = nil
}

// SpeedLimit returns the value of the "speed_limit" field in the mutation.
func (m *UserGroupMutation) SpeedLimit() (r int64, exists bool) {
	v := m.speed_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeedLimit returns the old "speed_limit" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldSpeedLimit(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeedLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeedLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeedLimit: %w", err)
	}
	return oldValue.SpeedLimit, nil
}

// AddSpeedLimit adds i to the "speed_limit" field.
func (m *UserGroupMutation) AddSpeedLimit(i int64) {
	if m.addspeed_limit != nil {
		*m.addspeed_limit += i
	} else {
		m.addspeed_limit = &i
	}
}

// AddedSpeedLimit returns the value that was added to the "speed_limit" field in this mutation.
func (m *UserGroupMutation) AddedSpeedLimit() (r int64, exists bool) {
	v := m.addspeed_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpeedLimit resets all changes to the "speed_limit" field.
func (m *UserGroupMutation) ResetSpeedLimit() {
	m.speed_limit = nil
	m.addspeed_limit = nil
}

// SetSettings sets the "settings" field.
func (m *UserGroupMutation) SetSettings(ms *model.GroupSettings) {
	m.settings = &ms
}

// Settings returns the value of the "settings" field in the mutation.
func (m *UserGroupMutation) Settings() (r *model.GroupSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldSettings(ctx context.Context) (v *model.GroupSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *UserGroupMutation) ResetSettings() {
	m.settings = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *UserGroupMutation) AddUserIDs(ids ...uint) {
	if m.users == nil {
		m.users = make(map[uint]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *UserGroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *UserGroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *UserGroupMutation) RemoveUserIDs(ids ...uint) {
	if m.removedusers == nil {
		m.removedusers = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *UserGroupMutation) RemovedUsersIDs() (ids []uint) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *UserGroupMutation) UsersIDs() (ids []uint) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *UserGroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the UserGroupMutation builder.
func (m *UserGroupMutation) Where(ps ...predicate.UserGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserGroup).
func (m *UserGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserGroupMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.deleted_at != nil {
		fields = append(fields, usergroup.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, usergroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usergroup.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, usergroup.FieldName)
	}
	if m.description != nil {
		fields = append(fields, usergroup.FieldDescription)
	}
	if m.permissions != nil {
		fields = append(fields, usergroup.FieldPermissions)
	}
	if m.max_storage != nil {
		fields = append(fields, usergroup.FieldMaxStorage)
	}
	if m.speed_limit != nil {
		fields = append(fields, usergroup.FieldSpeedLimit)
	}
	if m.settings != nil {
		fields = append(fields, usergroup.FieldSettings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usergroup.FieldDeletedAt:
		return m.DeletedAt()
	case usergroup.FieldCreatedAt:
		return m.CreatedAt()
	case usergroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case usergroup.FieldName:
		return m.Name()
	case usergroup.FieldDescription:
		return m.Description()
	case usergroup.FieldPermissions:
		return m.Permissions()
	case usergroup.FieldMaxStorage:
		return m.MaxStorage()
	case usergroup.FieldSpeedLimit:
		return m.SpeedLimit()
	case usergroup.FieldSettings:
		return m.Settings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usergroup.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usergroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usergroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usergroup.FieldName:
		return m.OldName(ctx)
	case usergroup.FieldDescription:
		return m.OldDescription(ctx)
	case usergroup.FieldPermissions:
		return m.OldPermissions(ctx)
	case usergroup.FieldMaxStorage:
		return m.OldMaxStorage(ctx)
	case usergroup.FieldSpeedLimit:
		return m.OldSpeedLimit(ctx)
	case usergroup.FieldSettings:
		return m.OldSettings(ctx)
	}
	return nil, fmt.Errorf("unknown UserGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usergroup.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usergroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usergroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usergroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case usergroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case usergroup.FieldPermissions:
		v, ok := value.(model.Boolset)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case usergroup.FieldMaxStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxStorage(v)
		return nil
	case usergroup.FieldSpeedLimit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeedLimit(v)
		return nil
	case usergroup.FieldSettings:
		v, ok := value.(*model.GroupSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	}
	return fmt.Errorf("unknown UserGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserGroupMutation) AddedFields() []string {
	var fields []string
	if m.addmax_storage != nil {
		fields = append(fields, usergroup.FieldMaxStorage)
	}
	if m.addspeed_limit != nil {
		fields = append(fields, usergroup.FieldSpeedLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usergroup.FieldMaxStorage:
		return m.AddedMaxStorage()
	case usergroup.FieldSpeedLimit:
		return m.AddedSpeedLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usergroup.FieldMaxStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxStorage(v)
		return nil
	case usergroup.FieldSpeedLimit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeedLimit(v)
		return nil
	}
	return fmt.Errorf("unknown UserGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usergroup.FieldDeletedAt) {
		fields = append(fields, usergroup.FieldDeletedAt)
	}
	if m.FieldCleared(usergroup.FieldDescription) {
		fields = append(fields, usergroup.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserGroupMutation) ClearField(name string) error {
	switch name {
	case usergroup.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case usergroup.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown UserGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserGroupMutation) ResetField(name string) error {
	switch name {
	case usergroup.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usergroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usergroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usergroup.FieldName:
		m.ResetName()
		return nil
	case usergroup.FieldDescription:
		m.ResetDescription()
		return nil
	case usergroup.FieldPermissions:
		m.ResetPermissions()
		return nil
	case usergroup.FieldMaxStorage:
		m.ResetMaxStorage()
		return nil
	case usergroup.FieldSpeedLimit:
		m.ResetSpeedLimit()
		return nil
	case usergroup.FieldSettings:
		m.ResetSettings()
		return nil
	}
	return fmt.Errorf("unknown UserGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, usergroup.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usergroup.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, usergroup.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usergroup.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, usergroup.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case usergroup.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserGroupMutation) ResetEdge(name string) error {
	switch name {
	case usergroup.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown UserGroup edge %s", name)
}

// UserInstalledThemeMutation represents an operation that mutates the UserInstalledTheme nodes in the graph.
type UserInstalledThemeMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint
	deleted_at         *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	theme_name         *string
	theme_market_id    *int
	addtheme_market_id *int
	is_current         *bool
	install_time       *time.Time
	user_theme_config  *map[string]interface{}
	installed_version  *string
	clearedFields      map[string]struct{}
	user               *uint
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*UserInstalledTheme, error)
	predicates         []predicate.UserInstalledTheme
}

var _ ent.Mutation = (*UserInstalledThemeMutation)(nil)

// userinstalledthemeOption allows management of the mutation configuration using functional options.
type userinstalledthemeOption func(*UserInstalledThemeMutation)

// newUserInstalledThemeMutation creates new mutation for the UserInstalledTheme entity.
func newUserInstalledThemeMutation(c config, op Op, opts ...userinstalledthemeOption) *UserInstalledThemeMutation {
	m := &UserInstalledThemeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserInstalledTheme,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserInstalledThemeID sets the ID field of the mutation.
func withUserInstalledThemeID(id uint) userinstalledthemeOption {
	return func(m *UserInstalledThemeMutation) {
		var (
			err   error
			once  sync.Once
			value *UserInstalledTheme
		)
		m.oldValue = func(ctx context.Context) (*UserInstalledTheme, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserInstalledTheme.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserInstalledTheme sets the old UserInstalledTheme of the mutation.
func withUserInstalledTheme(node *UserInstalledTheme) userinstalledthemeOption {
	return func(m *UserInstalledThemeMutation) {
		m.oldValue = func(context.Context) (*UserInstalledTheme, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserInstalledThemeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserInstalledThemeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserInstalledTheme entities.
func (m *UserInstalledThemeMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserInstalledThemeMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserInstalledThemeMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserInstalledTheme.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserInstalledThemeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserInstalledThemeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserInstalledThemeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userinstalledtheme.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserInstalledThemeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userinstalledtheme.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserInstalledThemeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userinstalledtheme.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserInstalledThemeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserInstalledThemeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserInstalledThemeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserInstalledThemeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserInstalledThemeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserInstalledThemeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserInstalledThemeMutation) SetUserID(u uint) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserInstalledThemeMutation) UserID() (r uint, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldUserID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserInstalledThemeMutation) ResetUserID() {
	m.user = nil
}

// SetThemeName sets the "theme_name" field.
func (m *UserInstalledThemeMutation) SetThemeName(s string) {
	m.theme_name = &s
}

// ThemeName returns the value of the "theme_name" field in the mutation.
func (m *UserInstalledThemeMutation) ThemeName() (r string, exists bool) {
	v := m.theme_name
	if v == nil {
		return
	}
	return *v, true
}

// OldThemeName returns the old "theme_name" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldThemeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThemeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThemeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThemeName: %w", err)
	}
	return oldValue.ThemeName, nil
}

// ResetThemeName resets all changes to the "theme_name" field.
func (m *UserInstalledThemeMutation) ResetThemeName() {
	m.theme_name = nil
}

// SetThemeMarketID sets the "theme_market_id" field.
func (m *UserInstalledThemeMutation) SetThemeMarketID(i int) {
	m.theme_market_id = &i
	m.addtheme_market_id = nil
}

// ThemeMarketID returns the value of the "theme_market_id" field in the mutation.
func (m *UserInstalledThemeMutation) ThemeMarketID() (r int, exists bool) {
	v := m.theme_market_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThemeMarketID returns the old "theme_market_id" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldThemeMarketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThemeMarketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThemeMarketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThemeMarketID: %w", err)
	}
	return oldValue.ThemeMarketID, nil
}

// AddThemeMarketID adds i to the "theme_market_id" field.
func (m *UserInstalledThemeMutation) AddThemeMarketID(i int) {
	if m.addtheme_market_id != nil {
		*m.addtheme_market_id += i
	} else {
		m.addtheme_market_id = &i
	}
}

// AddedThemeMarketID returns the value that was added to the "theme_market_id" field in this mutation.
func (m *UserInstalledThemeMutation) AddedThemeMarketID() (r int, exists bool) {
	v := m.addtheme_market_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearThemeMarketID clears the value of the "theme_market_id" field.
func (m *UserInstalledThemeMutation) ClearThemeMarketID() {
	m.theme_market_id = nil
	m.addtheme_market_id = nil
	m.clearedFields[userinstalledtheme.FieldThemeMarketID] = struct{}{}
}

// ThemeMarketIDCleared returns if the "theme_market_id" field was cleared in this mutation.
func (m *UserInstalledThemeMutation) ThemeMarketIDCleared() bool {
	_, ok := m.clearedFields[userinstalledtheme.FieldThemeMarketID]
	return ok
}

// ResetThemeMarketID resets all changes to the "theme_market_id" field.
func (m *UserInstalledThemeMutation) ResetThemeMarketID() {
	m.theme_market_id = nil
	m.addtheme_market_id = nil
	delete(m.clearedFields, userinstalledtheme.FieldThemeMarketID)
}

// SetIsCurrent sets the "is_current" field.
func (m *UserInstalledThemeMutation) SetIsCurrent(b bool) {
	m.is_current = &b
}

// IsCurrent returns the value of the "is_current" field in the mutation.
func (m *UserInstalledThemeMutation) IsCurrent() (r bool, exists bool) {
	v := m.is_current
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCurrent returns the old "is_current" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldIsCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCurrent: %w", err)
	}
	return oldValue.IsCurrent, nil
}

// ResetIsCurrent resets all changes to the "is_current" field.
func (m *UserInstalledThemeMutation) ResetIsCurrent() {
	m.is_current = nil
}

// SetInstallTime sets the "install_time" field.
func (m *UserInstalledThemeMutation) SetInstallTime(t time.Time) {
	m.install_time = &t
}

// InstallTime returns the value of the "install_time" field in the mutation.
func (m *UserInstalledThemeMutation) InstallTime() (r time.Time, exists bool) {
	v := m.install_time
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallTime returns the old "install_time" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldInstallTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallTime: %w", err)
	}
	return oldValue.InstallTime, nil
}

// ResetInstallTime resets all changes to the "install_time" field.
func (m *UserInstalledThemeMutation) ResetInstallTime() {
	m.install_time = nil
}

// SetUserThemeConfig sets the "user_theme_config" field.
func (m *UserInstalledThemeMutation) SetUserThemeConfig(value map[string]interface{}) {
	m.user_theme_config = &value
}

// UserThemeConfig returns the value of the "user_theme_config" field in the mutation.
func (m *UserInstalledThemeMutation) UserThemeConfig() (r map[string]interface{}, exists bool) {
	v := m.user_theme_config
	if v == nil {
		return
	}
	return *v, true
}

// OldUserThemeConfig returns the old "user_theme_config" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldUserThemeConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserThemeConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserThemeConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserThemeConfig: %w", err)
	}
	return oldValue.UserThemeConfig, nil
}

// ClearUserThemeConfig clears the value of the "user_theme_config" field.
func (m *UserInstalledThemeMutation) ClearUserThemeConfig() {
	m.user_theme_config = nil
	m.clearedFields[userinstalledtheme.FieldUserThemeConfig] = struct{}{}
}

// UserThemeConfigCleared returns if the "user_theme_config" field was cleared in this mutation.
func (m *UserInstalledThemeMutation) UserThemeConfigCleared() bool {
	_, ok := m.clearedFields[userinstalledtheme.FieldUserThemeConfig]
	return ok
}

// ResetUserThemeConfig resets all changes to the "user_theme_config" field.
func (m *UserInstalledThemeMutation) ResetUserThemeConfig() {
	m.user_theme_config = nil
	delete(m.clearedFields, userinstalledtheme.FieldUserThemeConfig)
}

// SetInstalledVersion sets the "installed_version" field.
func (m *UserInstalledThemeMutation) SetInstalledVersion(s string) {
	m.installed_version = &s
}

// InstalledVersion returns the value of the "installed_version" field in the mutation.
func (m *UserInstalledThemeMutation) InstalledVersion() (r string, exists bool) {
	v := m.installed_version
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalledVersion returns the old "installed_version" field's value of the UserInstalledTheme entity.
// If the UserInstalledTheme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInstalledThemeMutation) OldInstalledVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalledVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalledVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalledVersion: %w", err)
	}
	return oldValue.InstalledVersion, nil
}

// ClearInstalledVersion clears the value of the "installed_version" field.
func (m *UserInstalledThemeMutation) ClearInstalledVersion() {
	m.installed_version = nil
	m.clearedFields[userinstalledtheme.FieldInstalledVersion] = struct{}{}
}

// InstalledVersionCleared returns if the "installed_version" field was cleared in this mutation.
func (m *UserInstalledThemeMutation) InstalledVersionCleared() bool {
	_, ok := m.clearedFields[userinstalledtheme.FieldInstalledVersion]
	return ok
}

// ResetInstalledVersion resets all changes to the "installed_version" field.
func (m *UserInstalledThemeMutation) ResetInstalledVersion() {
	m.installed_version = nil
	delete(m.clearedFields, userinstalledtheme.FieldInstalledVersion)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserInstalledThemeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userinstalledtheme.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserInstalledThemeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserInstalledThemeMutation) UserIDs() (ids []uint) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserInstalledThemeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserInstalledThemeMutation builder.
func (m *UserInstalledThemeMutation) Where(ps ...predicate.UserInstalledTheme) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserInstalledThemeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserInstalledThemeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserInstalledTheme, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserInstalledThemeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserInstalledThemeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserInstalledTheme).
func (m *UserInstalledThemeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserInstalledThemeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.deleted_at != nil {
		fields = append(fields, userinstalledtheme.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, userinstalledtheme.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userinstalledtheme.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userinstalledtheme.FieldUserID)
	}
	if m.theme_name != nil {
		fields = append(fields, userinstalledtheme.FieldThemeName)
	}
	if m.theme_market_id != nil {
		fields = append(fields, userinstalledtheme.FieldThemeMarketID)
	}
	if m.is_current != nil {
		fields = append(fields, userinstalledtheme.FieldIsCurrent)
	}
	if m.install_time != nil {
		fields = append(fields, userinstalledtheme.FieldInstallTime)
	}
	if m.user_theme_config != nil {
		fields = append(fields, userinstalledtheme.FieldUserThemeConfig)
	}
	if m.installed_version != nil {
		fields = append(fields, userinstalledtheme.FieldInstalledVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserInstalledThemeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userinstalledtheme.FieldDeletedAt:
		return m.DeletedAt()
	case userinstalledtheme.FieldCreatedAt:
		return m.CreatedAt()
	case userinstalledtheme.FieldUpdatedAt:
		return m.UpdatedAt()
	case userinstalledtheme.FieldUserID:
		return m.UserID()
	case userinstalledtheme.FieldThemeName:
		return m.ThemeName()
	case userinstalledtheme.FieldThemeMarketID:
		return m.ThemeMarketID()
	case userinstalledtheme.FieldIsCurrent:
		return m.IsCurrent()
	case userinstalledtheme.FieldInstallTime:
		return m.InstallTime()
	case userinstalledtheme.FieldUserThemeConfig:
		return m.UserThemeConfig()
	case userinstalledtheme.FieldInstalledVersion:
		return m.InstalledVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserInstalledThemeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userinstalledtheme.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userinstalledtheme.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userinstalledtheme.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userinstalledtheme.FieldUserID:
		return m.OldUserID(ctx)
	case userinstalledtheme.FieldThemeName:
		return m.OldThemeName(ctx)
	case userinstalledtheme.FieldThemeMarketID:
		return m.OldThemeMarketID(ctx)
	case userinstalledtheme.FieldIsCurrent:
		return m.OldIsCurrent(ctx)
	case userinstalledtheme.FieldInstallTime:
		return m.OldInstallTime(ctx)
	case userinstalledtheme.FieldUserThemeConfig:
		return m.OldUserThemeConfig(ctx)
	case userinstalledtheme.FieldInstalledVersion:
		return m.OldInstalledVersion(ctx)
	}
	return nil, fmt.Errorf("unknown UserInstalledTheme field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserInstalledThemeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userinstalledtheme.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userinstalledtheme.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userinstalledtheme.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userinstalledtheme.FieldUserID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userinstalledtheme.FieldThemeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThemeName(v)
		return nil
	case userinstalledtheme.FieldThemeMarketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThemeMarketID(v)
		return nil
	case userinstalledtheme.FieldIsCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCurrent(v)
		return nil
	case userinstalledtheme.FieldInstallTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallTime(v)
		return nil
	case userinstalledtheme.FieldUserThemeConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserThemeConfig(v)
		return nil
	case userinstalledtheme.FieldInstalledVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalledVersion(v)
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserInstalledThemeMutation) AddedFields() []string {
	var fields []string
	if m.addtheme_market_id != nil {
		fields = append(fields, userinstalledtheme.FieldThemeMarketID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserInstalledThemeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userinstalledtheme.FieldThemeMarketID:
		return m.AddedThemeMarketID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserInstalledThemeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userinstalledtheme.FieldThemeMarketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThemeMarketID(v)
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserInstalledThemeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userinstalledtheme.FieldDeletedAt) {
		fields = append(fields, userinstalledtheme.FieldDeletedAt)
	}
	if m.FieldCleared(userinstalledtheme.FieldThemeMarketID) {
		fields = append(fields, userinstalledtheme.FieldThemeMarketID)
	}
	if m.FieldCleared(userinstalledtheme.FieldUserThemeConfig) {
		fields = append(fields, userinstalledtheme.FieldUserThemeConfig)
	}
	if m.FieldCleared(userinstalledtheme.FieldInstalledVersion) {
		fields = append(fields, userinstalledtheme.FieldInstalledVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserInstalledThemeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserInstalledThemeMutation) ClearField(name string) error {
	switch name {
	case userinstalledtheme.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userinstalledtheme.FieldThemeMarketID:
		m.ClearThemeMarketID()
		return nil
	case userinstalledtheme.FieldUserThemeConfig:
		m.ClearUserThemeConfig()
		return nil
	case userinstalledtheme.FieldInstalledVersion:
		m.ClearInstalledVersion()
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserInstalledThemeMutation) ResetField(name string) error {
	switch name {
	case userinstalledtheme.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userinstalledtheme.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userinstalledtheme.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userinstalledtheme.FieldUserID:
		m.ResetUserID()
		return nil
	case userinstalledtheme.FieldThemeName:
		m.ResetThemeName()
		return nil
	case userinstalledtheme.FieldThemeMarketID:
		m.ResetThemeMarketID()
		return nil
	case userinstalledtheme.FieldIsCurrent:
		m.ResetIsCurrent()
		return nil
	case userinstalledtheme.FieldInstallTime:
		m.ResetInstallTime()
		return nil
	case userinstalledtheme.FieldUserThemeConfig:
		m.ResetUserThemeConfig()
		return nil
	case userinstalledtheme.FieldInstalledVersion:
		m.ResetInstalledVersion()
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserInstalledThemeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userinstalledtheme.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserInstalledThemeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userinstalledtheme.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserInstalledThemeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserInstalledThemeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserInstalledThemeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userinstalledtheme.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserInstalledThemeMutation) EdgeCleared(name string) bool {
	switch name {
	case userinstalledtheme.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserInstalledThemeMutation) ClearEdge(name string) error {
	switch name {
	case userinstalledtheme.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserInstalledThemeMutation) ResetEdge(name string) error {
	switch name {
	case userinstalledtheme.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserInstalledTheme edge %s", name)
}

// VisitorLogMutation represents an operation that mutates the VisitorLog nodes in the graph.
type VisitorLogMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	created_at    *time.Time
	visitor_id    *string
	session_id    *string
	ip_address    *string
	user_agent    *string
	referer       *string
	url_path      *string
	country       *string
	region        *string
	city          *string
	browser       *string
	os            *string
	device        *string
	duration      *int
	addduration   *int
	is_bounce     *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VisitorLog, error)
	predicates    []predicate.VisitorLog
}

var _ ent.Mutation = (*VisitorLogMutation)(nil)

// visitorlogOption allows management of the mutation configuration using functional options.
type visitorlogOption func(*VisitorLogMutation)

// newVisitorLogMutation creates new mutation for the VisitorLog entity.
func newVisitorLogMutation(c config, op Op, opts ...visitorlogOption) *VisitorLogMutation {
	m := &VisitorLogMutation{
		config:        c,
		op:            op,
		typ:           TypeVisitorLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVisitorLogID sets the ID field of the mutation.
func withVisitorLogID(id uint) visitorlogOption {
	return func(m *VisitorLogMutation) {
		var (
			err   error
			once  sync.Once
			value *VisitorLog
		)
		m.oldValue = func(ctx context.Context) (*VisitorLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VisitorLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVisitorLog sets the old VisitorLog of the mutation.
func withVisitorLog(node *VisitorLog) visitorlogOption {
	return func(m *VisitorLogMutation) {
		m.oldValue = func(context.Context) (*VisitorLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VisitorLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VisitorLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VisitorLog entities.
func (m *VisitorLogMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VisitorLogMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VisitorLogMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VisitorLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VisitorLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VisitorLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VisitorLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetVisitorID sets the "visitor_id" field.
func (m *VisitorLogMutation) SetVisitorID(s string) {
	m.visitor_id = &s
}

// VisitorID returns the value of the "visitor_id" field in the mutation.
func (m *VisitorLogMutation) VisitorID() (r string, exists bool) {
	v := m.visitor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVisitorID returns the old "visitor_id" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldVisitorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisitorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisitorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisitorID: %w", err)
	}
	return oldValue.VisitorID, nil
}

// ResetVisitorID resets all changes to the "visitor_id" field.
func (m *VisitorLogMutation) ResetVisitorID() {
	m.visitor_id = nil
}

// SetSessionID sets the "session_id" field.
func (m *VisitorLogMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *VisitorLogMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldSessionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ClearSessionID clears the value of the "session_id" field.
func (m *VisitorLogMutation) ClearSessionID() {
	m.session_id = nil
	m.clearedFields[visitorlog.FieldSessionID] = struct{}{}
}

// SessionIDCleared returns if the "session_id" field was cleared in this mutation.
func (m *VisitorLogMutation) SessionIDCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldSessionID]
	return ok
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *VisitorLogMutation) ResetSessionID() {
	m.session_id = nil
	delete(m.clearedFields, visitorlog.FieldSessionID)
}

// SetIPAddress sets the "ip_address" field.
func (m *VisitorLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *VisitorLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *VisitorLogMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *VisitorLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *VisitorLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *VisitorLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[visitorlog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *VisitorLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *VisitorLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, visitorlog.FieldUserAgent)
}

// SetReferer sets the "referer" field.
func (m *VisitorLogMutation) SetReferer(s string) {
	m.referer = &s
}

// Referer returns the value of the "referer" field in the mutation.
func (m *VisitorLogMutation) Referer() (r string, exists bool) {
	v := m.referer
	if v == nil {
		return
	}
	return *v, true
}

// OldReferer returns the old "referer" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldReferer(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferer: %w", err)
	}
	return oldValue.Referer, nil
}

// ClearReferer clears the value of the "referer" field.
func (m *VisitorLogMutation) ClearReferer() {
	m.referer = nil
	m.clearedFields[visitorlog.FieldReferer] = struct{}{}
}

// RefererCleared returns if the "referer" field was cleared in this mutation.
func (m *VisitorLogMutation) RefererCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldReferer]
	return ok
}

// ResetReferer resets all changes to the "referer" field.
func (m *VisitorLogMutation) ResetReferer() {
	m.referer = nil
	delete(m.clearedFields, visitorlog.FieldReferer)
}

// SetURLPath sets the "url_path" field.
func (m *VisitorLogMutation) SetURLPath(s string) {
	m.url_path = &s
}

// URLPath returns the value of the "url_path" field in the mutation.
func (m *VisitorLogMutation) URLPath() (r string, exists bool) {
	v := m.url_path
	if v == nil {
		return
	}
	return *v, true
}

// OldURLPath returns the old "url_path" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldURLPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLPath: %w", err)
	}
	return oldValue.URLPath, nil
}

// ResetURLPath resets all changes to the "url_path" field.
func (m *VisitorLogMutation) ResetURLPath() {
	m.url_path = nil
}

// SetCountry sets the "country" field.
func (m *VisitorLogMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *VisitorLogMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldCountry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *VisitorLogMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[visitorlog.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *VisitorLogMutation) CountryCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *VisitorLogMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, visitorlog.FieldCountry)
}

// SetRegion sets the "region" field.
func (m *VisitorLogMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *VisitorLogMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldRegion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ClearRegion clears the value of the "region" field.
func (m *VisitorLogMutation) ClearRegion() {
	m.region = nil
	m.clearedFields[visitorlog.FieldRegion] = struct{}{}
}

// RegionCleared returns if the "region" field was cleared in this mutation.
func (m *VisitorLogMutation) RegionCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldRegion]
	return ok
}

// ResetRegion resets all changes to the "region" field.
func (m *VisitorLogMutation) ResetRegion() {
	m.region = nil
	delete(m.clearedFields, visitorlog.FieldRegion)
}

// SetCity sets the "city" field.
func (m *VisitorLogMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *VisitorLogMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *VisitorLogMutation) ClearCity() {
	m.city = nil
	m.clearedFields[visitorlog.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *VisitorLogMutation) CityCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *VisitorLogMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, visitorlog.FieldCity)
}

// SetBrowser sets the "browser" field.
func (m *VisitorLogMutation) SetBrowser(s string) {
	m.browser = &s
}

// Browser returns the value of the "browser" field in the mutation.
func (m *VisitorLogMutation) Browser() (r string, exists bool) {
	v := m.browser
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowser returns the old "browser" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldBrowser(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowser: %w", err)
	}
	return oldValue.Browser, nil
}

// ClearBrowser clears the value of the "browser" field.
func (m *VisitorLogMutation) ClearBrowser() {
	m.browser = nil
	m.clearedFields[visitorlog.FieldBrowser] = struct{}{}
}

// BrowserCleared returns if the "browser" field was cleared in this mutation.
func (m *VisitorLogMutation) BrowserCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldBrowser]
	return ok
}

// ResetBrowser resets all changes to the "browser" field.
func (m *VisitorLogMutation) ResetBrowser() {
	m.browser = nil
	delete(m.clearedFields, visitorlog.FieldBrowser)
}

// SetOs sets the "os" field.
func (m *VisitorLogMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *VisitorLogMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldOs(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ClearOs clears the value of the "os" field.
func (m *VisitorLogMutation) ClearOs() {
	m.os = nil
	m.clearedFields[visitorlog.FieldOs] = struct{}{}
}

// OsCleared returns if the "os" field was cleared in this mutation.
func (m *VisitorLogMutation) OsCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldOs]
	return ok
}

// ResetOs resets all changes to the "os" field.
func (m *VisitorLogMutation) ResetOs() {
	m.os = nil
	delete(m.clearedFields, visitorlog.FieldOs)
}

// SetDevice sets the "device" field.
func (m *VisitorLogMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *VisitorLogMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldDevice(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ClearDevice clears the value of the "device" field.
func (m *VisitorLogMutation) ClearDevice() {
	m.device = nil
	m.clearedFields[visitorlog.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *VisitorLogMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[visitorlog.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *VisitorLogMutation) ResetDevice() {
	m.device = nil
	delete(m.clearedFields, visitorlog.FieldDevice)
}

// SetDuration sets the "duration" field.
func (m *VisitorLogMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *VisitorLogMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *VisitorLogMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *VisitorLogMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *VisitorLogMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetIsBounce sets the "is_bounce" field.
func (m *VisitorLogMutation) SetIsBounce(b bool) {
	m.is_bounce = &b
}

// IsBounce returns the value of the "is_bounce" field in the mutation.
func (m *VisitorLogMutation) IsBounce() (r bool, exists bool) {
	v := m.is_bounce
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBounce returns the old "is_bounce" field's value of the VisitorLog entity.
// If the VisitorLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorLogMutation) OldIsBounce(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBounce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBounce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBounce: %w", err)
	}
	return oldValue.IsBounce, nil
}

// ResetIsBounce resets all changes to the "is_bounce" field.
func (m *VisitorLogMutation) ResetIsBounce() {
	m.is_bounce = nil
}

// Where appends a list predicates to the VisitorLogMutation builder.
func (m *VisitorLogMutation) Where(ps ...predicate.VisitorLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VisitorLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VisitorLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VisitorLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VisitorLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VisitorLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VisitorLog).
func (m *VisitorLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VisitorLogMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, visitorlog.FieldCreatedAt)
	}
	if m.visitor_id != nil {
		fields = append(fields, visitorlog.FieldVisitorID)
	}
	if m.session_id != nil {
		fields = append(fields, visitorlog.FieldSessionID)
	}
	if m.ip_address != nil {
		fields = append(fields, visitorlog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, visitorlog.FieldUserAgent)
	}
	if m.referer != nil {
		fields = append(fields, visitorlog.FieldReferer)
	}
	if m.url_path != nil {
		fields = append(fields, visitorlog.FieldURLPath)
	}
	if m.country != nil {
		fields = append(fields, visitorlog.FieldCountry)
	}
	if m.region != nil {
		fields = append(fields, visitorlog.FieldRegion)
	}
	if m.city != nil {
		fields = append(fields, visitorlog.FieldCity)
	}
	if m.browser != nil {
		fields = append(fields, visitorlog.FieldBrowser)
	}
	if m.os != nil {
		fields = append(fields, visitorlog.FieldOs)
	}
	if m.device != nil {
		fields = append(fields, visitorlog.FieldDevice)
	}
	if m.duration != nil {
		fields = append(fields, visitorlog.FieldDuration)
	}
	if m.is_bounce != nil {
		fields = append(fields, visitorlog.FieldIsBounce)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VisitorLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case visitorlog.FieldCreatedAt:
		return m.CreatedAt()
	case visitorlog.FieldVisitorID:
		return m.VisitorID()
	case visitorlog.FieldSessionID:
		return m.SessionID()
	case visitorlog.FieldIPAddress:
		return m.IPAddress()
	case visitorlog.FieldUserAgent:
		return m.UserAgent()
	case visitorlog.FieldReferer:
		return m.Referer()
	case visitorlog.FieldURLPath:
		return m.URLPath()
	case visitorlog.FieldCountry:
		return m.Country()
	case visitorlog.FieldRegion:
		return m.Region()
	case visitorlog.FieldCity:
		return m.City()
	case visitorlog.FieldBrowser:
		return m.Browser()
	case visitorlog.FieldOs:
		return m.Os()
	case visitorlog.FieldDevice:
		return m.Device()
	case visitorlog.FieldDuration:
		return m.Duration()
	case visitorlog.FieldIsBounce:
		return m.IsBounce()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VisitorLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case visitorlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case visitorlog.FieldVisitorID:
		return m.OldVisitorID(ctx)
	case visitorlog.FieldSessionID:
		return m.OldSessionID(ctx)
	case visitorlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case visitorlog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case visitorlog.FieldReferer:
		return m.OldReferer(ctx)
	case visitorlog.FieldURLPath:
		return m.OldURLPath(ctx)
	case visitorlog.FieldCountry:
		return m.OldCountry(ctx)
	case visitorlog.FieldRegion:
		return m.OldRegion(ctx)
	case visitorlog.FieldCity:
		return m.OldCity(ctx)
	case visitorlog.FieldBrowser:
		return m.OldBrowser(ctx)
	case visitorlog.FieldOs:
		return m.OldOs(ctx)
	case visitorlog.FieldDevice:
		return m.OldDevice(ctx)
	case visitorlog.FieldDuration:
		return m.OldDuration(ctx)
	case visitorlog.FieldIsBounce:
		return m.OldIsBounce(ctx)
	}
	return nil, fmt.Errorf("unknown VisitorLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitorLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case visitorlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case visitorlog.FieldVisitorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisitorID(v)
		return nil
	case visitorlog.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case visitorlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case visitorlog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case visitorlog.FieldReferer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferer(v)
		return nil
	case visitorlog.FieldURLPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLPath(v)
		return nil
	case visitorlog.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case visitorlog.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case visitorlog.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case visitorlog.FieldBrowser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowser(v)
		return nil
	case visitorlog.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case visitorlog.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case visitorlog.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case visitorlog.FieldIsBounce:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBounce(v)
		return nil
	}
	return fmt.Errorf("unknown VisitorLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VisitorLogMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, visitorlog.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VisitorLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case visitorlog.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitorLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case visitorlog.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown VisitorLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VisitorLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(visitorlog.FieldSessionID) {
		fields = append(fields, visitorlog.FieldSessionID)
	}
	if m.FieldCleared(visitorlog.FieldUserAgent) {
		fields = append(fields, visitorlog.FieldUserAgent)
	}
	if m.FieldCleared(visitorlog.FieldReferer) {
		fields = append(fields, visitorlog.FieldReferer)
	}
	if m.FieldCleared(visitorlog.FieldCountry) {
		fields = append(fields, visitorlog.FieldCountry)
	}
	if m.FieldCleared(visitorlog.FieldRegion) {
		fields = append(fields, visitorlog.FieldRegion)
	}
	if m.FieldCleared(visitorlog.FieldCity) {
		fields = append(fields, visitorlog.FieldCity)
	}
	if m.FieldCleared(visitorlog.FieldBrowser) {
		fields = append(fields, visitorlog.FieldBrowser)
	}
	if m.FieldCleared(visitorlog.FieldOs) {
		fields = append(fields, visitorlog.FieldOs)
	}
	if m.FieldCleared(visitorlog.FieldDevice) {
		fields = append(fields, visitorlog.FieldDevice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VisitorLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VisitorLogMutation) ClearField(name string) error {
	switch name {
	case visitorlog.FieldSessionID:
		m.ClearSessionID()
		return nil
	case visitorlog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case visitorlog.FieldReferer:
		m.ClearReferer()
		return nil
	case visitorlog.FieldCountry:
		m.ClearCountry()
		return nil
	case visitorlog.FieldRegion:
		m.ClearRegion()
		return nil
	case visitorlog.FieldCity:
		m.ClearCity()
		return nil
	case visitorlog.FieldBrowser:
		m.ClearBrowser()
		return nil
	case visitorlog.FieldOs:
		m.ClearOs()
		return nil
	case visitorlog.FieldDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown VisitorLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VisitorLogMutation) ResetField(name string) error {
	switch name {
	case visitorlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case visitorlog.FieldVisitorID:
		m.ResetVisitorID()
		return nil
	case visitorlog.FieldSessionID:
		m.ResetSessionID()
		return nil
	case visitorlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case visitorlog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case visitorlog.FieldReferer:
		m.ResetReferer()
		return nil
	case visitorlog.FieldURLPath:
		m.ResetURLPath()
		return nil
	case visitorlog.FieldCountry:
		m.ResetCountry()
		return nil
	case visitorlog.FieldRegion:
		m.ResetRegion()
		return nil
	case visitorlog.FieldCity:
		m.ResetCity()
		return nil
	case visitorlog.FieldBrowser:
		m.ResetBrowser()
		return nil
	case visitorlog.FieldOs:
		m.ResetOs()
		return nil
	case visitorlog.FieldDevice:
		m.ResetDevice()
		return nil
	case visitorlog.FieldDuration:
		m.ResetDuration()
		return nil
	case visitorlog.FieldIsBounce:
		m.ResetIsBounce()
		return nil
	}
	return fmt.Errorf("unknown VisitorLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VisitorLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VisitorLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VisitorLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VisitorLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VisitorLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VisitorLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VisitorLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VisitorLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VisitorLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VisitorLog edge %s", name)
}

// VisitorStatMutation represents an operation that mutates the VisitorStat nodes in the graph.
type VisitorStatMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint
	created_at         *time.Time
	updated_at         *time.Time
	date               *time.Time
	unique_visitors    *int64
	addunique_visitors *int64
	total_views        *int64
	addtotal_views     *int64
	page_views         *int64
	addpage_views      *int64
	bounce_count       *int64
	addbounce_count    *int64
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*VisitorStat, error)
	predicates         []predicate.VisitorStat
}

var _ ent.Mutation = (*VisitorStatMutation)(nil)

// visitorstatOption allows management of the mutation configuration using functional options.
type visitorstatOption func(*VisitorStatMutation)

// newVisitorStatMutation creates new mutation for the VisitorStat entity.
func newVisitorStatMutation(c config, op Op, opts ...visitorstatOption) *VisitorStatMutation {
	m := &VisitorStatMutation{
		config:        c,
		op:            op,
		typ:           TypeVisitorStat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVisitorStatID sets the ID field of the mutation.
func withVisitorStatID(id uint) visitorstatOption {
	return func(m *VisitorStatMutation) {
		var (
			err   error
			once  sync.Once
			value *VisitorStat
		)
		m.oldValue = func(ctx context.Context) (*VisitorStat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VisitorStat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVisitorStat sets the old VisitorStat of the mutation.
func withVisitorStat(node *VisitorStat) visitorstatOption {
	return func(m *VisitorStatMutation) {
		m.oldValue = func(context.Context) (*VisitorStat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VisitorStatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VisitorStatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VisitorStat entities.
func (m *VisitorStatMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VisitorStatMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VisitorStatMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VisitorStat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VisitorStatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VisitorStatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VisitorStatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VisitorStatMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VisitorStatMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VisitorStatMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDate sets the "date" field.
func (m *VisitorStatMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *VisitorStatMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *VisitorStatMutation) ResetDate() {
	m.date = nil
}

// SetUniqueVisitors sets the "unique_visitors" field.
func (m *VisitorStatMutation) SetUniqueVisitors(i int64) {
	m.unique_visitors = &i
	m.addunique_visitors = nil
}

// UniqueVisitors returns the value of the "unique_visitors" field in the mutation.
func (m *VisitorStatMutation) UniqueVisitors() (r int64, exists bool) {
	v := m.unique_visitors
	if v == nil {
		return
	}
	return *v, true
}

// OldUniqueVisitors returns the old "unique_visitors" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldUniqueVisitors(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniqueVisitors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniqueVisitors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniqueVisitors: %w", err)
	}
	return oldValue.UniqueVisitors, nil
}

// AddUniqueVisitors adds i to the "unique_visitors" field.
func (m *VisitorStatMutation) AddUniqueVisitors(i int64) {
	if m.addunique_visitors != nil {
		*m.addunique_visitors += i
	} else {
		m.addunique_visitors = &i
	}
}

// AddedUniqueVisitors returns the value that was added to the "unique_visitors" field in this mutation.
func (m *VisitorStatMutation) AddedUniqueVisitors() (r int64, exists bool) {
	v := m.addunique_visitors
	if v == nil {
		return
	}
	return *v, true
}

// ResetUniqueVisitors resets all changes to the "unique_visitors" field.
func (m *VisitorStatMutation) ResetUniqueVisitors() {
	m.unique_visitors = nil
	m.addunique_visitors = nil
}

// SetTotalViews sets the "total_views" field.
func (m *VisitorStatMutation) SetTotalViews(i int64) {
	m.total_views = &i
	m.addtotal_views = nil
}

// TotalViews returns the value of the "total_views" field in the mutation.
func (m *VisitorStatMutation) TotalViews() (r int64, exists bool) {
	v := m.total_views
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalViews returns the old "total_views" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldTotalViews(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalViews: %w", err)
	}
	return oldValue.TotalViews, nil
}

// AddTotalViews adds i to the "total_views" field.
func (m *VisitorStatMutation) AddTotalViews(i int64) {
	if m.addtotal_views != nil {
		*m.addtotal_views += i
	} else {
		m.addtotal_views = &i
	}
}

// AddedTotalViews returns the value that was added to the "total_views" field in this mutation.
func (m *VisitorStatMutation) AddedTotalViews() (r int64, exists bool) {
	v := m.addtotal_views
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalViews resets all changes to the "total_views" field.
func (m *VisitorStatMutation) ResetTotalViews() {
	m.total_views = nil
	m.addtotal_views = nil
}

// SetPageViews sets the "page_views" field.
func (m *VisitorStatMutation) SetPageViews(i int64) {
	m.page_views = &i
	m.addpage_views = nil
}

// PageViews returns the value of the "page_views" field in the mutation.
func (m *VisitorStatMutation) PageViews() (r int64, exists bool) {
	v := m.page_views
	if v == nil {
		return
	}
	return *v, true
}

// OldPageViews returns the old "page_views" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldPageViews(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageViews: %w", err)
	}
	return oldValue.PageViews, nil
}

// AddPageViews adds i to the "page_views" field.
func (m *VisitorStatMutation) AddPageViews(i int64) {
	if m.addpage_views != nil {
		*m.addpage_views += i
	} else {
		m.addpage_views = &i
	}
}

// AddedPageViews returns the value that was added to the "page_views" field in this mutation.
func (m *VisitorStatMutation) AddedPageViews() (r int64, exists bool) {
	v := m.addpage_views
	if v == nil {
		return
	}
	return *v, true
}

// ResetPageViews resets all changes to the "page_views" field.
func (m *VisitorStatMutation) ResetPageViews() {
	m.page_views = nil
	m.addpage_views = nil
}

// SetBounceCount sets the "bounce_count" field.
func (m *VisitorStatMutation) SetBounceCount(i int64) {
	m.bounce_count = &i
	m.addbounce_count = nil
}

// BounceCount returns the value of the "bounce_count" field in the mutation.
func (m *VisitorStatMutation) BounceCount() (r int64, exists bool) {
	v := m.bounce_count
	if v == nil {
		return
	}
	return *v, true
}

// OldBounceCount returns the old "bounce_count" field's value of the VisitorStat entity.
// If the VisitorStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitorStatMutation) OldBounceCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBounceCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBounceCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBounceCount: %w", err)
	}
	return oldValue.BounceCount, nil
}

// AddBounceCount adds i to the "bounce_count" field.
func (m *VisitorStatMutation) AddBounceCount(i int64) {
	if m.addbounce_count != nil {
		*m.addbounce_count += i
	} else {
		m.addbounce_count = &i
	}
}

// AddedBounceCount returns the value that was added to the "bounce_count" field in this mutation.
func (m *VisitorStatMutation) AddedBounceCount() (r int64, exists bool) {
	v := m.addbounce_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetBounceCount resets all changes to the "bounce_count" field.
func (m *VisitorStatMutation) ResetBounceCount() {
	m.bounce_count = nil
	m.addbounce_count = nil
}

// Where appends a list predicates to the VisitorStatMutation builder.
func (m *VisitorStatMutation) Where(ps ...predicate.VisitorStat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VisitorStatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VisitorStatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VisitorStat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VisitorStatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VisitorStatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VisitorStat).
func (m *VisitorStatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VisitorStatMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, visitorstat.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, visitorstat.FieldUpdatedAt)
	}
	if m.date != nil {
		fields = append(fields, visitorstat.FieldDate)
	}
	if m.unique_visitors != nil {
		fields = append(fields, visitorstat.FieldUniqueVisitors)
	}
	if m.total_views != nil {
		fields = append(fields, visitorstat.FieldTotalViews)
	}
	if m.page_views != nil {
		fields = append(fields, visitorstat.FieldPageViews)
	}
	if m.bounce_count != nil {
		fields = append(fields, visitorstat.FieldBounceCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VisitorStatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case visitorstat.FieldCreatedAt:
		return m.CreatedAt()
	case visitorstat.FieldUpdatedAt:
		return m.UpdatedAt()
	case visitorstat.FieldDate:
		return m.Date()
	case visitorstat.FieldUniqueVisitors:
		return m.UniqueVisitors()
	case visitorstat.FieldTotalViews:
		return m.TotalViews()
	case visitorstat.FieldPageViews:
		return m.PageViews()
	case visitorstat.FieldBounceCount:
		return m.BounceCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VisitorStatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case visitorstat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case visitorstat.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case visitorstat.FieldDate:
		return m.OldDate(ctx)
	case visitorstat.FieldUniqueVisitors:
		return m.OldUniqueVisitors(ctx)
	case visitorstat.FieldTotalViews:
		return m.OldTotalViews(ctx)
	case visitorstat.FieldPageViews:
		return m.OldPageViews(ctx)
	case visitorstat.FieldBounceCount:
		return m.OldBounceCount(ctx)
	}
	return nil, fmt.Errorf("unknown VisitorStat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitorStatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case visitorstat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case visitorstat.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case visitorstat.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case visitorstat.FieldUniqueVisitors:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniqueVisitors(v)
		return nil
	case visitorstat.FieldTotalViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalViews(v)
		return nil
	case visitorstat.FieldPageViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageViews(v)
		return nil
	case visitorstat.FieldBounceCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBounceCount(v)
		return nil
	}
	return fmt.Errorf("unknown VisitorStat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VisitorStatMutation) AddedFields() []string {
	var fields []string
	if m.addunique_visitors != nil {
		fields = append(fields, visitorstat.FieldUniqueVisitors)
	}
	if m.addtotal_views != nil {
		fields = append(fields, visitorstat.FieldTotalViews)
	}
	if m.addpage_views != nil {
		fields = append(fields, visitorstat.FieldPageViews)
	}
	if m.addbounce_count != nil {
		fields = append(fields, visitorstat.FieldBounceCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VisitorStatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case visitorstat.FieldUniqueVisitors:
		return m.AddedUniqueVisitors()
	case visitorstat.FieldTotalViews:
		return m.AddedTotalViews()
	case visitorstat.FieldPageViews:
		return m.AddedPageViews()
	case visitorstat.FieldBounceCount:
		return m.AddedBounceCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitorStatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case visitorstat.FieldUniqueVisitors:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUniqueVisitors(v)
		return nil
	case visitorstat.FieldTotalViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalViews(v)
		return nil
	case visitorstat.FieldPageViews:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPageViews(v)
		return nil
	case visitorstat.FieldBounceCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBounceCount(v)
		return nil
	}
	return fmt.Errorf("unknown VisitorStat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VisitorStatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VisitorStatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VisitorStatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VisitorStat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VisitorStatMutation) ResetField(name string) error {
	switch name {
	case visitorstat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case visitorstat.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case visitorstat.FieldDate:
		m.ResetDate()
		return nil
	case visitorstat.FieldUniqueVisitors:
		m.ResetUniqueVisitors()
		return nil
	case visitorstat.FieldTotalViews:
		m.ResetTotalViews()
		return nil
	case visitorstat.FieldPageViews:
		m.ResetPageViews()
		return nil
	case visitorstat.FieldBounceCount:
		m.ResetBounceCount()
		return nil
	}
	return fmt.Errorf("unknown VisitorStat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VisitorStatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VisitorStatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VisitorStatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VisitorStatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VisitorStatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VisitorStatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VisitorStatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VisitorStat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VisitorStatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VisitorStat edge %s", name)
}
