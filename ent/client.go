// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/anzhiyu-c/anheyu-app/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/anzhiyu-c/anheyu-app/ent/album"
	"github.com/anzhiyu-c/anheyu-app/ent/article"
	"github.com/anzhiyu-c/anheyu-app/ent/comment"
	"github.com/anzhiyu-c/anheyu-app/ent/directlink"
	"github.com/anzhiyu-c/anheyu-app/ent/entity"
	"github.com/anzhiyu-c/anheyu-app/ent/file"
	"github.com/anzhiyu-c/anheyu-app/ent/fileentity"
	"github.com/anzhiyu-c/anheyu-app/ent/link"
	"github.com/anzhiyu-c/anheyu-app/ent/linkcategory"
	"github.com/anzhiyu-c/anheyu-app/ent/linktag"
	"github.com/anzhiyu-c/anheyu-app/ent/metadata"
	"github.com/anzhiyu-c/anheyu-app/ent/notificationtype"
	"github.com/anzhiyu-c/anheyu-app/ent/page"
	"github.com/anzhiyu-c/anheyu-app/ent/postcategory"
	"github.com/anzhiyu-c/anheyu-app/ent/posttag"
	"github.com/anzhiyu-c/anheyu-app/ent/setting"
	"github.com/anzhiyu-c/anheyu-app/ent/storagepolicy"
	"github.com/anzhiyu-c/anheyu-app/ent/tag"
	"github.com/anzhiyu-c/anheyu-app/ent/urlstat"
	"github.com/anzhiyu-c/anheyu-app/ent/user"
	"github.com/anzhiyu-c/anheyu-app/ent/usergroup"
	"github.com/anzhiyu-c/anheyu-app/ent/userinstalledtheme"
	"github.com/anzhiyu-c/anheyu-app/ent/usernotificationconfig"
	"github.com/anzhiyu-c/anheyu-app/ent/visitorlog"
	"github.com/anzhiyu-c/anheyu-app/ent/visitorstat"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Album is the client for interacting with the Album builders.
	Album *AlbumClient
	// Article is the client for interacting with the Article builders.
	Article *ArticleClient
	// Comment is the client for interacting with the Comment builders.
	Comment *CommentClient
	// DirectLink is the client for interacting with the DirectLink builders.
	DirectLink *DirectLinkClient
	// Entity is the client for interacting with the Entity builders.
	Entity *EntityClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// FileEntity is the client for interacting with the FileEntity builders.
	FileEntity *FileEntityClient
	// Link is the client for interacting with the Link builders.
	Link *LinkClient
	// LinkCategory is the client for interacting with the LinkCategory builders.
	LinkCategory *LinkCategoryClient
	// LinkTag is the client for interacting with the LinkTag builders.
	LinkTag *LinkTagClient
	// Metadata is the client for interacting with the Metadata builders.
	Metadata *MetadataClient
	// NotificationType is the client for interacting with the NotificationType builders.
	NotificationType *NotificationTypeClient
	// Page is the client for interacting with the Page builders.
	Page *PageClient
	// PostCategory is the client for interacting with the PostCategory builders.
	PostCategory *PostCategoryClient
	// PostTag is the client for interacting with the PostTag builders.
	PostTag *PostTagClient
	// Setting is the client for interacting with the Setting builders.
	Setting *SettingClient
	// StoragePolicy is the client for interacting with the StoragePolicy builders.
	StoragePolicy *StoragePolicyClient
	// Tag is the client for interacting with the Tag builders.
	Tag *TagClient
	// URLStat is the client for interacting with the URLStat builders.
	URLStat *URLStatClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserGroup is the client for interacting with the UserGroup builders.
	UserGroup *UserGroupClient
	// UserInstalledTheme is the client for interacting with the UserInstalledTheme builders.
	UserInstalledTheme *UserInstalledThemeClient
	// UserNotificationConfig is the client for interacting with the UserNotificationConfig builders.
	UserNotificationConfig *UserNotificationConfigClient
	// VisitorLog is the client for interacting with the VisitorLog builders.
	VisitorLog *VisitorLogClient
	// VisitorStat is the client for interacting with the VisitorStat builders.
	VisitorStat *VisitorStatClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Album = NewAlbumClient(c.config)
	c.Article = NewArticleClient(c.config)
	c.Comment = NewCommentClient(c.config)
	c.DirectLink = NewDirectLinkClient(c.config)
	c.Entity = NewEntityClient(c.config)
	c.File = NewFileClient(c.config)
	c.FileEntity = NewFileEntityClient(c.config)
	c.Link = NewLinkClient(c.config)
	c.LinkCategory = NewLinkCategoryClient(c.config)
	c.LinkTag = NewLinkTagClient(c.config)
	c.Metadata = NewMetadataClient(c.config)
	c.NotificationType = NewNotificationTypeClient(c.config)
	c.Page = NewPageClient(c.config)
	c.PostCategory = NewPostCategoryClient(c.config)
	c.PostTag = NewPostTagClient(c.config)
	c.Setting = NewSettingClient(c.config)
	c.StoragePolicy = NewStoragePolicyClient(c.config)
	c.Tag = NewTagClient(c.config)
	c.URLStat = NewURLStatClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserGroup = NewUserGroupClient(c.config)
	c.UserInstalledTheme = NewUserInstalledThemeClient(c.config)
	c.UserNotificationConfig = NewUserNotificationConfigClient(c.config)
	c.VisitorLog = NewVisitorLogClient(c.config)
	c.VisitorStat = NewVisitorStatClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Album:                  NewAlbumClient(cfg),
		Article:                NewArticleClient(cfg),
		Comment:                NewCommentClient(cfg),
		DirectLink:             NewDirectLinkClient(cfg),
		Entity:                 NewEntityClient(cfg),
		File:                   NewFileClient(cfg),
		FileEntity:             NewFileEntityClient(cfg),
		Link:                   NewLinkClient(cfg),
		LinkCategory:           NewLinkCategoryClient(cfg),
		LinkTag:                NewLinkTagClient(cfg),
		Metadata:               NewMetadataClient(cfg),
		NotificationType:       NewNotificationTypeClient(cfg),
		Page:                   NewPageClient(cfg),
		PostCategory:           NewPostCategoryClient(cfg),
		PostTag:                NewPostTagClient(cfg),
		Setting:                NewSettingClient(cfg),
		StoragePolicy:          NewStoragePolicyClient(cfg),
		Tag:                    NewTagClient(cfg),
		URLStat:                NewURLStatClient(cfg),
		User:                   NewUserClient(cfg),
		UserGroup:              NewUserGroupClient(cfg),
		UserInstalledTheme:     NewUserInstalledThemeClient(cfg),
		UserNotificationConfig: NewUserNotificationConfigClient(cfg),
		VisitorLog:             NewVisitorLogClient(cfg),
		VisitorStat:            NewVisitorStatClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Album:                  NewAlbumClient(cfg),
		Article:                NewArticleClient(cfg),
		Comment:                NewCommentClient(cfg),
		DirectLink:             NewDirectLinkClient(cfg),
		Entity:                 NewEntityClient(cfg),
		File:                   NewFileClient(cfg),
		FileEntity:             NewFileEntityClient(cfg),
		Link:                   NewLinkClient(cfg),
		LinkCategory:           NewLinkCategoryClient(cfg),
		LinkTag:                NewLinkTagClient(cfg),
		Metadata:               NewMetadataClient(cfg),
		NotificationType:       NewNotificationTypeClient(cfg),
		Page:                   NewPageClient(cfg),
		PostCategory:           NewPostCategoryClient(cfg),
		PostTag:                NewPostTagClient(cfg),
		Setting:                NewSettingClient(cfg),
		StoragePolicy:          NewStoragePolicyClient(cfg),
		Tag:                    NewTagClient(cfg),
		URLStat:                NewURLStatClient(cfg),
		User:                   NewUserClient(cfg),
		UserGroup:              NewUserGroupClient(cfg),
		UserInstalledTheme:     NewUserInstalledThemeClient(cfg),
		UserNotificationConfig: NewUserNotificationConfigClient(cfg),
		VisitorLog:             NewVisitorLogClient(cfg),
		VisitorStat:            NewVisitorStatClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Album.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Album, c.Article, c.Comment, c.DirectLink, c.Entity, c.File, c.FileEntity,
		c.Link, c.LinkCategory, c.LinkTag, c.Metadata, c.NotificationType, c.Page,
		c.PostCategory, c.PostTag, c.Setting, c.StoragePolicy, c.Tag, c.URLStat,
		c.User, c.UserGroup, c.UserInstalledTheme, c.UserNotificationConfig,
		c.VisitorLog, c.VisitorStat,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Album, c.Article, c.Comment, c.DirectLink, c.Entity, c.File, c.FileEntity,
		c.Link, c.LinkCategory, c.LinkTag, c.Metadata, c.NotificationType, c.Page,
		c.PostCategory, c.PostTag, c.Setting, c.StoragePolicy, c.Tag, c.URLStat,
		c.User, c.UserGroup, c.UserInstalledTheme, c.UserNotificationConfig,
		c.VisitorLog, c.VisitorStat,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AlbumMutation:
		return c.Album.mutate(ctx, m)
	case *ArticleMutation:
		return c.Article.mutate(ctx, m)
	case *CommentMutation:
		return c.Comment.mutate(ctx, m)
	case *DirectLinkMutation:
		return c.DirectLink.mutate(ctx, m)
	case *EntityMutation:
		return c.Entity.mutate(ctx, m)
	case *FileMutation:
		return c.File.mutate(ctx, m)
	case *FileEntityMutation:
		return c.FileEntity.mutate(ctx, m)
	case *LinkMutation:
		return c.Link.mutate(ctx, m)
	case *LinkCategoryMutation:
		return c.LinkCategory.mutate(ctx, m)
	case *LinkTagMutation:
		return c.LinkTag.mutate(ctx, m)
	case *MetadataMutation:
		return c.Metadata.mutate(ctx, m)
	case *NotificationTypeMutation:
		return c.NotificationType.mutate(ctx, m)
	case *PageMutation:
		return c.Page.mutate(ctx, m)
	case *PostCategoryMutation:
		return c.PostCategory.mutate(ctx, m)
	case *PostTagMutation:
		return c.PostTag.mutate(ctx, m)
	case *SettingMutation:
		return c.Setting.mutate(ctx, m)
	case *StoragePolicyMutation:
		return c.StoragePolicy.mutate(ctx, m)
	case *TagMutation:
		return c.Tag.mutate(ctx, m)
	case *URLStatMutation:
		return c.URLStat.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserGroupMutation:
		return c.UserGroup.mutate(ctx, m)
	case *UserInstalledThemeMutation:
		return c.UserInstalledTheme.mutate(ctx, m)
	case *UserNotificationConfigMutation:
		return c.UserNotificationConfig.mutate(ctx, m)
	case *VisitorLogMutation:
		return c.VisitorLog.mutate(ctx, m)
	case *VisitorStatMutation:
		return c.VisitorStat.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AlbumClient is a client for the Album schema.
type AlbumClient struct {
	config
}

// NewAlbumClient returns a client for the Album from the given config.
func NewAlbumClient(c config) *AlbumClient {
	return &AlbumClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `album.Hooks(f(g(h())))`.
func (c *AlbumClient) Use(hooks ...Hook) {
	c.hooks.Album = append(c.hooks.Album, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `album.Intercept(f(g(h())))`.
func (c *AlbumClient) Intercept(interceptors ...Interceptor) {
	c.inters.Album = append(c.inters.Album, interceptors...)
}

// Create returns a builder for creating a Album entity.
func (c *AlbumClient) Create() *AlbumCreate {
	mutation := newAlbumMutation(c.config, OpCreate)
	return &AlbumCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Album entities.
func (c *AlbumClient) CreateBulk(builders ...*AlbumCreate) *AlbumCreateBulk {
	return &AlbumCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlbumClient) MapCreateBulk(slice any, setFunc func(*AlbumCreate, int)) *AlbumCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlbumCreateBulk{err: fmt.Errorf("calling to AlbumClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlbumCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlbumCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Album.
func (c *AlbumClient) Update() *AlbumUpdate {
	mutation := newAlbumMutation(c.config, OpUpdate)
	return &AlbumUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlbumClient) UpdateOne(_m *Album) *AlbumUpdateOne {
	mutation := newAlbumMutation(c.config, OpUpdateOne, withAlbum(_m))
	return &AlbumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlbumClient) UpdateOneID(id uint) *AlbumUpdateOne {
	mutation := newAlbumMutation(c.config, OpUpdateOne, withAlbumID(id))
	return &AlbumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Album.
func (c *AlbumClient) Delete() *AlbumDelete {
	mutation := newAlbumMutation(c.config, OpDelete)
	return &AlbumDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlbumClient) DeleteOne(_m *Album) *AlbumDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlbumClient) DeleteOneID(id uint) *AlbumDeleteOne {
	builder := c.Delete().Where(album.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlbumDeleteOne{builder}
}

// Query returns a query builder for Album.
func (c *AlbumClient) Query() *AlbumQuery {
	return &AlbumQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlbum},
		inters: c.Interceptors(),
	}
}

// Get returns a Album entity by its id.
func (c *AlbumClient) Get(ctx context.Context, id uint) (*Album, error) {
	return c.Query().Where(album.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlbumClient) GetX(ctx context.Context, id uint) *Album {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AlbumClient) Hooks() []Hook {
	hooks := c.hooks.Album
	return append(hooks[:len(hooks):len(hooks)], album.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AlbumClient) Interceptors() []Interceptor {
	return c.inters.Album
}

func (c *AlbumClient) mutate(ctx context.Context, m *AlbumMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlbumCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlbumUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlbumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlbumDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Album mutation op: %q", m.Op())
	}
}

// ArticleClient is a client for the Article schema.
type ArticleClient struct {
	config
}

// NewArticleClient returns a client for the Article from the given config.
func NewArticleClient(c config) *ArticleClient {
	return &ArticleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `article.Hooks(f(g(h())))`.
func (c *ArticleClient) Use(hooks ...Hook) {
	c.hooks.Article = append(c.hooks.Article, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `article.Intercept(f(g(h())))`.
func (c *ArticleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Article = append(c.inters.Article, interceptors...)
}

// Create returns a builder for creating a Article entity.
func (c *ArticleClient) Create() *ArticleCreate {
	mutation := newArticleMutation(c.config, OpCreate)
	return &ArticleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Article entities.
func (c *ArticleClient) CreateBulk(builders ...*ArticleCreate) *ArticleCreateBulk {
	return &ArticleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArticleClient) MapCreateBulk(slice any, setFunc func(*ArticleCreate, int)) *ArticleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArticleCreateBulk{err: fmt.Errorf("calling to ArticleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArticleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArticleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Article.
func (c *ArticleClient) Update() *ArticleUpdate {
	mutation := newArticleMutation(c.config, OpUpdate)
	return &ArticleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArticleClient) UpdateOne(_m *Article) *ArticleUpdateOne {
	mutation := newArticleMutation(c.config, OpUpdateOne, withArticle(_m))
	return &ArticleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArticleClient) UpdateOneID(id uint) *ArticleUpdateOne {
	mutation := newArticleMutation(c.config, OpUpdateOne, withArticleID(id))
	return &ArticleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Article.
func (c *ArticleClient) Delete() *ArticleDelete {
	mutation := newArticleMutation(c.config, OpDelete)
	return &ArticleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArticleClient) DeleteOne(_m *Article) *ArticleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArticleClient) DeleteOneID(id uint) *ArticleDeleteOne {
	builder := c.Delete().Where(article.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArticleDeleteOne{builder}
}

// Query returns a query builder for Article.
func (c *ArticleClient) Query() *ArticleQuery {
	return &ArticleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArticle},
		inters: c.Interceptors(),
	}
}

// Get returns a Article entity by its id.
func (c *ArticleClient) Get(ctx context.Context, id uint) (*Article, error) {
	return c.Query().Where(article.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArticleClient) GetX(ctx context.Context, id uint) *Article {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPostTags queries the post_tags edge of a Article.
func (c *ArticleClient) QueryPostTags(_m *Article) *PostTagQuery {
	query := (&PostTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(article.Table, article.FieldID, id),
			sqlgraph.To(posttag.Table, posttag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, article.PostTagsTable, article.PostTagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPostCategories queries the post_categories edge of a Article.
func (c *ArticleClient) QueryPostCategories(_m *Article) *PostCategoryQuery {
	query := (&PostCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(article.Table, article.FieldID, id),
			sqlgraph.To(postcategory.Table, postcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, article.PostCategoriesTable, article.PostCategoriesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Article.
func (c *ArticleClient) QueryComments(_m *Article) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(article.Table, article.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, article.CommentsTable, article.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArticleClient) Hooks() []Hook {
	hooks := c.hooks.Article
	return append(hooks[:len(hooks):len(hooks)], article.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ArticleClient) Interceptors() []Interceptor {
	return c.inters.Article
}

func (c *ArticleClient) mutate(ctx context.Context, m *ArticleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArticleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArticleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArticleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArticleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Article mutation op: %q", m.Op())
	}
}

// CommentClient is a client for the Comment schema.
type CommentClient struct {
	config
}

// NewCommentClient returns a client for the Comment from the given config.
func NewCommentClient(c config) *CommentClient {
	return &CommentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `comment.Hooks(f(g(h())))`.
func (c *CommentClient) Use(hooks ...Hook) {
	c.hooks.Comment = append(c.hooks.Comment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `comment.Intercept(f(g(h())))`.
func (c *CommentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Comment = append(c.inters.Comment, interceptors...)
}

// Create returns a builder for creating a Comment entity.
func (c *CommentClient) Create() *CommentCreate {
	mutation := newCommentMutation(c.config, OpCreate)
	return &CommentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Comment entities.
func (c *CommentClient) CreateBulk(builders ...*CommentCreate) *CommentCreateBulk {
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommentClient) MapCreateBulk(slice any, setFunc func(*CommentCreate, int)) *CommentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommentCreateBulk{err: fmt.Errorf("calling to CommentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Comment.
func (c *CommentClient) Update() *CommentUpdate {
	mutation := newCommentMutation(c.config, OpUpdate)
	return &CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommentClient) UpdateOne(_m *Comment) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withComment(_m))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommentClient) UpdateOneID(id uint) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withCommentID(id))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Comment.
func (c *CommentClient) Delete() *CommentDelete {
	mutation := newCommentMutation(c.config, OpDelete)
	return &CommentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommentClient) DeleteOne(_m *Comment) *CommentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommentClient) DeleteOneID(id uint) *CommentDeleteOne {
	builder := c.Delete().Where(comment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommentDeleteOne{builder}
}

// Query returns a query builder for Comment.
func (c *CommentClient) Query() *CommentQuery {
	return &CommentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComment},
		inters: c.Interceptors(),
	}
}

// Get returns a Comment entity by its id.
func (c *CommentClient) Get(ctx context.Context, id uint) (*Comment, error) {
	return c.Query().Where(comment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommentClient) GetX(ctx context.Context, id uint) *Comment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Comment.
func (c *CommentClient) QueryUser(_m *Comment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.UserTable, comment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Comment.
func (c *CommentClient) QueryChildren(_m *Comment) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.ChildrenTable, comment.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Comment.
func (c *CommentClient) QueryParent(_m *Comment) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, comment.ParentTable, comment.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommentClient) Hooks() []Hook {
	hooks := c.hooks.Comment
	return append(hooks[:len(hooks):len(hooks)], comment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CommentClient) Interceptors() []Interceptor {
	return c.inters.Comment
}

func (c *CommentClient) mutate(ctx context.Context, m *CommentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Comment mutation op: %q", m.Op())
	}
}

// DirectLinkClient is a client for the DirectLink schema.
type DirectLinkClient struct {
	config
}

// NewDirectLinkClient returns a client for the DirectLink from the given config.
func NewDirectLinkClient(c config) *DirectLinkClient {
	return &DirectLinkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `directlink.Hooks(f(g(h())))`.
func (c *DirectLinkClient) Use(hooks ...Hook) {
	c.hooks.DirectLink = append(c.hooks.DirectLink, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `directlink.Intercept(f(g(h())))`.
func (c *DirectLinkClient) Intercept(interceptors ...Interceptor) {
	c.inters.DirectLink = append(c.inters.DirectLink, interceptors...)
}

// Create returns a builder for creating a DirectLink entity.
func (c *DirectLinkClient) Create() *DirectLinkCreate {
	mutation := newDirectLinkMutation(c.config, OpCreate)
	return &DirectLinkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DirectLink entities.
func (c *DirectLinkClient) CreateBulk(builders ...*DirectLinkCreate) *DirectLinkCreateBulk {
	return &DirectLinkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DirectLinkClient) MapCreateBulk(slice any, setFunc func(*DirectLinkCreate, int)) *DirectLinkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DirectLinkCreateBulk{err: fmt.Errorf("calling to DirectLinkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DirectLinkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DirectLinkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DirectLink.
func (c *DirectLinkClient) Update() *DirectLinkUpdate {
	mutation := newDirectLinkMutation(c.config, OpUpdate)
	return &DirectLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DirectLinkClient) UpdateOne(_m *DirectLink) *DirectLinkUpdateOne {
	mutation := newDirectLinkMutation(c.config, OpUpdateOne, withDirectLink(_m))
	return &DirectLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DirectLinkClient) UpdateOneID(id uint) *DirectLinkUpdateOne {
	mutation := newDirectLinkMutation(c.config, OpUpdateOne, withDirectLinkID(id))
	return &DirectLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DirectLink.
func (c *DirectLinkClient) Delete() *DirectLinkDelete {
	mutation := newDirectLinkMutation(c.config, OpDelete)
	return &DirectLinkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DirectLinkClient) DeleteOne(_m *DirectLink) *DirectLinkDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DirectLinkClient) DeleteOneID(id uint) *DirectLinkDeleteOne {
	builder := c.Delete().Where(directlink.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DirectLinkDeleteOne{builder}
}

// Query returns a query builder for DirectLink.
func (c *DirectLinkClient) Query() *DirectLinkQuery {
	return &DirectLinkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDirectLink},
		inters: c.Interceptors(),
	}
}

// Get returns a DirectLink entity by its id.
func (c *DirectLinkClient) Get(ctx context.Context, id uint) (*DirectLink, error) {
	return c.Query().Where(directlink.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DirectLinkClient) GetX(ctx context.Context, id uint) *DirectLink {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFile queries the file edge of a DirectLink.
func (c *DirectLinkClient) QueryFile(_m *DirectLink) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(directlink.Table, directlink.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, directlink.FileTable, directlink.FileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DirectLinkClient) Hooks() []Hook {
	hooks := c.hooks.DirectLink
	return append(hooks[:len(hooks):len(hooks)], directlink.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DirectLinkClient) Interceptors() []Interceptor {
	return c.inters.DirectLink
}

func (c *DirectLinkClient) mutate(ctx context.Context, m *DirectLinkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DirectLinkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DirectLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DirectLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DirectLinkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DirectLink mutation op: %q", m.Op())
	}
}

// EntityClient is a client for the Entity schema.
type EntityClient struct {
	config
}

// NewEntityClient returns a client for the Entity from the given config.
func NewEntityClient(c config) *EntityClient {
	return &EntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entity.Hooks(f(g(h())))`.
func (c *EntityClient) Use(hooks ...Hook) {
	c.hooks.Entity = append(c.hooks.Entity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entity.Intercept(f(g(h())))`.
func (c *EntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Entity = append(c.inters.Entity, interceptors...)
}

// Create returns a builder for creating a Entity entity.
func (c *EntityClient) Create() *EntityCreate {
	mutation := newEntityMutation(c.config, OpCreate)
	return &EntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Entity entities.
func (c *EntityClient) CreateBulk(builders ...*EntityCreate) *EntityCreateBulk {
	return &EntityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntityClient) MapCreateBulk(slice any, setFunc func(*EntityCreate, int)) *EntityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntityCreateBulk{err: fmt.Errorf("calling to EntityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Entity.
func (c *EntityClient) Update() *EntityUpdate {
	mutation := newEntityMutation(c.config, OpUpdate)
	return &EntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntityClient) UpdateOne(_m *Entity) *EntityUpdateOne {
	mutation := newEntityMutation(c.config, OpUpdateOne, withEntity(_m))
	return &EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntityClient) UpdateOneID(id uint) *EntityUpdateOne {
	mutation := newEntityMutation(c.config, OpUpdateOne, withEntityID(id))
	return &EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Entity.
func (c *EntityClient) Delete() *EntityDelete {
	mutation := newEntityMutation(c.config, OpDelete)
	return &EntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntityClient) DeleteOne(_m *Entity) *EntityDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntityClient) DeleteOneID(id uint) *EntityDeleteOne {
	builder := c.Delete().Where(entity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntityDeleteOne{builder}
}

// Query returns a query builder for Entity.
func (c *EntityClient) Query() *EntityQuery {
	return &EntityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntity},
		inters: c.Interceptors(),
	}
}

// Get returns a Entity entity by its id.
func (c *EntityClient) Get(ctx context.Context, id uint) (*Entity, error) {
	return c.Query().Where(entity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntityClient) GetX(ctx context.Context, id uint) *Entity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFileVersions queries the file_versions edge of a Entity.
func (c *EntityClient) QueryFileVersions(_m *Entity) *FileEntityQuery {
	query := (&FileEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(fileentity.Table, fileentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entity.FileVersionsTable, entity.FileVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntityClient) Hooks() []Hook {
	return c.hooks.Entity
}

// Interceptors returns the client interceptors.
func (c *EntityClient) Interceptors() []Interceptor {
	return c.inters.Entity
}

func (c *EntityClient) mutate(ctx context.Context, m *EntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Entity mutation op: %q", m.Op())
	}
}

// FileClient is a client for the File schema.
type FileClient struct {
	config
}

// NewFileClient returns a client for the File from the given config.
func NewFileClient(c config) *FileClient {
	return &FileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `file.Hooks(f(g(h())))`.
func (c *FileClient) Use(hooks ...Hook) {
	c.hooks.File = append(c.hooks.File, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `file.Intercept(f(g(h())))`.
func (c *FileClient) Intercept(interceptors ...Interceptor) {
	c.inters.File = append(c.inters.File, interceptors...)
}

// Create returns a builder for creating a File entity.
func (c *FileClient) Create() *FileCreate {
	mutation := newFileMutation(c.config, OpCreate)
	return &FileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of File entities.
func (c *FileClient) CreateBulk(builders ...*FileCreate) *FileCreateBulk {
	return &FileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileClient) MapCreateBulk(slice any, setFunc func(*FileCreate, int)) *FileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileCreateBulk{err: fmt.Errorf("calling to FileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for File.
func (c *FileClient) Update() *FileUpdate {
	mutation := newFileMutation(c.config, OpUpdate)
	return &FileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileClient) UpdateOne(_m *File) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFile(_m))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileClient) UpdateOneID(id uint) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFileID(id))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for File.
func (c *FileClient) Delete() *FileDelete {
	mutation := newFileMutation(c.config, OpDelete)
	return &FileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileClient) DeleteOne(_m *File) *FileDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileClient) DeleteOneID(id uint) *FileDeleteOne {
	builder := c.Delete().Where(file.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteOne{builder}
}

// Query returns a query builder for File.
func (c *FileClient) Query() *FileQuery {
	return &FileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFile},
		inters: c.Interceptors(),
	}
}

// Get returns a File entity by its id.
func (c *FileClient) Get(ctx context.Context, id uint) (*File, error) {
	return c.Query().Where(file.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileClient) GetX(ctx context.Context, id uint) *File {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a File.
func (c *FileClient) QueryOwner(_m *File) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, file.OwnerTable, file.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a File.
func (c *FileClient) QueryParent(_m *File) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, file.ParentTable, file.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a File.
func (c *FileClient) QueryChildren(_m *File) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, file.ChildrenTable, file.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrimaryEntity queries the primary_entity edge of a File.
func (c *FileClient) QueryPrimaryEntity(_m *File) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, file.PrimaryEntityTable, file.PrimaryEntityColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVersions queries the versions edge of a File.
func (c *FileClient) QueryVersions(_m *File) *FileEntityQuery {
	query := (&FileEntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(fileentity.Table, fileentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, file.VersionsTable, file.VersionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDirectLink queries the direct_link edge of a File.
func (c *FileClient) QueryDirectLink(_m *File) *DirectLinkQuery {
	query := (&DirectLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(directlink.Table, directlink.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, file.DirectLinkTable, file.DirectLinkColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a File.
func (c *FileClient) QueryMetadata(_m *File) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, file.MetadataTable, file.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileClient) Hooks() []Hook {
	hooks := c.hooks.File
	return append(hooks[:len(hooks):len(hooks)], file.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FileClient) Interceptors() []Interceptor {
	return c.inters.File
}

func (c *FileClient) mutate(ctx context.Context, m *FileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown File mutation op: %q", m.Op())
	}
}

// FileEntityClient is a client for the FileEntity schema.
type FileEntityClient struct {
	config
}

// NewFileEntityClient returns a client for the FileEntity from the given config.
func NewFileEntityClient(c config) *FileEntityClient {
	return &FileEntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fileentity.Hooks(f(g(h())))`.
func (c *FileEntityClient) Use(hooks ...Hook) {
	c.hooks.FileEntity = append(c.hooks.FileEntity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fileentity.Intercept(f(g(h())))`.
func (c *FileEntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileEntity = append(c.inters.FileEntity, interceptors...)
}

// Create returns a builder for creating a FileEntity entity.
func (c *FileEntityClient) Create() *FileEntityCreate {
	mutation := newFileEntityMutation(c.config, OpCreate)
	return &FileEntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileEntity entities.
func (c *FileEntityClient) CreateBulk(builders ...*FileEntityCreate) *FileEntityCreateBulk {
	return &FileEntityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileEntityClient) MapCreateBulk(slice any, setFunc func(*FileEntityCreate, int)) *FileEntityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileEntityCreateBulk{err: fmt.Errorf("calling to FileEntityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileEntityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileEntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileEntity.
func (c *FileEntityClient) Update() *FileEntityUpdate {
	mutation := newFileEntityMutation(c.config, OpUpdate)
	return &FileEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileEntityClient) UpdateOne(_m *FileEntity) *FileEntityUpdateOne {
	mutation := newFileEntityMutation(c.config, OpUpdateOne, withFileEntity(_m))
	return &FileEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileEntityClient) UpdateOneID(id uint) *FileEntityUpdateOne {
	mutation := newFileEntityMutation(c.config, OpUpdateOne, withFileEntityID(id))
	return &FileEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileEntity.
func (c *FileEntityClient) Delete() *FileEntityDelete {
	mutation := newFileEntityMutation(c.config, OpDelete)
	return &FileEntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileEntityClient) DeleteOne(_m *FileEntity) *FileEntityDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileEntityClient) DeleteOneID(id uint) *FileEntityDeleteOne {
	builder := c.Delete().Where(fileentity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileEntityDeleteOne{builder}
}

// Query returns a query builder for FileEntity.
func (c *FileEntityClient) Query() *FileEntityQuery {
	return &FileEntityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileEntity},
		inters: c.Interceptors(),
	}
}

// Get returns a FileEntity entity by its id.
func (c *FileEntityClient) Get(ctx context.Context, id uint) (*FileEntity, error) {
	return c.Query().Where(fileentity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileEntityClient) GetX(ctx context.Context, id uint) *FileEntity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFile queries the file edge of a FileEntity.
func (c *FileEntityClient) QueryFile(_m *FileEntity) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fileentity.Table, fileentity.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fileentity.FileTable, fileentity.FileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntity queries the entity edge of a FileEntity.
func (c *FileEntityClient) QueryEntity(_m *FileEntity) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fileentity.Table, fileentity.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fileentity.EntityTable, fileentity.EntityColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileEntityClient) Hooks() []Hook {
	hooks := c.hooks.FileEntity
	return append(hooks[:len(hooks):len(hooks)], fileentity.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FileEntityClient) Interceptors() []Interceptor {
	return c.inters.FileEntity
}

func (c *FileEntityClient) mutate(ctx context.Context, m *FileEntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileEntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileEntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FileEntity mutation op: %q", m.Op())
	}
}

// LinkClient is a client for the Link schema.
type LinkClient struct {
	config
}

// NewLinkClient returns a client for the Link from the given config.
func NewLinkClient(c config) *LinkClient {
	return &LinkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `link.Hooks(f(g(h())))`.
func (c *LinkClient) Use(hooks ...Hook) {
	c.hooks.Link = append(c.hooks.Link, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `link.Intercept(f(g(h())))`.
func (c *LinkClient) Intercept(interceptors ...Interceptor) {
	c.inters.Link = append(c.inters.Link, interceptors...)
}

// Create returns a builder for creating a Link entity.
func (c *LinkClient) Create() *LinkCreate {
	mutation := newLinkMutation(c.config, OpCreate)
	return &LinkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Link entities.
func (c *LinkClient) CreateBulk(builders ...*LinkCreate) *LinkCreateBulk {
	return &LinkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LinkClient) MapCreateBulk(slice any, setFunc func(*LinkCreate, int)) *LinkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LinkCreateBulk{err: fmt.Errorf("calling to LinkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LinkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LinkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Link.
func (c *LinkClient) Update() *LinkUpdate {
	mutation := newLinkMutation(c.config, OpUpdate)
	return &LinkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LinkClient) UpdateOne(_m *Link) *LinkUpdateOne {
	mutation := newLinkMutation(c.config, OpUpdateOne, withLink(_m))
	return &LinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LinkClient) UpdateOneID(id int) *LinkUpdateOne {
	mutation := newLinkMutation(c.config, OpUpdateOne, withLinkID(id))
	return &LinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Link.
func (c *LinkClient) Delete() *LinkDelete {
	mutation := newLinkMutation(c.config, OpDelete)
	return &LinkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LinkClient) DeleteOne(_m *Link) *LinkDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LinkClient) DeleteOneID(id int) *LinkDeleteOne {
	builder := c.Delete().Where(link.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LinkDeleteOne{builder}
}

// Query returns a query builder for Link.
func (c *LinkClient) Query() *LinkQuery {
	return &LinkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLink},
		inters: c.Interceptors(),
	}
}

// Get returns a Link entity by its id.
func (c *LinkClient) Get(ctx context.Context, id int) (*Link, error) {
	return c.Query().Where(link.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LinkClient) GetX(ctx context.Context, id int) *Link {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCategory queries the category edge of a Link.
func (c *LinkClient) QueryCategory(_m *Link) *LinkCategoryQuery {
	query := (&LinkCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(link.Table, link.FieldID, id),
			sqlgraph.To(linkcategory.Table, linkcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, link.CategoryTable, link.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a Link.
func (c *LinkClient) QueryTags(_m *Link) *LinkTagQuery {
	query := (&LinkTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(link.Table, link.FieldID, id),
			sqlgraph.To(linktag.Table, linktag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, link.TagsTable, link.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LinkClient) Hooks() []Hook {
	return c.hooks.Link
}

// Interceptors returns the client interceptors.
func (c *LinkClient) Interceptors() []Interceptor {
	return c.inters.Link
}

func (c *LinkClient) mutate(ctx context.Context, m *LinkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LinkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LinkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LinkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Link mutation op: %q", m.Op())
	}
}

// LinkCategoryClient is a client for the LinkCategory schema.
type LinkCategoryClient struct {
	config
}

// NewLinkCategoryClient returns a client for the LinkCategory from the given config.
func NewLinkCategoryClient(c config) *LinkCategoryClient {
	return &LinkCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `linkcategory.Hooks(f(g(h())))`.
func (c *LinkCategoryClient) Use(hooks ...Hook) {
	c.hooks.LinkCategory = append(c.hooks.LinkCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `linkcategory.Intercept(f(g(h())))`.
func (c *LinkCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.LinkCategory = append(c.inters.LinkCategory, interceptors...)
}

// Create returns a builder for creating a LinkCategory entity.
func (c *LinkCategoryClient) Create() *LinkCategoryCreate {
	mutation := newLinkCategoryMutation(c.config, OpCreate)
	return &LinkCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LinkCategory entities.
func (c *LinkCategoryClient) CreateBulk(builders ...*LinkCategoryCreate) *LinkCategoryCreateBulk {
	return &LinkCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LinkCategoryClient) MapCreateBulk(slice any, setFunc func(*LinkCategoryCreate, int)) *LinkCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LinkCategoryCreateBulk{err: fmt.Errorf("calling to LinkCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LinkCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LinkCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LinkCategory.
func (c *LinkCategoryClient) Update() *LinkCategoryUpdate {
	mutation := newLinkCategoryMutation(c.config, OpUpdate)
	return &LinkCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LinkCategoryClient) UpdateOne(_m *LinkCategory) *LinkCategoryUpdateOne {
	mutation := newLinkCategoryMutation(c.config, OpUpdateOne, withLinkCategory(_m))
	return &LinkCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LinkCategoryClient) UpdateOneID(id int) *LinkCategoryUpdateOne {
	mutation := newLinkCategoryMutation(c.config, OpUpdateOne, withLinkCategoryID(id))
	return &LinkCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LinkCategory.
func (c *LinkCategoryClient) Delete() *LinkCategoryDelete {
	mutation := newLinkCategoryMutation(c.config, OpDelete)
	return &LinkCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LinkCategoryClient) DeleteOne(_m *LinkCategory) *LinkCategoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LinkCategoryClient) DeleteOneID(id int) *LinkCategoryDeleteOne {
	builder := c.Delete().Where(linkcategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LinkCategoryDeleteOne{builder}
}

// Query returns a query builder for LinkCategory.
func (c *LinkCategoryClient) Query() *LinkCategoryQuery {
	return &LinkCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLinkCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a LinkCategory entity by its id.
func (c *LinkCategoryClient) Get(ctx context.Context, id int) (*LinkCategory, error) {
	return c.Query().Where(linkcategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LinkCategoryClient) GetX(ctx context.Context, id int) *LinkCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLinks queries the links edge of a LinkCategory.
func (c *LinkCategoryClient) QueryLinks(_m *LinkCategory) *LinkQuery {
	query := (&LinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(linkcategory.Table, linkcategory.FieldID, id),
			sqlgraph.To(link.Table, link.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, linkcategory.LinksTable, linkcategory.LinksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LinkCategoryClient) Hooks() []Hook {
	return c.hooks.LinkCategory
}

// Interceptors returns the client interceptors.
func (c *LinkCategoryClient) Interceptors() []Interceptor {
	return c.inters.LinkCategory
}

func (c *LinkCategoryClient) mutate(ctx context.Context, m *LinkCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LinkCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LinkCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LinkCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LinkCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LinkCategory mutation op: %q", m.Op())
	}
}

// LinkTagClient is a client for the LinkTag schema.
type LinkTagClient struct {
	config
}

// NewLinkTagClient returns a client for the LinkTag from the given config.
func NewLinkTagClient(c config) *LinkTagClient {
	return &LinkTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `linktag.Hooks(f(g(h())))`.
func (c *LinkTagClient) Use(hooks ...Hook) {
	c.hooks.LinkTag = append(c.hooks.LinkTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `linktag.Intercept(f(g(h())))`.
func (c *LinkTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.LinkTag = append(c.inters.LinkTag, interceptors...)
}

// Create returns a builder for creating a LinkTag entity.
func (c *LinkTagClient) Create() *LinkTagCreate {
	mutation := newLinkTagMutation(c.config, OpCreate)
	return &LinkTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LinkTag entities.
func (c *LinkTagClient) CreateBulk(builders ...*LinkTagCreate) *LinkTagCreateBulk {
	return &LinkTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LinkTagClient) MapCreateBulk(slice any, setFunc func(*LinkTagCreate, int)) *LinkTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LinkTagCreateBulk{err: fmt.Errorf("calling to LinkTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LinkTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LinkTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LinkTag.
func (c *LinkTagClient) Update() *LinkTagUpdate {
	mutation := newLinkTagMutation(c.config, OpUpdate)
	return &LinkTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LinkTagClient) UpdateOne(_m *LinkTag) *LinkTagUpdateOne {
	mutation := newLinkTagMutation(c.config, OpUpdateOne, withLinkTag(_m))
	return &LinkTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LinkTagClient) UpdateOneID(id int) *LinkTagUpdateOne {
	mutation := newLinkTagMutation(c.config, OpUpdateOne, withLinkTagID(id))
	return &LinkTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LinkTag.
func (c *LinkTagClient) Delete() *LinkTagDelete {
	mutation := newLinkTagMutation(c.config, OpDelete)
	return &LinkTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LinkTagClient) DeleteOne(_m *LinkTag) *LinkTagDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LinkTagClient) DeleteOneID(id int) *LinkTagDeleteOne {
	builder := c.Delete().Where(linktag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LinkTagDeleteOne{builder}
}

// Query returns a query builder for LinkTag.
func (c *LinkTagClient) Query() *LinkTagQuery {
	return &LinkTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLinkTag},
		inters: c.Interceptors(),
	}
}

// Get returns a LinkTag entity by its id.
func (c *LinkTagClient) Get(ctx context.Context, id int) (*LinkTag, error) {
	return c.Query().Where(linktag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LinkTagClient) GetX(ctx context.Context, id int) *LinkTag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLinks queries the links edge of a LinkTag.
func (c *LinkTagClient) QueryLinks(_m *LinkTag) *LinkQuery {
	query := (&LinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(linktag.Table, linktag.FieldID, id),
			sqlgraph.To(link.Table, link.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, linktag.LinksTable, linktag.LinksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LinkTagClient) Hooks() []Hook {
	return c.hooks.LinkTag
}

// Interceptors returns the client interceptors.
func (c *LinkTagClient) Interceptors() []Interceptor {
	return c.inters.LinkTag
}

func (c *LinkTagClient) mutate(ctx context.Context, m *LinkTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LinkTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LinkTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LinkTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LinkTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LinkTag mutation op: %q", m.Op())
	}
}

// MetadataClient is a client for the Metadata schema.
type MetadataClient struct {
	config
}

// NewMetadataClient returns a client for the Metadata from the given config.
func NewMetadataClient(c config) *MetadataClient {
	return &MetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metadata.Hooks(f(g(h())))`.
func (c *MetadataClient) Use(hooks ...Hook) {
	c.hooks.Metadata = append(c.hooks.Metadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `metadata.Intercept(f(g(h())))`.
func (c *MetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.Metadata = append(c.inters.Metadata, interceptors...)
}

// Create returns a builder for creating a Metadata entity.
func (c *MetadataClient) Create() *MetadataCreate {
	mutation := newMetadataMutation(c.config, OpCreate)
	return &MetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Metadata entities.
func (c *MetadataClient) CreateBulk(builders ...*MetadataCreate) *MetadataCreateBulk {
	return &MetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MetadataClient) MapCreateBulk(slice any, setFunc func(*MetadataCreate, int)) *MetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MetadataCreateBulk{err: fmt.Errorf("calling to MetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Metadata.
func (c *MetadataClient) Update() *MetadataUpdate {
	mutation := newMetadataMutation(c.config, OpUpdate)
	return &MetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetadataClient) UpdateOne(_m *Metadata) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadata(_m))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetadataClient) UpdateOneID(id uint) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadataID(id))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Metadata.
func (c *MetadataClient) Delete() *MetadataDelete {
	mutation := newMetadataMutation(c.config, OpDelete)
	return &MetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MetadataClient) DeleteOne(_m *Metadata) *MetadataDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MetadataClient) DeleteOneID(id uint) *MetadataDeleteOne {
	builder := c.Delete().Where(metadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetadataDeleteOne{builder}
}

// Query returns a query builder for Metadata.
func (c *MetadataClient) Query() *MetadataQuery {
	return &MetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a Metadata entity by its id.
func (c *MetadataClient) Get(ctx context.Context, id uint) (*Metadata, error) {
	return c.Query().Where(metadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetadataClient) GetX(ctx context.Context, id uint) *Metadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFile queries the file edge of a Metadata.
func (c *MetadataClient) QueryFile(_m *Metadata) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, metadata.FileTable, metadata.FileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MetadataClient) Hooks() []Hook {
	hooks := c.hooks.Metadata
	return append(hooks[:len(hooks):len(hooks)], metadata.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MetadataClient) Interceptors() []Interceptor {
	return c.inters.Metadata
}

func (c *MetadataClient) mutate(ctx context.Context, m *MetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Metadata mutation op: %q", m.Op())
	}
}

// NotificationTypeClient is a client for the NotificationType schema.
type NotificationTypeClient struct {
	config
}

// NewNotificationTypeClient returns a client for the NotificationType from the given config.
func NewNotificationTypeClient(c config) *NotificationTypeClient {
	return &NotificationTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notificationtype.Hooks(f(g(h())))`.
func (c *NotificationTypeClient) Use(hooks ...Hook) {
	c.hooks.NotificationType = append(c.hooks.NotificationType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notificationtype.Intercept(f(g(h())))`.
func (c *NotificationTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.NotificationType = append(c.inters.NotificationType, interceptors...)
}

// Create returns a builder for creating a NotificationType entity.
func (c *NotificationTypeClient) Create() *NotificationTypeCreate {
	mutation := newNotificationTypeMutation(c.config, OpCreate)
	return &NotificationTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NotificationType entities.
func (c *NotificationTypeClient) CreateBulk(builders ...*NotificationTypeCreate) *NotificationTypeCreateBulk {
	return &NotificationTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationTypeClient) MapCreateBulk(slice any, setFunc func(*NotificationTypeCreate, int)) *NotificationTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationTypeCreateBulk{err: fmt.Errorf("calling to NotificationTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NotificationType.
func (c *NotificationTypeClient) Update() *NotificationTypeUpdate {
	mutation := newNotificationTypeMutation(c.config, OpUpdate)
	return &NotificationTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationTypeClient) UpdateOne(_m *NotificationType) *NotificationTypeUpdateOne {
	mutation := newNotificationTypeMutation(c.config, OpUpdateOne, withNotificationType(_m))
	return &NotificationTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationTypeClient) UpdateOneID(id uint) *NotificationTypeUpdateOne {
	mutation := newNotificationTypeMutation(c.config, OpUpdateOne, withNotificationTypeID(id))
	return &NotificationTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NotificationType.
func (c *NotificationTypeClient) Delete() *NotificationTypeDelete {
	mutation := newNotificationTypeMutation(c.config, OpDelete)
	return &NotificationTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationTypeClient) DeleteOne(_m *NotificationType) *NotificationTypeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationTypeClient) DeleteOneID(id uint) *NotificationTypeDeleteOne {
	builder := c.Delete().Where(notificationtype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationTypeDeleteOne{builder}
}

// Query returns a query builder for NotificationType.
func (c *NotificationTypeClient) Query() *NotificationTypeQuery {
	return &NotificationTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotificationType},
		inters: c.Interceptors(),
	}
}

// Get returns a NotificationType entity by its id.
func (c *NotificationTypeClient) Get(ctx context.Context, id uint) (*NotificationType, error) {
	return c.Query().Where(notificationtype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationTypeClient) GetX(ctx context.Context, id uint) *NotificationType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserConfigs queries the user_configs edge of a NotificationType.
func (c *NotificationTypeClient) QueryUserConfigs(_m *NotificationType) *UserNotificationConfigQuery {
	query := (&UserNotificationConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notificationtype.Table, notificationtype.FieldID, id),
			sqlgraph.To(usernotificationconfig.Table, usernotificationconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, notificationtype.UserConfigsTable, notificationtype.UserConfigsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationTypeClient) Hooks() []Hook {
	return c.hooks.NotificationType
}

// Interceptors returns the client interceptors.
func (c *NotificationTypeClient) Interceptors() []Interceptor {
	return c.inters.NotificationType
}

func (c *NotificationTypeClient) mutate(ctx context.Context, m *NotificationTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NotificationType mutation op: %q", m.Op())
	}
}

// PageClient is a client for the Page schema.
type PageClient struct {
	config
}

// NewPageClient returns a client for the Page from the given config.
func NewPageClient(c config) *PageClient {
	return &PageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `page.Hooks(f(g(h())))`.
func (c *PageClient) Use(hooks ...Hook) {
	c.hooks.Page = append(c.hooks.Page, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `page.Intercept(f(g(h())))`.
func (c *PageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Page = append(c.inters.Page, interceptors...)
}

// Create returns a builder for creating a Page entity.
func (c *PageClient) Create() *PageCreate {
	mutation := newPageMutation(c.config, OpCreate)
	return &PageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Page entities.
func (c *PageClient) CreateBulk(builders ...*PageCreate) *PageCreateBulk {
	return &PageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PageClient) MapCreateBulk(slice any, setFunc func(*PageCreate, int)) *PageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PageCreateBulk{err: fmt.Errorf("calling to PageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Page.
func (c *PageClient) Update() *PageUpdate {
	mutation := newPageMutation(c.config, OpUpdate)
	return &PageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PageClient) UpdateOne(_m *Page) *PageUpdateOne {
	mutation := newPageMutation(c.config, OpUpdateOne, withPage(_m))
	return &PageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PageClient) UpdateOneID(id uint) *PageUpdateOne {
	mutation := newPageMutation(c.config, OpUpdateOne, withPageID(id))
	return &PageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Page.
func (c *PageClient) Delete() *PageDelete {
	mutation := newPageMutation(c.config, OpDelete)
	return &PageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PageClient) DeleteOne(_m *Page) *PageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PageClient) DeleteOneID(id uint) *PageDeleteOne {
	builder := c.Delete().Where(page.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PageDeleteOne{builder}
}

// Query returns a query builder for Page.
func (c *PageClient) Query() *PageQuery {
	return &PageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePage},
		inters: c.Interceptors(),
	}
}

// Get returns a Page entity by its id.
func (c *PageClient) Get(ctx context.Context, id uint) (*Page, error) {
	return c.Query().Where(page.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PageClient) GetX(ctx context.Context, id uint) *Page {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PageClient) Hooks() []Hook {
	hooks := c.hooks.Page
	return append(hooks[:len(hooks):len(hooks)], page.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PageClient) Interceptors() []Interceptor {
	return c.inters.Page
}

func (c *PageClient) mutate(ctx context.Context, m *PageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Page mutation op: %q", m.Op())
	}
}

// PostCategoryClient is a client for the PostCategory schema.
type PostCategoryClient struct {
	config
}

// NewPostCategoryClient returns a client for the PostCategory from the given config.
func NewPostCategoryClient(c config) *PostCategoryClient {
	return &PostCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `postcategory.Hooks(f(g(h())))`.
func (c *PostCategoryClient) Use(hooks ...Hook) {
	c.hooks.PostCategory = append(c.hooks.PostCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `postcategory.Intercept(f(g(h())))`.
func (c *PostCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.PostCategory = append(c.inters.PostCategory, interceptors...)
}

// Create returns a builder for creating a PostCategory entity.
func (c *PostCategoryClient) Create() *PostCategoryCreate {
	mutation := newPostCategoryMutation(c.config, OpCreate)
	return &PostCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PostCategory entities.
func (c *PostCategoryClient) CreateBulk(builders ...*PostCategoryCreate) *PostCategoryCreateBulk {
	return &PostCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostCategoryClient) MapCreateBulk(slice any, setFunc func(*PostCategoryCreate, int)) *PostCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostCategoryCreateBulk{err: fmt.Errorf("calling to PostCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PostCategory.
func (c *PostCategoryClient) Update() *PostCategoryUpdate {
	mutation := newPostCategoryMutation(c.config, OpUpdate)
	return &PostCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostCategoryClient) UpdateOne(_m *PostCategory) *PostCategoryUpdateOne {
	mutation := newPostCategoryMutation(c.config, OpUpdateOne, withPostCategory(_m))
	return &PostCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostCategoryClient) UpdateOneID(id uint) *PostCategoryUpdateOne {
	mutation := newPostCategoryMutation(c.config, OpUpdateOne, withPostCategoryID(id))
	return &PostCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PostCategory.
func (c *PostCategoryClient) Delete() *PostCategoryDelete {
	mutation := newPostCategoryMutation(c.config, OpDelete)
	return &PostCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostCategoryClient) DeleteOne(_m *PostCategory) *PostCategoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostCategoryClient) DeleteOneID(id uint) *PostCategoryDeleteOne {
	builder := c.Delete().Where(postcategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostCategoryDeleteOne{builder}
}

// Query returns a query builder for PostCategory.
func (c *PostCategoryClient) Query() *PostCategoryQuery {
	return &PostCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePostCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a PostCategory entity by its id.
func (c *PostCategoryClient) Get(ctx context.Context, id uint) (*PostCategory, error) {
	return c.Query().Where(postcategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostCategoryClient) GetX(ctx context.Context, id uint) *PostCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArticles queries the articles edge of a PostCategory.
func (c *PostCategoryClient) QueryArticles(_m *PostCategory) *ArticleQuery {
	query := (&ArticleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(postcategory.Table, postcategory.FieldID, id),
			sqlgraph.To(article.Table, article.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, postcategory.ArticlesTable, postcategory.ArticlesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostCategoryClient) Hooks() []Hook {
	hooks := c.hooks.PostCategory
	return append(hooks[:len(hooks):len(hooks)], postcategory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PostCategoryClient) Interceptors() []Interceptor {
	return c.inters.PostCategory
}

func (c *PostCategoryClient) mutate(ctx context.Context, m *PostCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PostCategory mutation op: %q", m.Op())
	}
}

// PostTagClient is a client for the PostTag schema.
type PostTagClient struct {
	config
}

// NewPostTagClient returns a client for the PostTag from the given config.
func NewPostTagClient(c config) *PostTagClient {
	return &PostTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `posttag.Hooks(f(g(h())))`.
func (c *PostTagClient) Use(hooks ...Hook) {
	c.hooks.PostTag = append(c.hooks.PostTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `posttag.Intercept(f(g(h())))`.
func (c *PostTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.PostTag = append(c.inters.PostTag, interceptors...)
}

// Create returns a builder for creating a PostTag entity.
func (c *PostTagClient) Create() *PostTagCreate {
	mutation := newPostTagMutation(c.config, OpCreate)
	return &PostTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PostTag entities.
func (c *PostTagClient) CreateBulk(builders ...*PostTagCreate) *PostTagCreateBulk {
	return &PostTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostTagClient) MapCreateBulk(slice any, setFunc func(*PostTagCreate, int)) *PostTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostTagCreateBulk{err: fmt.Errorf("calling to PostTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PostTag.
func (c *PostTagClient) Update() *PostTagUpdate {
	mutation := newPostTagMutation(c.config, OpUpdate)
	return &PostTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostTagClient) UpdateOne(_m *PostTag) *PostTagUpdateOne {
	mutation := newPostTagMutation(c.config, OpUpdateOne, withPostTag(_m))
	return &PostTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostTagClient) UpdateOneID(id uint) *PostTagUpdateOne {
	mutation := newPostTagMutation(c.config, OpUpdateOne, withPostTagID(id))
	return &PostTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PostTag.
func (c *PostTagClient) Delete() *PostTagDelete {
	mutation := newPostTagMutation(c.config, OpDelete)
	return &PostTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostTagClient) DeleteOne(_m *PostTag) *PostTagDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostTagClient) DeleteOneID(id uint) *PostTagDeleteOne {
	builder := c.Delete().Where(posttag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostTagDeleteOne{builder}
}

// Query returns a query builder for PostTag.
func (c *PostTagClient) Query() *PostTagQuery {
	return &PostTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePostTag},
		inters: c.Interceptors(),
	}
}

// Get returns a PostTag entity by its id.
func (c *PostTagClient) Get(ctx context.Context, id uint) (*PostTag, error) {
	return c.Query().Where(posttag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostTagClient) GetX(ctx context.Context, id uint) *PostTag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArticles queries the articles edge of a PostTag.
func (c *PostTagClient) QueryArticles(_m *PostTag) *ArticleQuery {
	query := (&ArticleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(posttag.Table, posttag.FieldID, id),
			sqlgraph.To(article.Table, article.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, posttag.ArticlesTable, posttag.ArticlesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostTagClient) Hooks() []Hook {
	hooks := c.hooks.PostTag
	return append(hooks[:len(hooks):len(hooks)], posttag.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PostTagClient) Interceptors() []Interceptor {
	return c.inters.PostTag
}

func (c *PostTagClient) mutate(ctx context.Context, m *PostTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PostTag mutation op: %q", m.Op())
	}
}

// SettingClient is a client for the Setting schema.
type SettingClient struct {
	config
}

// NewSettingClient returns a client for the Setting from the given config.
func NewSettingClient(c config) *SettingClient {
	return &SettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `setting.Hooks(f(g(h())))`.
func (c *SettingClient) Use(hooks ...Hook) {
	c.hooks.Setting = append(c.hooks.Setting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `setting.Intercept(f(g(h())))`.
func (c *SettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Setting = append(c.inters.Setting, interceptors...)
}

// Create returns a builder for creating a Setting entity.
func (c *SettingClient) Create() *SettingCreate {
	mutation := newSettingMutation(c.config, OpCreate)
	return &SettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Setting entities.
func (c *SettingClient) CreateBulk(builders ...*SettingCreate) *SettingCreateBulk {
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SettingClient) MapCreateBulk(slice any, setFunc func(*SettingCreate, int)) *SettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SettingCreateBulk{err: fmt.Errorf("calling to SettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Setting.
func (c *SettingClient) Update() *SettingUpdate {
	mutation := newSettingMutation(c.config, OpUpdate)
	return &SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettingClient) UpdateOne(_m *Setting) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSetting(_m))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettingClient) UpdateOneID(id int) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSettingID(id))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Setting.
func (c *SettingClient) Delete() *SettingDelete {
	mutation := newSettingMutation(c.config, OpDelete)
	return &SettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettingClient) DeleteOne(_m *Setting) *SettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettingClient) DeleteOneID(id int) *SettingDeleteOne {
	builder := c.Delete().Where(setting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettingDeleteOne{builder}
}

// Query returns a query builder for Setting.
func (c *SettingClient) Query() *SettingQuery {
	return &SettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a Setting entity by its id.
func (c *SettingClient) Get(ctx context.Context, id int) (*Setting, error) {
	return c.Query().Where(setting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettingClient) GetX(ctx context.Context, id int) *Setting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SettingClient) Hooks() []Hook {
	hooks := c.hooks.Setting
	return append(hooks[:len(hooks):len(hooks)], setting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SettingClient) Interceptors() []Interceptor {
	return c.inters.Setting
}

func (c *SettingClient) mutate(ctx context.Context, m *SettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Setting mutation op: %q", m.Op())
	}
}

// StoragePolicyClient is a client for the StoragePolicy schema.
type StoragePolicyClient struct {
	config
}

// NewStoragePolicyClient returns a client for the StoragePolicy from the given config.
func NewStoragePolicyClient(c config) *StoragePolicyClient {
	return &StoragePolicyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `storagepolicy.Hooks(f(g(h())))`.
func (c *StoragePolicyClient) Use(hooks ...Hook) {
	c.hooks.StoragePolicy = append(c.hooks.StoragePolicy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `storagepolicy.Intercept(f(g(h())))`.
func (c *StoragePolicyClient) Intercept(interceptors ...Interceptor) {
	c.inters.StoragePolicy = append(c.inters.StoragePolicy, interceptors...)
}

// Create returns a builder for creating a StoragePolicy entity.
func (c *StoragePolicyClient) Create() *StoragePolicyCreate {
	mutation := newStoragePolicyMutation(c.config, OpCreate)
	return &StoragePolicyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StoragePolicy entities.
func (c *StoragePolicyClient) CreateBulk(builders ...*StoragePolicyCreate) *StoragePolicyCreateBulk {
	return &StoragePolicyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StoragePolicyClient) MapCreateBulk(slice any, setFunc func(*StoragePolicyCreate, int)) *StoragePolicyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StoragePolicyCreateBulk{err: fmt.Errorf("calling to StoragePolicyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StoragePolicyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StoragePolicyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StoragePolicy.
func (c *StoragePolicyClient) Update() *StoragePolicyUpdate {
	mutation := newStoragePolicyMutation(c.config, OpUpdate)
	return &StoragePolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StoragePolicyClient) UpdateOne(_m *StoragePolicy) *StoragePolicyUpdateOne {
	mutation := newStoragePolicyMutation(c.config, OpUpdateOne, withStoragePolicy(_m))
	return &StoragePolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StoragePolicyClient) UpdateOneID(id uint) *StoragePolicyUpdateOne {
	mutation := newStoragePolicyMutation(c.config, OpUpdateOne, withStoragePolicyID(id))
	return &StoragePolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StoragePolicy.
func (c *StoragePolicyClient) Delete() *StoragePolicyDelete {
	mutation := newStoragePolicyMutation(c.config, OpDelete)
	return &StoragePolicyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StoragePolicyClient) DeleteOne(_m *StoragePolicy) *StoragePolicyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StoragePolicyClient) DeleteOneID(id uint) *StoragePolicyDeleteOne {
	builder := c.Delete().Where(storagepolicy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StoragePolicyDeleteOne{builder}
}

// Query returns a query builder for StoragePolicy.
func (c *StoragePolicyClient) Query() *StoragePolicyQuery {
	return &StoragePolicyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStoragePolicy},
		inters: c.Interceptors(),
	}
}

// Get returns a StoragePolicy entity by its id.
func (c *StoragePolicyClient) Get(ctx context.Context, id uint) (*StoragePolicy, error) {
	return c.Query().Where(storagepolicy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StoragePolicyClient) GetX(ctx context.Context, id uint) *StoragePolicy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StoragePolicyClient) Hooks() []Hook {
	hooks := c.hooks.StoragePolicy
	return append(hooks[:len(hooks):len(hooks)], storagepolicy.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StoragePolicyClient) Interceptors() []Interceptor {
	return c.inters.StoragePolicy
}

func (c *StoragePolicyClient) mutate(ctx context.Context, m *StoragePolicyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StoragePolicyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StoragePolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StoragePolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StoragePolicyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StoragePolicy mutation op: %q", m.Op())
	}
}

// TagClient is a client for the Tag schema.
type TagClient struct {
	config
}

// NewTagClient returns a client for the Tag from the given config.
func NewTagClient(c config) *TagClient {
	return &TagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tag.Hooks(f(g(h())))`.
func (c *TagClient) Use(hooks ...Hook) {
	c.hooks.Tag = append(c.hooks.Tag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tag.Intercept(f(g(h())))`.
func (c *TagClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tag = append(c.inters.Tag, interceptors...)
}

// Create returns a builder for creating a Tag entity.
func (c *TagClient) Create() *TagCreate {
	mutation := newTagMutation(c.config, OpCreate)
	return &TagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tag entities.
func (c *TagClient) CreateBulk(builders ...*TagCreate) *TagCreateBulk {
	return &TagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TagClient) MapCreateBulk(slice any, setFunc func(*TagCreate, int)) *TagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TagCreateBulk{err: fmt.Errorf("calling to TagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tag.
func (c *TagClient) Update() *TagUpdate {
	mutation := newTagMutation(c.config, OpUpdate)
	return &TagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TagClient) UpdateOne(_m *Tag) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTag(_m))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TagClient) UpdateOneID(id uint) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTagID(id))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tag.
func (c *TagClient) Delete() *TagDelete {
	mutation := newTagMutation(c.config, OpDelete)
	return &TagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TagClient) DeleteOne(_m *Tag) *TagDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TagClient) DeleteOneID(id uint) *TagDeleteOne {
	builder := c.Delete().Where(tag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TagDeleteOne{builder}
}

// Query returns a query builder for Tag.
func (c *TagClient) Query() *TagQuery {
	return &TagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTag},
		inters: c.Interceptors(),
	}
}

// Get returns a Tag entity by its id.
func (c *TagClient) Get(ctx context.Context, id uint) (*Tag, error) {
	return c.Query().Where(tag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TagClient) GetX(ctx context.Context, id uint) *Tag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TagClient) Hooks() []Hook {
	hooks := c.hooks.Tag
	return append(hooks[:len(hooks):len(hooks)], tag.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TagClient) Interceptors() []Interceptor {
	return c.inters.Tag
}

func (c *TagClient) mutate(ctx context.Context, m *TagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tag mutation op: %q", m.Op())
	}
}

// URLStatClient is a client for the URLStat schema.
type URLStatClient struct {
	config
}

// NewURLStatClient returns a client for the URLStat from the given config.
func NewURLStatClient(c config) *URLStatClient {
	return &URLStatClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `urlstat.Hooks(f(g(h())))`.
func (c *URLStatClient) Use(hooks ...Hook) {
	c.hooks.URLStat = append(c.hooks.URLStat, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `urlstat.Intercept(f(g(h())))`.
func (c *URLStatClient) Intercept(interceptors ...Interceptor) {
	c.inters.URLStat = append(c.inters.URLStat, interceptors...)
}

// Create returns a builder for creating a URLStat entity.
func (c *URLStatClient) Create() *URLStatCreate {
	mutation := newURLStatMutation(c.config, OpCreate)
	return &URLStatCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of URLStat entities.
func (c *URLStatClient) CreateBulk(builders ...*URLStatCreate) *URLStatCreateBulk {
	return &URLStatCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *URLStatClient) MapCreateBulk(slice any, setFunc func(*URLStatCreate, int)) *URLStatCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &URLStatCreateBulk{err: fmt.Errorf("calling to URLStatClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*URLStatCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &URLStatCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for URLStat.
func (c *URLStatClient) Update() *URLStatUpdate {
	mutation := newURLStatMutation(c.config, OpUpdate)
	return &URLStatUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *URLStatClient) UpdateOne(_m *URLStat) *URLStatUpdateOne {
	mutation := newURLStatMutation(c.config, OpUpdateOne, withURLStat(_m))
	return &URLStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *URLStatClient) UpdateOneID(id uint) *URLStatUpdateOne {
	mutation := newURLStatMutation(c.config, OpUpdateOne, withURLStatID(id))
	return &URLStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for URLStat.
func (c *URLStatClient) Delete() *URLStatDelete {
	mutation := newURLStatMutation(c.config, OpDelete)
	return &URLStatDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *URLStatClient) DeleteOne(_m *URLStat) *URLStatDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *URLStatClient) DeleteOneID(id uint) *URLStatDeleteOne {
	builder := c.Delete().Where(urlstat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &URLStatDeleteOne{builder}
}

// Query returns a query builder for URLStat.
func (c *URLStatClient) Query() *URLStatQuery {
	return &URLStatQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeURLStat},
		inters: c.Interceptors(),
	}
}

// Get returns a URLStat entity by its id.
func (c *URLStatClient) Get(ctx context.Context, id uint) (*URLStat, error) {
	return c.Query().Where(urlstat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *URLStatClient) GetX(ctx context.Context, id uint) *URLStat {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *URLStatClient) Hooks() []Hook {
	return c.hooks.URLStat
}

// Interceptors returns the client interceptors.
func (c *URLStatClient) Interceptors() []Interceptor {
	return c.inters.URLStat
}

func (c *URLStatClient) mutate(ctx context.Context, m *URLStatMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&URLStatCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&URLStatUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&URLStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&URLStatDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown URLStat mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uint) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uint) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uint) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uint) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserGroup queries the user_group edge of a User.
func (c *UserClient) QueryUserGroup(_m *User) *UserGroupQuery {
	query := (&UserGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usergroup.Table, usergroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.UserGroupTable, user.UserGroupColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a User.
func (c *UserClient) QueryFiles(_m *User) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FilesTable, user.FilesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a User.
func (c *UserClient) QueryComments(_m *User) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CommentsTable, user.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstalledThemes queries the installed_themes edge of a User.
func (c *UserClient) QueryInstalledThemes(_m *User) *UserInstalledThemeQuery {
	query := (&UserInstalledThemeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userinstalledtheme.Table, userinstalledtheme.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.InstalledThemesTable, user.InstalledThemesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotificationConfigs queries the notification_configs edge of a User.
func (c *UserClient) QueryNotificationConfigs(_m *User) *UserNotificationConfigQuery {
	query := (&UserNotificationConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usernotificationconfig.Table, usernotificationconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.NotificationConfigsTable, user.NotificationConfigsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserGroupClient is a client for the UserGroup schema.
type UserGroupClient struct {
	config
}

// NewUserGroupClient returns a client for the UserGroup from the given config.
func NewUserGroupClient(c config) *UserGroupClient {
	return &UserGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usergroup.Hooks(f(g(h())))`.
func (c *UserGroupClient) Use(hooks ...Hook) {
	c.hooks.UserGroup = append(c.hooks.UserGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usergroup.Intercept(f(g(h())))`.
func (c *UserGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserGroup = append(c.inters.UserGroup, interceptors...)
}

// Create returns a builder for creating a UserGroup entity.
func (c *UserGroupClient) Create() *UserGroupCreate {
	mutation := newUserGroupMutation(c.config, OpCreate)
	return &UserGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserGroup entities.
func (c *UserGroupClient) CreateBulk(builders ...*UserGroupCreate) *UserGroupCreateBulk {
	return &UserGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserGroupClient) MapCreateBulk(slice any, setFunc func(*UserGroupCreate, int)) *UserGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserGroupCreateBulk{err: fmt.Errorf("calling to UserGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserGroup.
func (c *UserGroupClient) Update() *UserGroupUpdate {
	mutation := newUserGroupMutation(c.config, OpUpdate)
	return &UserGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserGroupClient) UpdateOne(_m *UserGroup) *UserGroupUpdateOne {
	mutation := newUserGroupMutation(c.config, OpUpdateOne, withUserGroup(_m))
	return &UserGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserGroupClient) UpdateOneID(id uint) *UserGroupUpdateOne {
	mutation := newUserGroupMutation(c.config, OpUpdateOne, withUserGroupID(id))
	return &UserGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserGroup.
func (c *UserGroupClient) Delete() *UserGroupDelete {
	mutation := newUserGroupMutation(c.config, OpDelete)
	return &UserGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserGroupClient) DeleteOne(_m *UserGroup) *UserGroupDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserGroupClient) DeleteOneID(id uint) *UserGroupDeleteOne {
	builder := c.Delete().Where(usergroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserGroupDeleteOne{builder}
}

// Query returns a query builder for UserGroup.
func (c *UserGroupClient) Query() *UserGroupQuery {
	return &UserGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a UserGroup entity by its id.
func (c *UserGroupClient) Get(ctx context.Context, id uint) (*UserGroup, error) {
	return c.Query().Where(usergroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserGroupClient) GetX(ctx context.Context, id uint) *UserGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a UserGroup.
func (c *UserGroupClient) QueryUsers(_m *UserGroup) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usergroup.Table, usergroup.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, usergroup.UsersTable, usergroup.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserGroupClient) Hooks() []Hook {
	hooks := c.hooks.UserGroup
	return append(hooks[:len(hooks):len(hooks)], usergroup.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserGroupClient) Interceptors() []Interceptor {
	return c.inters.UserGroup
}

func (c *UserGroupClient) mutate(ctx context.Context, m *UserGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserGroup mutation op: %q", m.Op())
	}
}

// UserInstalledThemeClient is a client for the UserInstalledTheme schema.
type UserInstalledThemeClient struct {
	config
}

// NewUserInstalledThemeClient returns a client for the UserInstalledTheme from the given config.
func NewUserInstalledThemeClient(c config) *UserInstalledThemeClient {
	return &UserInstalledThemeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userinstalledtheme.Hooks(f(g(h())))`.
func (c *UserInstalledThemeClient) Use(hooks ...Hook) {
	c.hooks.UserInstalledTheme = append(c.hooks.UserInstalledTheme, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userinstalledtheme.Intercept(f(g(h())))`.
func (c *UserInstalledThemeClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserInstalledTheme = append(c.inters.UserInstalledTheme, interceptors...)
}

// Create returns a builder for creating a UserInstalledTheme entity.
func (c *UserInstalledThemeClient) Create() *UserInstalledThemeCreate {
	mutation := newUserInstalledThemeMutation(c.config, OpCreate)
	return &UserInstalledThemeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserInstalledTheme entities.
func (c *UserInstalledThemeClient) CreateBulk(builders ...*UserInstalledThemeCreate) *UserInstalledThemeCreateBulk {
	return &UserInstalledThemeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserInstalledThemeClient) MapCreateBulk(slice any, setFunc func(*UserInstalledThemeCreate, int)) *UserInstalledThemeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserInstalledThemeCreateBulk{err: fmt.Errorf("calling to UserInstalledThemeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserInstalledThemeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserInstalledThemeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserInstalledTheme.
func (c *UserInstalledThemeClient) Update() *UserInstalledThemeUpdate {
	mutation := newUserInstalledThemeMutation(c.config, OpUpdate)
	return &UserInstalledThemeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserInstalledThemeClient) UpdateOne(_m *UserInstalledTheme) *UserInstalledThemeUpdateOne {
	mutation := newUserInstalledThemeMutation(c.config, OpUpdateOne, withUserInstalledTheme(_m))
	return &UserInstalledThemeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserInstalledThemeClient) UpdateOneID(id uint) *UserInstalledThemeUpdateOne {
	mutation := newUserInstalledThemeMutation(c.config, OpUpdateOne, withUserInstalledThemeID(id))
	return &UserInstalledThemeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserInstalledTheme.
func (c *UserInstalledThemeClient) Delete() *UserInstalledThemeDelete {
	mutation := newUserInstalledThemeMutation(c.config, OpDelete)
	return &UserInstalledThemeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserInstalledThemeClient) DeleteOne(_m *UserInstalledTheme) *UserInstalledThemeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserInstalledThemeClient) DeleteOneID(id uint) *UserInstalledThemeDeleteOne {
	builder := c.Delete().Where(userinstalledtheme.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserInstalledThemeDeleteOne{builder}
}

// Query returns a query builder for UserInstalledTheme.
func (c *UserInstalledThemeClient) Query() *UserInstalledThemeQuery {
	return &UserInstalledThemeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserInstalledTheme},
		inters: c.Interceptors(),
	}
}

// Get returns a UserInstalledTheme entity by its id.
func (c *UserInstalledThemeClient) Get(ctx context.Context, id uint) (*UserInstalledTheme, error) {
	return c.Query().Where(userinstalledtheme.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserInstalledThemeClient) GetX(ctx context.Context, id uint) *UserInstalledTheme {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserInstalledTheme.
func (c *UserInstalledThemeClient) QueryUser(_m *UserInstalledTheme) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userinstalledtheme.Table, userinstalledtheme.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userinstalledtheme.UserTable, userinstalledtheme.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserInstalledThemeClient) Hooks() []Hook {
	hooks := c.hooks.UserInstalledTheme
	return append(hooks[:len(hooks):len(hooks)], userinstalledtheme.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserInstalledThemeClient) Interceptors() []Interceptor {
	return c.inters.UserInstalledTheme
}

func (c *UserInstalledThemeClient) mutate(ctx context.Context, m *UserInstalledThemeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserInstalledThemeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserInstalledThemeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserInstalledThemeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserInstalledThemeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserInstalledTheme mutation op: %q", m.Op())
	}
}

// UserNotificationConfigClient is a client for the UserNotificationConfig schema.
type UserNotificationConfigClient struct {
	config
}

// NewUserNotificationConfigClient returns a client for the UserNotificationConfig from the given config.
func NewUserNotificationConfigClient(c config) *UserNotificationConfigClient {
	return &UserNotificationConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usernotificationconfig.Hooks(f(g(h())))`.
func (c *UserNotificationConfigClient) Use(hooks ...Hook) {
	c.hooks.UserNotificationConfig = append(c.hooks.UserNotificationConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usernotificationconfig.Intercept(f(g(h())))`.
func (c *UserNotificationConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserNotificationConfig = append(c.inters.UserNotificationConfig, interceptors...)
}

// Create returns a builder for creating a UserNotificationConfig entity.
func (c *UserNotificationConfigClient) Create() *UserNotificationConfigCreate {
	mutation := newUserNotificationConfigMutation(c.config, OpCreate)
	return &UserNotificationConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserNotificationConfig entities.
func (c *UserNotificationConfigClient) CreateBulk(builders ...*UserNotificationConfigCreate) *UserNotificationConfigCreateBulk {
	return &UserNotificationConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserNotificationConfigClient) MapCreateBulk(slice any, setFunc func(*UserNotificationConfigCreate, int)) *UserNotificationConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserNotificationConfigCreateBulk{err: fmt.Errorf("calling to UserNotificationConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserNotificationConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserNotificationConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserNotificationConfig.
func (c *UserNotificationConfigClient) Update() *UserNotificationConfigUpdate {
	mutation := newUserNotificationConfigMutation(c.config, OpUpdate)
	return &UserNotificationConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserNotificationConfigClient) UpdateOne(_m *UserNotificationConfig) *UserNotificationConfigUpdateOne {
	mutation := newUserNotificationConfigMutation(c.config, OpUpdateOne, withUserNotificationConfig(_m))
	return &UserNotificationConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserNotificationConfigClient) UpdateOneID(id uint) *UserNotificationConfigUpdateOne {
	mutation := newUserNotificationConfigMutation(c.config, OpUpdateOne, withUserNotificationConfigID(id))
	return &UserNotificationConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserNotificationConfig.
func (c *UserNotificationConfigClient) Delete() *UserNotificationConfigDelete {
	mutation := newUserNotificationConfigMutation(c.config, OpDelete)
	return &UserNotificationConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserNotificationConfigClient) DeleteOne(_m *UserNotificationConfig) *UserNotificationConfigDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserNotificationConfigClient) DeleteOneID(id uint) *UserNotificationConfigDeleteOne {
	builder := c.Delete().Where(usernotificationconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserNotificationConfigDeleteOne{builder}
}

// Query returns a query builder for UserNotificationConfig.
func (c *UserNotificationConfigClient) Query() *UserNotificationConfigQuery {
	return &UserNotificationConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserNotificationConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a UserNotificationConfig entity by its id.
func (c *UserNotificationConfigClient) Get(ctx context.Context, id uint) (*UserNotificationConfig, error) {
	return c.Query().Where(usernotificationconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserNotificationConfigClient) GetX(ctx context.Context, id uint) *UserNotificationConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserNotificationConfig.
func (c *UserNotificationConfigClient) QueryUser(_m *UserNotificationConfig) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usernotificationconfig.Table, usernotificationconfig.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usernotificationconfig.UserTable, usernotificationconfig.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotificationType queries the notification_type edge of a UserNotificationConfig.
func (c *UserNotificationConfigClient) QueryNotificationType(_m *UserNotificationConfig) *NotificationTypeQuery {
	query := (&NotificationTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usernotificationconfig.Table, usernotificationconfig.FieldID, id),
			sqlgraph.To(notificationtype.Table, notificationtype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usernotificationconfig.NotificationTypeTable, usernotificationconfig.NotificationTypeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserNotificationConfigClient) Hooks() []Hook {
	return c.hooks.UserNotificationConfig
}

// Interceptors returns the client interceptors.
func (c *UserNotificationConfigClient) Interceptors() []Interceptor {
	return c.inters.UserNotificationConfig
}

func (c *UserNotificationConfigClient) mutate(ctx context.Context, m *UserNotificationConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserNotificationConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserNotificationConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserNotificationConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserNotificationConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserNotificationConfig mutation op: %q", m.Op())
	}
}

// VisitorLogClient is a client for the VisitorLog schema.
type VisitorLogClient struct {
	config
}

// NewVisitorLogClient returns a client for the VisitorLog from the given config.
func NewVisitorLogClient(c config) *VisitorLogClient {
	return &VisitorLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `visitorlog.Hooks(f(g(h())))`.
func (c *VisitorLogClient) Use(hooks ...Hook) {
	c.hooks.VisitorLog = append(c.hooks.VisitorLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `visitorlog.Intercept(f(g(h())))`.
func (c *VisitorLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.VisitorLog = append(c.inters.VisitorLog, interceptors...)
}

// Create returns a builder for creating a VisitorLog entity.
func (c *VisitorLogClient) Create() *VisitorLogCreate {
	mutation := newVisitorLogMutation(c.config, OpCreate)
	return &VisitorLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VisitorLog entities.
func (c *VisitorLogClient) CreateBulk(builders ...*VisitorLogCreate) *VisitorLogCreateBulk {
	return &VisitorLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VisitorLogClient) MapCreateBulk(slice any, setFunc func(*VisitorLogCreate, int)) *VisitorLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VisitorLogCreateBulk{err: fmt.Errorf("calling to VisitorLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VisitorLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VisitorLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VisitorLog.
func (c *VisitorLogClient) Update() *VisitorLogUpdate {
	mutation := newVisitorLogMutation(c.config, OpUpdate)
	return &VisitorLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VisitorLogClient) UpdateOne(_m *VisitorLog) *VisitorLogUpdateOne {
	mutation := newVisitorLogMutation(c.config, OpUpdateOne, withVisitorLog(_m))
	return &VisitorLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VisitorLogClient) UpdateOneID(id uint) *VisitorLogUpdateOne {
	mutation := newVisitorLogMutation(c.config, OpUpdateOne, withVisitorLogID(id))
	return &VisitorLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VisitorLog.
func (c *VisitorLogClient) Delete() *VisitorLogDelete {
	mutation := newVisitorLogMutation(c.config, OpDelete)
	return &VisitorLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VisitorLogClient) DeleteOne(_m *VisitorLog) *VisitorLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VisitorLogClient) DeleteOneID(id uint) *VisitorLogDeleteOne {
	builder := c.Delete().Where(visitorlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VisitorLogDeleteOne{builder}
}

// Query returns a query builder for VisitorLog.
func (c *VisitorLogClient) Query() *VisitorLogQuery {
	return &VisitorLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVisitorLog},
		inters: c.Interceptors(),
	}
}

// Get returns a VisitorLog entity by its id.
func (c *VisitorLogClient) Get(ctx context.Context, id uint) (*VisitorLog, error) {
	return c.Query().Where(visitorlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VisitorLogClient) GetX(ctx context.Context, id uint) *VisitorLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VisitorLogClient) Hooks() []Hook {
	return c.hooks.VisitorLog
}

// Interceptors returns the client interceptors.
func (c *VisitorLogClient) Interceptors() []Interceptor {
	return c.inters.VisitorLog
}

func (c *VisitorLogClient) mutate(ctx context.Context, m *VisitorLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VisitorLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VisitorLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VisitorLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VisitorLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VisitorLog mutation op: %q", m.Op())
	}
}

// VisitorStatClient is a client for the VisitorStat schema.
type VisitorStatClient struct {
	config
}

// NewVisitorStatClient returns a client for the VisitorStat from the given config.
func NewVisitorStatClient(c config) *VisitorStatClient {
	return &VisitorStatClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `visitorstat.Hooks(f(g(h())))`.
func (c *VisitorStatClient) Use(hooks ...Hook) {
	c.hooks.VisitorStat = append(c.hooks.VisitorStat, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `visitorstat.Intercept(f(g(h())))`.
func (c *VisitorStatClient) Intercept(interceptors ...Interceptor) {
	c.inters.VisitorStat = append(c.inters.VisitorStat, interceptors...)
}

// Create returns a builder for creating a VisitorStat entity.
func (c *VisitorStatClient) Create() *VisitorStatCreate {
	mutation := newVisitorStatMutation(c.config, OpCreate)
	return &VisitorStatCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VisitorStat entities.
func (c *VisitorStatClient) CreateBulk(builders ...*VisitorStatCreate) *VisitorStatCreateBulk {
	return &VisitorStatCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VisitorStatClient) MapCreateBulk(slice any, setFunc func(*VisitorStatCreate, int)) *VisitorStatCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VisitorStatCreateBulk{err: fmt.Errorf("calling to VisitorStatClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VisitorStatCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VisitorStatCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VisitorStat.
func (c *VisitorStatClient) Update() *VisitorStatUpdate {
	mutation := newVisitorStatMutation(c.config, OpUpdate)
	return &VisitorStatUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VisitorStatClient) UpdateOne(_m *VisitorStat) *VisitorStatUpdateOne {
	mutation := newVisitorStatMutation(c.config, OpUpdateOne, withVisitorStat(_m))
	return &VisitorStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VisitorStatClient) UpdateOneID(id uint) *VisitorStatUpdateOne {
	mutation := newVisitorStatMutation(c.config, OpUpdateOne, withVisitorStatID(id))
	return &VisitorStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VisitorStat.
func (c *VisitorStatClient) Delete() *VisitorStatDelete {
	mutation := newVisitorStatMutation(c.config, OpDelete)
	return &VisitorStatDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VisitorStatClient) DeleteOne(_m *VisitorStat) *VisitorStatDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VisitorStatClient) DeleteOneID(id uint) *VisitorStatDeleteOne {
	builder := c.Delete().Where(visitorstat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VisitorStatDeleteOne{builder}
}

// Query returns a query builder for VisitorStat.
func (c *VisitorStatClient) Query() *VisitorStatQuery {
	return &VisitorStatQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVisitorStat},
		inters: c.Interceptors(),
	}
}

// Get returns a VisitorStat entity by its id.
func (c *VisitorStatClient) Get(ctx context.Context, id uint) (*VisitorStat, error) {
	return c.Query().Where(visitorstat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VisitorStatClient) GetX(ctx context.Context, id uint) *VisitorStat {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VisitorStatClient) Hooks() []Hook {
	return c.hooks.VisitorStat
}

// Interceptors returns the client interceptors.
func (c *VisitorStatClient) Interceptors() []Interceptor {
	return c.inters.VisitorStat
}

func (c *VisitorStatClient) mutate(ctx context.Context, m *VisitorStatMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VisitorStatCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VisitorStatUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VisitorStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VisitorStatDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VisitorStat mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Album, Article, Comment, DirectLink, Entity, File, FileEntity, Link,
		LinkCategory, LinkTag, Metadata, NotificationType, Page, PostCategory, PostTag,
		Setting, StoragePolicy, Tag, URLStat, User, UserGroup, UserInstalledTheme,
		UserNotificationConfig, VisitorLog, VisitorStat []ent.Hook
	}
	inters struct {
		Album, Article, Comment, DirectLink, Entity, File, FileEntity, Link,
		LinkCategory, LinkTag, Metadata, NotificationType, Page, PostCategory, PostTag,
		Setting, StoragePolicy, Tag, URLStat, User, UserGroup, UserInstalledTheme,
		UserNotificationConfig, VisitorLog, VisitorStat []ent.Interceptor
	}
)
